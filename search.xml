<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Helm 安装使用]]></title>
      <url>/2019/08/08/Helm-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>其实 Helm 的安装很简单，之所以单独写这篇文章主要是因为国内网络原因导致 helm 使用存在障碍(防火墙对 google 不友好)，本文重点说如何解决这一问题。</p>
<h4 id="helm-安装"><a href="#helm-安装" class="headerlink" title="helm 安装"></a>helm 安装</h4><p>官方提供了一件安装脚本，安装最新版：<a href="https://helm.sh/docs/using_helm/#installing-helm" target="_blank" rel="noopener">https://helm.sh/docs/using_helm/#installing-helm</a><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L <span class="string">https:</span><span class="comment">//git.io/get_helm.sh | bash</span></span><br></pre></td></tr></table></figure></p>
<h4 id="创建服务账号和角色绑定"><a href="#创建服务账号和角色绑定" class="headerlink" title="创建服务账号和角色绑定"></a>创建服务账号和角色绑定</h4><p>rbac-config.yaml:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">  - kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">tiller</span></span><br><span class="line"><span class="attr">    namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f rbac-config.yaml</span><br></pre></td></tr></table></figure>
<h4 id="helm-init-初始化"><a href="#helm-init-初始化" class="headerlink" title="helm init 初始化"></a>helm init 初始化</h4><p>国内无法访问 gcr.io 仓库，指定阿里云镜像仓库，同时制定前面创建的服务账号：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm init --service-account tiller -<span class="selector-tag">i</span> registry<span class="selector-class">.aliyuncs</span><span class="selector-class">.com</span>/google_containers/tiller:v2.<span class="number">14.3</span></span><br></pre></td></tr></table></figure></p>
<p>国内也无法访问 helm 默认的 Chart 仓库，所以也改成阿里云 Chart 镜像仓库：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm repo remove stable</span><br><span class="line">helm repo add stable https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Kubernetes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Kubeadm 结合 Vagrant 自动化部署最新版 Kubernetes 集群]]></title>
      <url>/2019/08/06/Kubeadm-%E7%BB%93%E5%90%88-Vagrant-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E6%9C%80%E6%96%B0%E7%89%88-Kubernetes-%E9%9B%86%E7%BE%A4/</url>
      <content type="html"><![CDATA[<p>之前写过一篇搭建 k8s 集群的教程：<a href="https://qhh.me/2019/03/19/%E4%BD%BF%E7%94%A8-kubeadm-%E6%90%AD%E5%BB%BA-kubernetes-%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">「使用 kubeadm 搭建 kubernetes 集群」</a>，教程中用到了 kubeadm 和 vagrant，但是整个过程还是手动一步一步完成：<code>创建节点--&gt; 节点配置、相关软件安装  --&gt; 初始化 master 节点 --&gt; node 节点加入 master 节点</code>。其实这个过程完全可以通过 Vagrant 的配置器自动化来实现，达到的目的是启动一个 k8s 只需在 Vagrant 工程目录执行：vagrant up 即可一键完成集群的创建。</p>
<p>本文主要介绍如何使用 Kubeadm 结合 Vagrant 自动化 k8s 集群的创建，在了解了 kubeadm 手动搭建 kubernetes 集群的过程后，自动化就简单了，如果不了解请参见之前的文章：<a href="https://qhh.me/2019/03/19/%E4%BD%BF%E7%94%A8-kubeadm-%E6%90%AD%E5%BB%BA-kubernetes-%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">「使用 kubeadm 搭建 kubernetes 集群」</a>，梳理下整个过程，在此不做过多介绍。下面大概介绍下自动化流程：</p>
<ol>
<li><p>首先抽象出来每个节点需要执行的通用脚本，完成一些常用软件的安装、docker 安装、kubectl 和 kubeadm 安装，还有一些节点的系统级配置：<br>具体实现脚本见：<a href="https://github.com/qhh0205/kubeadm-vagrant/blob/master/install-centos.sh" target="_blank" rel="noopener">https://github.com/qhh0205/kubeadm-vagrant/blob/master/install-centos.sh</a></p>
</li>
<li><p>编写 Vagrantfile，完成主节点的初始化安装和 node 节点加入主节点。但是有个地方和之前手动安装不太一样，为了自动化，我们必须在 kubeadm 初始化 master 节点之前生成 TOKEN（使用其他任意主机的 kubeadm 工具生成 TOKEN 即可），然后自动化脚本统一用这个 TOKEN 初始化主节点和从节点加入。Vagrantfile 具体实现见：<a href="https://github.com/qhh0205/kubeadm-vagrant/blob/master/Vagrantfile" target="_blank" rel="noopener">https://github.com/qhh0205/kubeadm-vagrant/blob/master/Vagrantfile</a></p>
</li>
</ol>
<p>完整的 Vagrant 工程在这里：<a href="https://github.com/qhh0205/kubeadm-vagrant" target="_blank" rel="noopener">https://github.com/qhh0205/kubeadm-vagrant</a><br>使用 kubeadm + vagrant 自动化部署 k8s 集群，基于 Centos7 操作系统。该工程 fork 自 <a href="https://github.com/coolsvap/kubeadm-vagrant" target="_blank" rel="noopener">kubeadm-vagrant</a>, 对已知问题进行了修复：节点设置正确的 IP 地址<a href="https://github.com/qhh0205/kubeadm-vagrant/blob/master/set-k8s-node-ip.sh" target="_blank" rel="noopener">「set-k8s-node-ip.sh」</a>。否则使用过程中会出现问题，具体问题见这里：<a href="https://qhh.me/2019/08/06/kubeadm-vagrant-%E9%83%A8%E7%BD%B2%E5%A4%9A%E8%8A%82%E7%82%B9-k8s-%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/" target="_blank" rel="noopener">「kubeadm + vagrant 部署多节点 k8s 的一个坑」</a>。其他一些调整：节点初始化脚本更改、Vagrantfile 添加 Shell 脚本配置器，运行初始化脚本。</p>
<blockquote>
<p>默认：1 个 master 节点，1 个 node 节点，可以根据需要修改 Vagrantfile 文件，具体见工程 <a href="https://github.com/qhh0205/kubeadm-vagrant/blob/master/README.md" target="_blank" rel="noopener">README.md</a> 说明。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Kubernetes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kubeadm + vagrant 部署多节点 k8s 的一个坑]]></title>
      <url>/2019/08/06/kubeadm-vagrant-%E9%83%A8%E7%BD%B2%E5%A4%9A%E8%8A%82%E7%82%B9-k8s-%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>之前写过一篇<a href="https://qhh.me/2019/03/19/%E4%BD%BF%E7%94%A8-kubeadm-%E6%90%AD%E5%BB%BA-kubernetes-%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">「使用 kubeadm 搭建 kubernetes 集群」</a>教程，教程里面使用 Vagrant 启动 3 个节点，1 个 master，2 个 node 节点，后来使用过程中才慢慢发现还是存在问题的。具体问题表现是：</p>
<ol>
<li><p>kubectl get node -o wide 查看到节点 IP 都是：10.0.2.15；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl get node -o wide</span></span><br><span class="line">NAME     STATUS   ROLES    AGE     VERSION   INTERNAL-IP   EXTERNAL-IP   OS-IMAGE                KERNEL-VERSION              CONTAINER-RUNTIME</span><br><span class="line">master   Ready    master   5m11s   v1.15.1   10.0.2.15     &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-862.2.3.el7.x86_64   docker://19.3.1</span><br><span class="line">node1    Ready    &lt;none&gt;   2m31s   v1.15.1   10.0.2.15     &lt;none&gt;        CentOS Linux 7 (Core)   3.10.0-862.2.3.el7.x86_64   docker://19.3.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>kubect get pod 可以查看 pod，pod 也运行正常，但是无法查看 pod 日志，也无法 kubectl exec -it 进入 pod。具体报错如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># kubectl get pod</span></span><br><span class="line">NAME                                READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-deployment-5754944d6c-gnqjg   1/1     Running   0          66s</span><br><span class="line">nginx-deployment-5754944d6c-mxgn7   1/1     Running   0          66s</span><br><span class="line"></span><br><span class="line">[root@master ~]<span class="comment"># kubectl logs nginx-deployment-5754944d6c-gnqjg</span></span><br><span class="line">Error from server (NotFound): the server could not find the requested resource ( pods/<span class="built_in">log</span> nginx-deployment-5754944d6c-gnqjg)</span><br><span class="line"></span><br><span class="line">[root@master ~]<span class="comment"># kubectl exec -it nginx-deployment-5754944d6c-gnqjg sh</span></span><br><span class="line">error: unable to upgrade connection: pod does not exist</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>带着上面两个问题，于是网上搜索一番，找到了根因并得以解决：<br><a href="https://github.com/kubernetes/kubernetes/issues/60835" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/60835</a></p>
<h4 id="主要原因"><a href="#主要原因" class="headerlink" title="主要原因"></a>主要原因</h4><p>Vagrant 在多主机模式时每个主机的 eth0 网口 ip 都是 10.0.2.15，这个网口是所有主机访问公网的出口，用于 nat 转发。而 eth1才是主机真正的 IP。kubelet 在启动时默认读取的是 eth0 网卡的 IP，因此在集群部署完后 kubect get node -o wide 查看到节点的 IP 都是 10.0.2.15。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@master ~]$<span class="built_in"> ip </span>addr</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP<span class="built_in"> group default </span>qlen 1000</span><br><span class="line">    link/ether 52:54:00:c9:c7:04 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0</span><br><span class="line">       valid_lft 85708sec preferred_lft 85708sec</span><br><span class="line">    inet6 fe80::5054:ff:fec9:c704/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP<span class="built_in"> group default </span>qlen 1000</span><br><span class="line">    link/ether 08:00:27:25:1b:45 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.26.10/24 brd 192.168.26.255 scope global noprefixroute eth1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::a00:27ff:fe25:1b45/64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>上面知道问题的根本原因是 k8s 节点 IP 获取不对导致访问节点出现问题，那么解决方法就是调整 kubelet 参数设置正确的<br>IP 地址：<br>编辑 /etc/sysconfig/kubelet 文件，KUBELET_EXTRA_ARGS 环境变量添加 <code>--node-ip</code> 参数：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">KUBELET_EXTRA_ARGS</span>=<span class="string">"--node-ip=&lt;eth1 网口 IP&gt;"</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启 kubelet：systemctl restart kubelet<br>执行 kubectl get node -o wide 发现节点 IP 已经改变成了KUBELET_EXTRA_ARGS 变量指定的 IP。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# kubectl get node -o wide</span><br><span class="line">NAME     STATUS   ROLES    AGE   VERSION   INTERNAL-<span class="built_in">IP</span>     EXTERNAL-<span class="built_in">IP</span>   OS-IMAGE                KERNEL-VERSION              CONTAINER-RUNTIME</span><br><span class="line">master   Ready    master   24m   v1<span class="meta">.15</span><span class="meta">.1</span>   <span class="number">192.168</span><span class="meta">.26</span><span class="meta">.10</span>   &lt;none&gt;        CentOS Linux <span class="number">7</span> (Core)   <span class="number">3.10</span><span class="meta">.0</span>-<span class="number">862.2</span><span class="meta">.3</span>.el7.x86_64   docker://<span class="number">19.3</span><span class="meta">.1</span></span><br><span class="line">node1    Ready    &lt;none&gt;   21m   v1<span class="meta">.15</span><span class="meta">.1</span>   <span class="number">10.0</span><span class="meta">.2</span><span class="meta">.15</span>       &lt;none&gt;        CentOS Linux <span class="number">7</span> (Core)   <span class="number">3.10</span><span class="meta">.0</span>-<span class="number">862.2</span><span class="meta">.3</span>.el7.x86_64   docker://<span class="number">19.3</span><span class="meta">.1</span></span><br></pre></td></tr></table></figure></p>
<p>用同样的方法修改其他节点 IP 即可。<br>为了方便，这里提供了一个命令，自动化上面步骤：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> KUBELET_EXTRA_ARGS=\<span class="string">"--node-ip=`ip addr show eth1 | grep inet | grep -E -o "</span>([0-9]&#123;1,3&#125;[\.])&#123;3&#125;[0-9]&#123;1,3&#125;/<span class="string">" | tr -d '/'`\" &gt; /etc/sysconfig/kubelet</span></span><br><span class="line"><span class="string">systemctl restart kubelet</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Kubenetes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubenetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jenkins 集成 allure 测试报告工具]]></title>
      <url>/2019/07/25/Jenkins-%E9%9B%86%E6%88%90-allure-%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p><a href="https://docs.qameta.io/allure/" target="_blank" rel="noopener">allure</a> 基于已有的测试报告数据进行进一步的加工，美化等操作，相当于做了一次数据格式转换。allure 支持多种语言的多种测试框架，比如 Java 的 jUnit4、jUnit5、TestNg 等等。</p>
<p>本文主要介绍如何在 Jenkins 中集成 allure 测试报表工具，在每次项目自动化测试完成后，用 allure 生成经过加工后的测试报告。我们以 java 工程的 TestNg 测试为例，处理 TestNg 生成的测试报告。</p>
<ul>
<li><p>Jenkins 安装 allure 插件<br>全局工具配置：</p>
<p>  <img src="/images/jenkins-allure4.png" alt=""></p>
</li>
<li><p>Jenkinsfile 添加 allure 代码</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">script</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">allure</span> <span class="attr">jdk:</span> <span class="string">''</span><span class="string">,</span> <span class="attr">report:</span> <span class="string">"target/allure-report-unit"</span><span class="string">,</span> <span class="attr">results:</span> <span class="string">[[path:</span> <span class="string">"target/surefire-reports"</span><span class="string">]]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>  <code>target/allure-report-unit</code> 参数：allure 报告生成路径；<br>  <code>target/surefire-reports</code> 参数：测试报告原始路径；</p>
</li>
<li><p>Jenkins 平台查看 allure 报告<br>在 allure 成功集成到 Jenkins 后，allure 每次处理完成，在 Jenkins job 页面都可以看到 allure 的图标，点击图标即可查看报告详细信息:</p>
<p>  <img src="/images/jenkins-allure1.png" alt=""></p>
<p>  <img src="/images/jenkins-allure2.png" alt=""></p>
</li>
</ul>
<h3 id="遇到问题及解决方法"><a href="#遇到问题及解决方法" class="headerlink" title="遇到问题及解决方法"></a>遇到问题及解决方法</h3><p>问题：<br>allure 在 Jenkins pipline 中生成报表时报目录权限问题：java.nio.file.AccessDeniedException</p>
<p><img src="/images/jenkins-allure3.png" alt=""></p>
<p>原因：<br>jenkins k8s pod 执行 job 时默认用户为 jenkins，但是 pipeline 中调用的容器生成的文件的属主是 root。<br>解决方法：<br>配置 jenkins k8s 插件模版，添加安全配置，运行用户设置为 root<br><a href="https://groups.google.com/forum/#!topic/jenkinsci-users/GR0n8ZkCJ-E" target="_blank" rel="noopener">https://groups.google.com/forum/#!topic/jenkinsci-users/GR0n8ZkCJ-E</a></p>
<p>pod 配置（spec 下）：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">securityContext:</span></span><br><span class="line"><span class="attr">    runAsUser:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">    fsGroup:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://docs.qameta.io/allure/" target="_blank" rel="noopener">https://docs.qameta.io/allure/</a></p>
]]></content>
      
        <categories>
            
            <category> DevOps </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Go 开发命令行应用]]></title>
      <url>/2019/07/24/%E4%BD%BF%E7%94%A8-Go-%E5%BC%80%E5%8F%91%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>作为一个程序员，命令行工具是我们再熟悉不过的了，我们每天或多或少都会用到命令行工具。比如项目构建、打包、启动等等。那么如何用 Go 语言编写类似的工具呢？调研了下，大概有下面三种方法：</p>
<ul>
<li><strong>os.Args 函数</strong><br>os.Args 功能类似于 Shell 脚本的 <code>$@</code> 功能，获取到命令行输入，然后进行人工解析处理，这种方式对于编写简单的工具还行，对于复杂点的工具，光解析输入参数就是一场”灾难”了。</li>
<li><strong>使用 Go 标准 <a href="https://go-zh.org/pkg/flag/" target="_blank" rel="noopener">flag</a> 包</strong><br><a href="https://go-zh.org/pkg/flag/" target="_blank" rel="noopener">flag</a> 包是 Golang 官方提供的命令行参数解析包，省去人工解析工作，对于构建一个一般功能的命令行应用足够了，但是对于复杂应用还是显得比较麻烦。</li>
<li><strong>使用第三方包 <a href="https://github.com/urfave/cli" target="_blank" rel="noopener">cli</a> 或者 <a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">cobra</a></strong><br>使用第三方包就比较专业了，提供的功能更加丰富，使用起来也很顺手。目前对于 Golang 命令行应用开发业界比较主流的就是 <a href="https://github.com/urfave/cli" target="_blank" rel="noopener">cli</a> 和 <a href="https://github.com/spf13/cobra" target="_blank" rel="noopener">cobra</a> 了。其实两者的流行度差不多，cobra 的学习成本稍微高点，而且更加专业，看文档介绍，Kubernetes、Moby、rkt、etcd 等都是基于 cobra 构建。我个人更推荐使用 <a href="https://github.com/urfave/cli" target="_blank" rel="noopener">cli</a>，因为 cli 比较轻量级、容易学习，使用起来也更加得心应手，对于开发日常应用足够了。</li>
</ul>
<p>本文主要介绍后面两种方式，即 flag 包和第三方包 cli 的使用，对于 cobra 的使用这里不做具体介绍。</p>
<h3 id="使用-flag-包构建命令行应用"><a href="#使用-flag-包构建命令行应用" class="headerlink" title="使用 flag 包构建命令行应用"></a>使用 flag 包构建命令行应用</h3><p> flag 包的使用很简单，能很方便地解析命令行输入，支持的命令行参数类型有  bool, int, uint, string, time.Duration, float 类型，另外还可以自定义类型。这里介绍下一般的使用方法，假如要开发一个命令行工具，使用方式：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="keyword">go</span>-curl -v -X <span class="string">"GET"</span> https:<span class="comment">//example.com</span></span><br></pre></td></tr></table></figure></p>
<p>具体实现代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个 bool 类型的参数，默认值为 false，第三个参数为 Usage 说明</span></span><br><span class="line">	<span class="comment">// 函数返回值为对应类型的指针</span></span><br><span class="line">	v := flag.Bool(<span class="string">"v"</span>, <span class="literal">false</span>, <span class="string">"Makes  curl  verbose  during the operation."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个 String 类型的参数，默认值为 GET，第三个参数为 Usage 说明</span></span><br><span class="line">	<span class="comment">// 与上面那种不同的是函数第一个参数为变量的指针</span></span><br><span class="line">	<span class="keyword">var</span> X <span class="keyword">string</span></span><br><span class="line">	flag.StringVar(&amp;X, <span class="string">"X"</span>, <span class="string">"GET"</span>, <span class="string">"(HTTP) Specifies a custom request method to use when communicating with the HTTP server."</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在参数定义完后必须调用 flag.Parse() 完成命令行参数的解析</span></span><br><span class="line">	flag.Parse()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回其余参数的列表</span></span><br><span class="line">	args := flag.Args()</span><br><span class="line">	fmt.Printf(<span class="string">"v: %t, X: %s, args: %v\n"</span>, *v, X, args)</span><br><span class="line">	os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出定义参数有两种方式：</p>
<ul>
<li>指针类型参数：调用函数为 <code>flag.Type</code> 形式，返回值为对应类型的指针；</li>
<li>值类型参数：调用函数为 <code>flag.TypeVar</code> 形式，调用时传递变量的指针；</li>
</ul>
<p>两种方法效果都是一样的，只不过一种解析返回的是指针，另一种是直接使用变量。</p>
<h3 id="使用-cli-包构建命令行应用"><a href="#使用-cli-包构建命令行应用" class="headerlink" title="使用 cli 包构建命令行应用"></a>使用 cli 包构建命令行应用</h3><p>使用 cli 包开发命令行工具能省很多事，而且写出来的代码结构非常清晰，很容易理解。具体使用见代码仓库 <a href="https://github.com/urfave/cli" target="_blank" rel="noopener">README.md</a> 。在这里举一个例子，我最近写的服务部署命令行工具：<a href="https://github.com/qhh0205/deploy-kit" target="_blank" rel="noopener">https://github.com/qhh0205/deploy-kit</a>   通过看官方文档结合这个例子能很容易掌握 cli 包的是使用技巧。下面为该部署工具的 <code>--help</code> 输出：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NAME:</span><br><span class="line">   deploy - deploy application</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">   deploy [global options] command [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">VERSION:</span><br><span class="line">   v1<span class="number">.0</span></span><br><span class="line"></span><br><span class="line">COMMANDS:</span><br><span class="line">     list, ls           list all of services</span><br><span class="line">     app                deploy microservice application</span><br><span class="line">     web                deploy web application</span><br><span class="line">     lsbranch, lsb      list the code branches of service</span><br><span class="line">     upload-cdn, upcdn  upload file or directory to gcs bucket</span><br><span class="line">     help, h            Shows a list of commands or help <span class="keyword">for</span> one command</span><br><span class="line"></span><br><span class="line">GLOBAL OPTIONS:</span><br><span class="line">   --help, -h     show help</span><br><span class="line">   --version, -v  <span class="built_in">print</span> the version</span><br></pre></td></tr></table></figure></p>
<p>该工具基于 cli 包构建，cli 包的使用核心是通过 <code>app.Commands = []cli.Command{}</code>  定义一些列命令、选项，并且通过 <code>Action</code> 绑定对应选项参数的处理函数。</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://github.com/urfave/cli" target="_blank" rel="noopener">https://github.com/urfave/cli</a> | cli GitHub<br><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter13/13.1.html" target="_blank" rel="noopener">https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter13/13.1.html</a> | flag 包介绍<br><a href="https://blog.yumaojun.net/2016/12/30/go-cobra/" target="_blank" rel="noopener">https://blog.yumaojun.net/2016/12/30/go-cobra/</a> | cobra 使用，如何使用golang编写漂亮的命令行工具<br><a href="https://blog.rapid7.com/2016/08/04/build-a-simple-cli-tool-with-golang/" target="_blank" rel="noopener">https://blog.rapid7.com/2016/08/04/build-a-simple-cli-tool-with-golang/</a> | Building a Simple CLI Tool with Golang<br><a href="https://medium.com/what-i-talk-about-when-i-talk-about-technology/dealing-with-command-line-options-in-golang-flag-package-e5fb6ef1a79e" target="_blank" rel="noopener">https://medium.com/what-i-talk-about-when-i-talk-about-technology/dealing-with-command-line-options-in-golang-flag-package-e5fb6ef1a79e</a> | Dealing with Command Line Options in Golang: flag package</p>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Golang 协程顺序打印]]></title>
      <url>/2019/07/23/Golang-%E5%8D%8F%E7%A8%8B%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0/</url>
      <content type="html"><![CDATA[<h3 id="A、B-两个协程分别打印-1、2、3、4-和-A，B，C，D"><a href="#A、B-两个协程分别打印-1、2、3、4-和-A，B，C，D" class="headerlink" title="A、B 两个协程分别打印 1、2、3、4 和 A，B，C，D"></a>A、B 两个协程分别打印 1、2、3、4 和 A，B，C，D</h3><p>实现：定义 A、B 两个 channal，开 A、B 两个协程，A 协程输出[1, 2, 3, 4]、B 协程输出[A, B, C, D]，通过两个独立的 channal 控制顺序，交替输出。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	A := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	B := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	Exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> ok := &lt;-A; ok &#123;</span><br><span class="line">				fmt.Println(<span class="string">"A: "</span>, s[i])</span><br><span class="line">				B &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">close</span>(Exit)</span><br><span class="line">		&#125;()</span><br><span class="line">		s := []<span class="keyword">byte</span>&#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> ok := &lt;-B; ok &#123;</span><br><span class="line">				fmt.Printf(<span class="string">"B: %c\n"</span>, s[i])</span><br><span class="line">				A &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	A &lt;- <span class="literal">true</span></span><br><span class="line">	&lt;-Exit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="A、B-两个协程顺序打印-1-20"><a href="#A、B-两个协程顺序打印-1-20" class="headerlink" title="A、B 两个协程顺序打印 1~20"></a>A、B 两个协程顺序打印 1~20</h3><p>实现：与上面基本一样，定义 A、B 两个 channal，开 A、B 两个协程，A 协程输出奇数、B 协程输出偶数，通过两个独立的 channal 控制顺序，交替输出。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	A := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">1</span>)</span><br><span class="line">	B := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	Exit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> ok := &lt;-A; ok &#123;</span><br><span class="line">				fmt.Println(<span class="string">"A = "</span>, <span class="number">2</span>*i<span class="number">-1</span>)</span><br><span class="line">				B &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="built_in">close</span>(Exit)</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> ok := &lt;-B; ok &#123;</span><br><span class="line">				fmt.Println(<span class="string">"B : "</span>, <span class="number">2</span>*i)</span><br><span class="line">				A &lt;- <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	A &lt;- <span class="literal">true</span></span><br><span class="line">	&lt;-Exit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go 语言 exec 实时获取外部命令的执行输出]]></title>
      <url>/2019/07/20/Go-%E8%AF%AD%E8%A8%80-exec-%E5%AE%9E%E6%97%B6%E8%8E%B7%E5%8F%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BE%93%E5%87%BA/</url>
      <content type="html"><![CDATA[<p>在 Go 语言中调用外部 Linux 命令可以通过标准的 <a href="https://go-zh.org/pkg/os/exec/" target="_blank" rel="noopener">os/exec</a> 包实现，我们一般的使用方式如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"ls"</span>, <span class="string">"-al"</span>)</span><br><span class="line">	output, _ := cmd.CombinedOutput()</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(output))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这种使用方式虽然能获取到外部命令的执行结果输出 output，但是必须得命令执行完成后才将获取到的结果一次性返回。很多时候我们是需要实时知道命令执行的输出，比如我们调用一个外部的服务构建命令： <code>mvn build</code>，这种情况下实时输出命令执行的结果对我们来说很重要。再比如我们 ping 远程 IP，需要知道实时输出，如果直接 ping 完在输出，在使用上来说体验不好。</p>
<p>要实现外部命令执行结果的实时输出，需要使用 <code>Cmd</code> 结构的 <code>StdoutPipe()</code> 方法创建一个管道连接到命令执行的输出，然后用 for 循环从管道中实时读取命令执行的输出并打印到终端。具体代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunCommand</span><span class="params">(name <span class="keyword">string</span>, arg ...<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(name, arg...)</span><br><span class="line">    <span class="comment">// 命令的错误输出和标准输出都连接到同一个管道</span></span><br><span class="line">	stdout, err := cmd.StdoutPipe()</span><br><span class="line">	cmd.Stderr = cmd.Stdout</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err = cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 从管道中实时获取输出并打印到终端</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		tmp := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">		_, err := stdout.Read(tmp)</span><br><span class="line">		fmt.Print(<span class="keyword">string</span>(tmp))</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err = cmd.Wait(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Go 语言读写文件]]></title>
      <url>/2019/07/15/Go-%E8%AF%AD%E8%A8%80%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>在这里演示下如何通过 Go 读写文件，Go 读写文件有很 IO 多函数可以使用，在这里使用 os 包的 OpenFile 和 Open 函数打开文件，然后用 bufio 包带缓冲的读写器读写文件。查看 OpenFile 源码，其实 Open 函数底层还是调用了 OpenFile。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bufio"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//           写文件</span></span><br><span class="line">	outputFile, outputError := os.OpenFile(<span class="string">"file.txt"</span>, os.O_WRONLY|os.O_CREATE|os.O_APPEND, <span class="number">0666</span>)</span><br><span class="line">	<span class="keyword">if</span> outputError != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(outputError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> outputFile.Close()</span><br><span class="line">	outputWriter := bufio.NewWriter(outputFile)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		outputWriter.WriteString(<span class="string">"hello, world\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 一定得记得将缓冲区内容刷新到磁盘文件</span></span><br><span class="line">	outputWriter.Flush()</span><br><span class="line">	<span class="comment">//           读文件</span></span><br><span class="line">	inputFile, inputError := os.Open(<span class="string">"file.txt"</span>)</span><br><span class="line">	<span class="keyword">if</span> inputError != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(inputError)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> inputFile.Close()</span><br><span class="line">	inputReader := bufio.NewReader(inputFile)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		inputString, readerError := inputReader.ReadString(<span class="string">'\n'</span>)</span><br><span class="line">		fmt.Printf(inputString)</span><br><span class="line">		<span class="keyword">if</span> readerError == io.EOF &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自动化测试报表统一平台 ReportPortal 集成 TestNG]]></title>
      <url>/2019/07/10/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%8A%A5%E8%A1%A8%E7%BB%9F%E4%B8%80%E5%B9%B3%E5%8F%B0-ReportPortal-%E9%9B%86%E6%88%90-TestNG/</url>
      <content type="html"><![CDATA[<p>本文主要介绍 <a href="https://reportportal.io/" target="_blank" rel="noopener">ReportPortal</a> 如何集成 TestNG 测试框架，用到的工具链有：ReportPortal + TestNG + log4j。ReportPortal 集成 TestNG 的主要原理是通过给 TestNG 配置 ReportPortal 的 listener，在测试开始时该监听器将测试信息实时上报给 ReportPortal 平台。另外我们通过给 log4j 配置 ReportPortal appender，将测试过程中代码日志也上报到 ReportPortal 平台。然后 ReportPortal 将收到的数据进行整合、分析，形成平台数据统一展示。</p>
<h4 id="ReportPortal-简介"><a href="#ReportPortal-简介" class="headerlink" title="ReportPortal 简介"></a>ReportPortal 简介</h4><p>ReportPortal 是一个统一的自动化测试报告收集、分析、可视化平台，可以集成多种测试框架，比如 TestNG、Selenium 等等。ReportPortal 的主要特性有：</p>
<ul>
<li>能轻易和多种测试框架集成；<br><img src="/images/rp_feature1.png" alt="Alt text"></li>
<li>实时展示测试情况；</li>
<li>所有的自动化测试结果在一个地方统一查看；</li>
<li>保留历史测试信息；</li>
<li>能和 bug 跟踪系统集成，比如 Jira；</li>
</ul>
<h4 id="ReportPortal-解决了什么问题"><a href="#ReportPortal-解决了什么问题" class="headerlink" title="ReportPortal 解决了什么问题"></a>ReportPortal 解决了什么问题</h4><p>个人认为 ReportPortal 最大的价值在于报表的统一收集、查看、分析。假如没有 ReportPortal 工具，我们可能需要自己写脚本，或者 Jenkins 插件针对不同的测试框架装不同的插件，然后展示测试报告，但是 Jenkins 收集的测试报告只能在 Jenkins 平台查看。微服务拆分细、导致 Jenkins job 数量比较多，要看每次测试的报告要逐个点开进去查看，没有一个全局的地方查看。另外 Jenkins 本身的插件生态提供的测试报告收集不支持对历史测试报告的统一查询，如果有这种需求，基本不能满足。</p>
<p>ReportPortal 基本是全测试框架支持的统一报表收集、分析、可视化平台，能轻松解决上述存在的痛点。</p>
<h4 id="ReportPortal-在-CI-CD-中扮演了什么角色"><a href="#ReportPortal-在-CI-CD-中扮演了什么角色" class="headerlink" title="ReportPortal 在 CI/CD 中扮演了什么角色"></a>ReportPortal 在 CI/CD 中扮演了什么角色</h4><p>CI/CD 我们已经很熟悉了，但是如何将 CI/CD 与 CT 无缝整合，也许 ReportPortal 在 CI/CD 与 CT 的整合中扮演了重要角色。DevOps 的关键在于自动化统一标准、流程，根据 ReportPortal 的特性及本人的试用，发现 ReportPortal 真是对 CI/CD 完美的补充，整个交付流水线更加统一、规范、简洁、无缝衔接。</p>
<p><img src="/images/rp_role_cicd.png" alt="Alt text"></p>
<h3 id="ReportPortal-TestNG-log4j-集成详细步骤"><a href="#ReportPortal-TestNG-log4j-集成详细步骤" class="headerlink" title="ReportPortal + TestNG + log4j 集成详细步骤"></a>ReportPortal + TestNG + log4j 集成详细步骤</h3><p>以一个基于 TestNG 测试框架的 java 工程为例说明，配置前 java 工程目录结构：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">├── README.md</span><br><span class="line">├── run.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── config.properties</span><br><span class="line">    │       ├── dev.yml</span><br><span class="line">    │       ├── log4j.properties</span><br><span class="line">    │       ├── log4testng.properties</span><br><span class="line">    │       ├── production.yml</span><br><span class="line">    │       ├── stage.yml</span><br><span class="line">    │       ├── test.yml</span><br><span class="line">    │       └── web.yml</span><br><span class="line">    └── test</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        └── resources</span><br><span class="line">            └── testng.xml</span><br></pre></td></tr></table></figure></p>
<h4 id="1-配置工程-pom-文件"><a href="#1-配置工程-pom-文件" class="headerlink" title="1. 配置工程 pom 文件"></a>1. 配置工程 pom 文件</h4><h5 id="1-1-配置-ReportPortal-相关依赖远程仓库"><a href="#1-1-配置-ReportPortal-相关依赖远程仓库" class="headerlink" title="1.1 配置 ReportPortal 相关依赖远程仓库"></a>1.1 配置 ReportPortal 相关依赖远程仓库</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>bintray<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://dl.bintray.com/epam/reportportal<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>jitpack.io<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://jitpack.io<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="1-2-添加一些依赖配置"><a href="#1-2-添加一些依赖配置" class="headerlink" title="1.2 添加一些依赖配置"></a>1.2 添加一些依赖配置</h5><p><strong>testng 依赖</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>ReportPortal agent 的 testng 实现</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.epam.reportportal<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>agent-java-testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>添加 Rport Portal 的 log 包装以及 log4j 本身的配置</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.epam.reportportal<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logger-java-log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.26<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="1-3-maven-surefire-plugin-插件配置"><a href="#1-3-maven-surefire-plugin-插件配置" class="headerlink" title="1.3 maven-surefire-plugin 插件配置"></a>1.3 maven-surefire-plugin 插件配置</h5><p>说明：<br>src/test/resources/testng.xml：tesng 执行测试用例时读取的文件，该文件指定执行哪些测试用例等信息；<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">testFailureIgnore</span>&gt;</span>true<span class="tag">&lt;/<span class="name">testFailureIgnore</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">suiteXmlFiles</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">suiteXmlFilexmlFile</span>&gt;</span>src/test/resources/testng.xml<span class="tag">&lt;/<span class="name">suiteXmlFilexmlFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">suiteXmlFiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>usedefaultlisteners<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- disabling default listeners is optional --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="1-4-maven-compiler-plugin-插件配置"><a href="#1-4-maven-compiler-plugin-插件配置" class="headerlink" title="1.4 maven-compiler-plugin 插件配置"></a>1.4 maven-compiler-plugin 插件配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-TestNG-配置-RportPortal-listener"><a href="#2-TestNG-配置-RportPortal-listener" class="headerlink" title="2. TestNG 配置 RportPortal listener"></a>2. TestNG 配置 RportPortal listener</h3><p>testng  testng.xml  文件添加 RportPortal 的 listener，文件：src/test/resources/testng.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listeners</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">listener</span> <span class="attr">class-name</span>=<span class="string">"com.epam.reportportal.testng.ReportPortalTestNGListener"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listeners</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-工程添加-ReportPortal-resource"><a href="#3-工程添加-ReportPortal-resource" class="headerlink" title="3. 工程添加 ReportPortal resource"></a>3. 工程添加 ReportPortal resource</h3><p>src/test/resources/ 目录添加 ReportPortal 配置文件：reportportal.properties<br><strong>获取 ReportPortal 配置：</strong><br>访问 ReportPortal UI—&gt;点击右上角图标—&gt;点击 Profile—&gt;拷贝右下角框框中 REQUERED 配置。</p>
<p><strong>将上面获取到的 ReportPortal 配置放到 src/test/resources/ 目录下reportportal.properties 文件：</strong><br>示例文件内容：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rp<span class="selector-class">.endpoint</span> = http:<span class="comment">//reportIp:8080</span></span><br><span class="line">rp<span class="selector-class">.uuid</span> = xxxxx</span><br><span class="line">rp<span class="selector-class">.launch</span> = superadmin_TEST_EXAMPLE</span><br><span class="line">rp<span class="selector-class">.project</span> = superadmin_personal</span><br></pre></td></tr></table></figure></p>
<h3 id="4-配置-log4j-的-ReportPortal-appender"><a href="#4-配置-log4j-的-ReportPortal-appender" class="headerlink" title="4. 配置 log4j 的 ReportPortal appender"></a>4. 配置 log4j 的 ReportPortal appender</h3><p>src/test/resources/ 目录添加 log4j.xml 文件，主要是配置 log4j 的 ReportPortal appender，内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">xmlns:log4j</span>=<span class="string">'http://jakarta.apache.org/log4j/'</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ReportPortalAppender"</span> <span class="attr">class</span>=<span class="string">"com.epam.ta.reportportal.log4j.appender.ReportPortalAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"[%d&#123;HH:mm:ss&#125;] %-5p (%F:%L) - %m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.epam.reportportal.apache"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"OFF"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"info"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ReportPortalAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>至此相关配置已完成，工程目录结构此时为：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">├── README.md</span><br><span class="line">├── run.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── config.properties</span><br><span class="line">    │       ├── dev.yml</span><br><span class="line">    │       ├── log4j.properties</span><br><span class="line">    │       ├── log4testng.properties</span><br><span class="line">    │       ├── production.yml</span><br><span class="line">    │       ├── stage.yml</span><br><span class="line">    │       ├── test.yml</span><br><span class="line">    │       └── web.yml</span><br><span class="line">    └── test</span><br><span class="line">        ├── java</span><br><span class="line">        │   └── com</span><br><span class="line">        └── resources</span><br><span class="line">            ├── log4j.xml</span><br><span class="line">            ├── reportportal.properties</span><br><span class="line">            └── testng.xml</span><br></pre></td></tr></table></figure></p>
<h3 id="5-执行-mvn-clean-test-测试"><a href="#5-执行-mvn-clean-test-测试" class="headerlink" title="5. 执行 mvn clean test 测试"></a>5. 执行 <code>mvn clean test</code> 测试</h3><h3 id="6-到-ReportPortal-控制台观察新的-Launches-是否启动"><a href="#6-到-ReportPortal-控制台观察新的-Launches-是否启动" class="headerlink" title="6. 到 ReportPortal 控制台观察新的 Launches 是否启动"></a>6. 到 ReportPortal 控制台观察新的 Launches 是否启动</h3><p>每次测试会在 ReportPortal 平台对应触发一个 Launche，包含本次构建相关信息。<br><img src="/images/rp_launche.png" alt="Alt text"></p>
<h3 id="7-创建-ReportPortal-Dashboard，可视化测试报告"><a href="#7-创建-ReportPortal-Dashboard，可视化测试报告" class="headerlink" title="7. 创建 ReportPortal Dashboard，可视化测试报告"></a>7. 创建 ReportPortal Dashboard，可视化测试报告</h3><p>创建 ReportPortal 的 Dashboard 很简单，也很灵活，主要思想是 RP 提供了多种图表，然后每个图表配置条件，筛选出想要的 Launches 展示。<br><img src="/images/rp_dashboard.png" alt="Alt text"></p>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p><a href="https://reportportal.io/docs" target="_blank" rel="noopener">https://reportportal.io/docs</a><br><a href="https://github.com/reportportal/example-java-TestNG" target="_blank" rel="noopener">https://github.com/reportportal/example-java-TestNG</a></p>
]]></content>
      
        <categories>
            
            <category> DevOps </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DevOps </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Golang json 编解码]]></title>
      <url>/2019/07/09/Golang-json-%E7%BC%96%E8%A7%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<h4 id="Json-编码"><a href="#Json-编码" class="headerlink" title="Json 编码"></a>Json 编码</h4><p>Json 编码的过程即为将程序的数据结构转化为 json 串的过程，比如 Golang 里面的结构体、Python 中的字典，这些有结构的数据转化为 json 串。在 Golang 中编码 Json 使用 <code>encoding/json</code> 包的 Marshal() 函数，函数原型为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Marshal</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span></span><br></pre></td></tr></table></figure></p>
<p>举例：将 Book 结构体对象编码为 json 串，然后输出到控制台<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title       <span class="keyword">string</span></span><br><span class="line">    Authors     []<span class="keyword">string</span></span><br><span class="line">    Publisher   <span class="keyword">string</span></span><br><span class="line">    IsPublished <span class="keyword">bool</span></span><br><span class="line">    Price       <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> gobook Book = Book&#123;</span><br><span class="line">        <span class="string">"Go语言编程"</span>,</span><br><span class="line">        []<span class="keyword">string</span>&#123;<span class="string">"XuShiwei"</span>, <span class="string">"HughLv"</span>&#125;,</span><br><span class="line">        <span class="string">"ituring.com.cn"</span>,</span><br><span class="line">        <span class="literal">true</span>,</span><br><span class="line">        <span class="number">9.99</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    b, _ := json.Marshal(gobook)</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Json-解码"><a href="#Json-解码" class="headerlink" title="Json 解码"></a>Json 解码</h4><p>Json 解码的过程和编码刚好相反，将普通的 json 字符串转化为有结构的程序数据。比如将 json 串转化为 Golang 的结构体。在Golang 中解码 json 的函数为 <code>encoding/json</code> 包的 <code>Unmarshal()</code> 函数，函数原型为：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unmarshal</span><span class="params">(data []<span class="keyword">byte</span>, v <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></p>
<p>举例：将 json 字符串解码成 Golang Book 结构体对象，并打印每个字段的值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="comment">//"encoding/json"</span></span><br><span class="line">    <span class="string">"encoding/json"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">    Title       <span class="keyword">string</span></span><br><span class="line">    Authors     []<span class="keyword">string</span></span><br><span class="line">    Publisher   <span class="keyword">string</span></span><br><span class="line">    IsPublished <span class="keyword">bool</span></span><br><span class="line">    Price       <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jsonStr := <span class="string">`&#123;"Title":"Go语言编程","Authors":["XuShiwei","HughLv"],"Publisher":"ituring.com.cn","IsPublished":true,"Price":9.99&#125;`</span></span><br><span class="line">    <span class="keyword">var</span> book Book</span><br><span class="line">    json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), &amp;book)</span><br><span class="line">    fmt.Println(book.Title, book.Authors, book.Publisher, book.IsPublished, book.Price)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Go </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Go </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 iperf 测试 Linux 服务器带宽]]></title>
      <url>/2019/07/02/%E4%BD%BF%E7%94%A8-iperf-%E6%B5%8B%E8%AF%95-Linux-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%A6%E5%AE%BD/</url>
      <content type="html"><![CDATA[<h3 id="iperf-简介"><a href="#iperf-简介" class="headerlink" title="iperf 简介"></a>iperf 简介</h3><p><a href="https://sourceforge.net/projects/iperf/" target="_blank" rel="noopener">iperf</a> 是一个用于测试网络带宽的命令行工具，可以测试服务器的网络吞吐量。目前发现两个很实用的功能：</p>
<ol>
<li>测试服务器网络吞吐量：如果我们需要知道某台服务器的「最大」网络带宽，那么最好在同区域找两台同等配置的机器测试，因为带宽测试结果和两节点的距离有关、也和运营商的限制有关、也和服务器 CPU 核数有关。</li>
<li>测试到服务端节点网速：如果我们想知道目前客户端到服务器的实际网速是多少，在服务器启动 iperf，客户端连接 iperf 服务端，测试结果就是当前客户端到服务器的真实网速。</li>
</ol>
<h3 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y iperf</span><br></pre></td></tr></table></figure>
<h3 id="iperf-选项参数"><a href="#iperf-选项参数" class="headerlink" title="iperf 选项参数"></a>iperf 选项参数</h3><h4 id="通用选项"><a href="#通用选项" class="headerlink" title="通用选项"></a>通用选项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-f &lt;kmKM&gt;    报告输出格式。 [kmKM]   format to report: Kbits, Mbits, KBytes, MBytes</span><br><span class="line">-i &lt;sec&gt;    在周期性报告带宽之间暂停n秒。如周期是10s，则-i指定为2，则每隔2秒报告一次带宽测试情况,则共计报告5次</span><br><span class="line">-p    设置服务端监听的端口，默认是5001</span><br><span class="line">-u    使用UDP协议测试</span><br><span class="line">-w n&lt;K/M&gt;   指定TCP窗口大小</span><br><span class="line">-m    输出MTU大小</span><br><span class="line">-M    设置MTU大小</span><br><span class="line">-o &lt;filename&gt;    结果输出至文件</span><br></pre></td></tr></table></figure>
<h4 id="服务端选项"><a href="#服务端选项" class="headerlink" title="服务端选项"></a>服务端选项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-s    iperf服务器模式</span><br><span class="line">-d    以后台模式运行服务端</span><br><span class="line">-U    运行一个单一线程的UDP模式</span><br></pre></td></tr></table></figure>
<h4 id="客户端选项"><a href="#客户端选项" class="headerlink" title="客户端选项"></a>客户端选项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-b , --bandwidth n[KM] 指定客户端通过UDP协议发送数据的带宽（bit/s）该参数只对 udp 测试有效。默认是1Mbit/s</span><br><span class="line">-c &lt;ServerIP&gt;  以客户端模式运行iperf，并且连接至服务端主机ServerIP。 eg:  iperf -c &lt;server_ip&gt;</span><br><span class="line">-d    双向测试</span><br><span class="line">-t    指定iperf带宽测试时间，默认是10s。  eg:  iperf -c &lt;server_ip&gt; -t 20</span><br><span class="line">-P    指定客户端并发线程数，默认只运行一个线程。 eg,指定3个线程 : iperf -c &lt;server_ip&gt; -P 3</span><br><span class="line">-T    指定TTL值</span><br></pre></td></tr></table></figure>
<h3 id="使用方法示例"><a href="#使用方法示例" class="headerlink" title="使用方法示例"></a>使用方法示例</h3><p>准备两台服务器 A 和 B，并分别安装 iperf 命令行工具。</p>
<ol>
<li><p>测试 A 服务器的出站带宽：在 B 服务器启动 iperf 服务端，A 服务器使用 iperf 连接 B 服务<br>器 iperf 服务端，这样测试的就是 A 服务器的出口带宽：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B: iperf -s -i 2  <span class="comment"># 启动服务端</span></span><br><span class="line">A: iperf -c &lt;B_server_ip&gt; -i 2 -t 60  <span class="comment"># 客户端链接</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试 A 服务器的入站带宽：在 A 服务器启动 iperf 服务的，B 服务器使用 iperf 连接 A 服务器 iperf 服务端，这样测试的就是 A 服务器的入口带宽。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: iperf -s -i 2  <span class="comment"># 启动服务端</span></span><br><span class="line">B: iperf -c &lt;A_server_ip&gt; -i 2 -t 60  <span class="comment"># 客户端链接</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="测试结果示例"><a href="#测试结果示例" class="headerlink" title="测试结果示例"></a>测试结果示例</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@com26-83 ~]# iperf -c x.x.x.x -i 2 -t 60</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting <span class="keyword">to</span> x.x.x.x, TCP<span class="built_in"> port </span>5001</span><br><span class="line">TCP window size: 22.1 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  3] local 10.2.26.83<span class="built_in"> port </span>48234 connected with x.x.x.x<span class="built_in"> port </span>5001</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  3]  0.0- 2.0 sec   147 KBytes   603 Kbits/sec</span><br><span class="line">[  3]  2.0- 4.0 sec   369 KBytes  1.51 Mbits/sec</span><br><span class="line">[  3]  4.0- 6.0 sec   512 KBytes  2.10 Mbits/sec</span><br><span class="line">[  3]  6.0- 8.0 sec   896 KBytes  3.67 Mbits/sec</span><br><span class="line">[  3]  8.0-10.0 sec  1.62 MBytes  6.82 Mbits/sec</span><br><span class="line">[  3] 10.0-12.0 sec  2.12 MBytes  8.91 Mbits/sec</span><br><span class="line">[  3] 12.0-14.0 sec  3.38 MBytes  14.2 Mbits/sec</span><br><span class="line">[  3] 14.0-16.0 sec  6.00 MBytes  25.2 Mbits/sec</span><br><span class="line">[  3] 16.0-18.0 sec  8.00 MBytes  33.6 Mbits/sec</span><br></pre></td></tr></table></figure>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p><a href="https://www.cnblogs.com/zdz8207/p/linux-iperf.html" target="_blank" rel="noopener">https://www.cnblogs.com/zdz8207/p/linux-iperf.html</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Stunnel 隐藏 OpenVPN 流量]]></title>
      <url>/2019/06/23/%E4%BD%BF%E7%94%A8-Stunnel-%E9%9A%90%E8%97%8F-OpenVPN-%E6%B5%81%E9%87%8F/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>众所周知的原因，在海外直接搭建 <a href="https://openvpn.net" target="_blank" rel="noopener">OpenVPN</a> 根本无法使用（TCP 模式），或者用段时间就被墙了（UDP 模式）。本文主要介绍如何通过 <a href="https://www.stunnel.org/" target="_blank" rel="noopener">Stunnel</a> 隐藏 OpenVPN 流量，使其看起来像普通的 SSL 协议传输，从而绕过 gfw。</p>
<p>Stunnel 分为客户端和服务端，客户端负责接收用户 OpenVPN 客户端流量并转化成 SSL 协议加密数据包，然后转发给 Stunnel 服务端，实现 SSL 协议数据传输，服务端然后将流量转化成 OpenVPN 流量传输给 OpenVPN 服务端。因此我们可以在国内搭 Stunnel 客户端，国外搭 Stunnel 服务端。OpenVPN + Stunnel 整体架构如下：</p>
<p><img src="/images/stunnel-openvpn.png" alt="Alt text"></p>
<h3 id="Stunnel-隐藏-OpenVPN-流量具体过程"><a href="#Stunnel-隐藏-OpenVPN-流量具体过程" class="headerlink" title="Stunnel 隐藏 OpenVPN 流量具体过程"></a>Stunnel 隐藏 OpenVPN 流量具体过程</h3><h4 id="1-首先需要有个-OpenVPN-服务端"><a href="#1-首先需要有个-OpenVPN-服务端" class="headerlink" title="1. 首先需要有个 OpenVPN 服务端"></a>1. 首先需要有个 OpenVPN 服务端</h4><p>关于 OpenVPN 的搭建及使用在这里不多说了，之前写过文章，详情见<a href="https://qhh.me/2019/06/16/Cenos7-%E4%B8%8B%E6%90%AD%E5%BB%BA-OpenVPN-%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" target="_blank" rel="noopener">这里</a>。这里要说明的是，Stunnel 不支持 udp 流量转换，所以 OpenVPN 需要以 TCP 模式运行。下面为 OpenVPN TCP 模式的配置示例：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">port 4001   # 监听的端口号</span><br><span class="line">proto tcp-server</span><br><span class="line">dev tun</span><br><span class="line">ca /etc/openvpn/server/certs/ca.crt  #   CA 根证书路径</span><br><span class="line">cert /etc/openvpn/server/certs/server.crt  # open VPN 服务器证书路径</span><br><span class="line">key /etc/openvpn/server/certs/server.key  # open VPN 服务器密钥路径，This file should be kept secret</span><br><span class="line">dh /etc/openvpn/server/certs/dh.pem  # Diffie-Hellman 算法密钥文件路径</span><br><span class="line">tls-auth /etc/openvpn/server/certs/ta.key 0 #  tls-auth key，参数 0 可以省略，如果不省略，那么客户端</span><br><span class="line"><span class="comment"># 配置相应的参数该配成 1。如果省略，那么客户端不需要 tls-auth 配置</span></span><br><span class="line">server 10.8.0.0 255.255.255.0   # 该网段为 open VPN 虚拟网卡网段，不要和内网网段冲突即可。open VPN 默认为 10.8.0.0/24</span><br><span class="line">push <span class="string">"dhcp-option DNS 8.8.8.8"</span>  #<span class="built_in"> DNS </span>服务器配置，可以根据需要指定其他 ns</span><br><span class="line">push <span class="string">"dhcp-option DNS 8.8.4.4"</span></span><br><span class="line">push <span class="string">"redirect-gateway def1"</span>   # 客户端所有流量都通过 open VPN 转发，类似于代理开全局</span><br><span class="line">compress lzo</span><br><span class="line">duplicate-cn   # 允许一个用户多个终端连接</span><br><span class="line">keepalive 10 120</span><br><span class="line">comp-lzo</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">user openvpn  # open VPN 进程启动用户，openvpn 用户在安装完 openvpn 后就自动生成了</span><br><span class="line">group openvpn</span><br><span class="line">log /var/log/openvpn/server.log  # 指定 log 文件位置</span><br><span class="line">log-append /var/log/openvpn/server.log</span><br><span class="line">status /var/log/openvpn/status.log</span><br><span class="line">verb 3</span><br></pre></td></tr></table></figure></p>
<h4 id="2-Stunnel-服务端安装配置"><a href="#2-Stunnel-服务端安装配置" class="headerlink" title="2. Stunnel 服务端安装配置"></a>2. Stunnel 服务端安装配置</h4><h5 id="安装配置-Stunnel-服务端（海外节点）："><a href="#安装配置-Stunnel-服务端（海外节点）：" class="headerlink" title="安装配置 Stunnel 服务端（海外节点）："></a>安装配置 Stunnel 服务端（海外节点）：</h5><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">yum -y install stunnel</span><br><span class="line">cd /etc/stunnel</span><br><span class="line">openssl req -new -x509 -days 3650 -nodes -out stunnel.pem -keyout stunnel.pem</span><br><span class="line">chmod 600 /etc/stunnel/stunnel.pem</span><br><span class="line">vim stunnel.conf 填入如下内容:</span><br><span class="line">pid = /var/run/stunnel.pid</span><br><span class="line">output = /var/log/stunnel.log</span><br><span class="line">client = no</span><br><span class="line">[openvpn]</span><br><span class="line">accept = 443   </span><br><span class="line">connect = 127.0.0.1:4001</span><br><span class="line">cert = /etc/stunnel/stunnel.pem</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<blockquote>
<p>accept = 443   # Stunnel 服务端监听端口<br>connect = 127.0.0.1:4001  # OpenVPN 服务端地址</p>
</blockquote>
<h5 id="使用-systemd-启动-Stunnel-服务端："><a href="#使用-systemd-启动-Stunnel-服务端：" class="headerlink" title="使用 systemd  启动 Stunnel 服务端："></a>使用 systemd  启动 Stunnel 服务端：</h5><p>为了管理方便，我们使用 systemd 管理 Stunnel 服务，编辑一个 systemd unit 文件，vim /lib/systemd/system/stunnel.service：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=SSL tunnel for network daemons</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"><span class="attr">After</span>=syslog.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br><span class="line"><span class="attr">Alias</span>=stunnel.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=forking</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/bin/stunnel /etc/stunnel/stunnel.conf</span><br><span class="line"><span class="attr">ExecStop</span>=/usr/bin/killall -<span class="number">9</span> stunnel</span><br><span class="line"></span><br><span class="line"><span class="comment"># Give up if ping don't get an answer</span></span><br><span class="line"><span class="attr">TimeoutSec</span>=<span class="number">600</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Restart</span>=always</span><br><span class="line"><span class="attr">PrivateTmp</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>启动 Stunnel 服务端：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">start</span> <span class="selector-tag">stunnel</span><span class="selector-class">.service</span></span><br><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">enable</span> <span class="selector-tag">stunnel</span><span class="selector-class">.service</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-Stunnel-客户端安装配置"><a href="#3-Stunnel-客户端安装配置" class="headerlink" title="3. Stunnel 客户端安装配置"></a>3. Stunnel 客户端安装配置</h4><p>Stunnel 的客户端安装和服务器一样，同样的软件，既可以作为客户端，也可以作为服务端，只是配置不同而已。</p>
<h5 id="安装配置-Stunnel-客户端（国内节点）："><a href="#安装配置-Stunnel-客户端（国内节点）：" class="headerlink" title="安装配置 Stunnel 客户端（国内节点）："></a>安装配置 Stunnel 客户端（国内节点）：</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">yum -y install stunnel</span><br><span class="line">cd /etc/stunnel</span><br><span class="line">scp <span class="built_in">..</span><span class="built_in">..</span>  # 将服务端的证书 stunnel.pem 拷贝到这里</span><br><span class="line">chmod 600 /etc/stunnel/stunnel.pem</span><br><span class="line">vim stunnel.conf 填入如下内容：</span><br><span class="line"><span class="attribute">pid</span>=/var/run/stunnel.pid</span><br><span class="line"><span class="attribute">output</span>=/var/log/stunnel.log</span><br><span class="line">client = <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line">[openvpn]</span><br><span class="line"><span class="attribute">accept</span>=8443</span><br><span class="line"><span class="attribute">connect</span>=stunnel_server_ip:443</span><br><span class="line">cert = /etc/stunnel/stunnel.pem</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<blockquote>
<p>accept=8443  # Stunnel 客户端监听端口<br>stunnel_server_ip:443 # stunnel 服务端 ip 及端口</p>
</blockquote>
<h5 id="使用-systemd-启动-Stunnel-客户端："><a href="#使用-systemd-启动-Stunnel-客户端：" class="headerlink" title="使用 systemd  启动 Stunnel 客户端："></a>使用 systemd  启动 Stunnel 客户端：</h5><p>这里前面同服务端的操作过程，不再赘述。<br>启动 Stunnel 客户端：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">start</span> <span class="selector-tag">stunnel</span><span class="selector-class">.service</span></span><br><span class="line"><span class="selector-tag">systemctl</span> <span class="selector-tag">enable</span> <span class="selector-tag">stunnel</span><span class="selector-class">.service</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-使用-OpenVPN-连接-Stunnel"><a href="#4-使用-OpenVPN-连接-Stunnel" class="headerlink" title="4. 使用 OpenVPN 连接 Stunnel"></a>4. 使用 OpenVPN 连接 Stunnel</h4><p>Stunnel + OpenVPN 都配好后，就可以使用 OpenVPN 客户端实现自由上网了，需要注意的是 OpenVPN 客户端现在需要连接的是 Stunnel 客户端，不再是直接连接 OpenVPN 服务端。</p>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p><a href="https://github.com/Xaqron/stunnel" target="_blank" rel="noopener">https://github.com/Xaqron/stunnel</a></p>
]]></content>
      
        <categories>
            
            <category> OpenVPN </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenVPN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Haproxy 从入门到掌握]]></title>
      <url>/2019/06/17/Haproxy-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%8E%8C%E6%8F%A1/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="http://www.haproxy.org/" target="_blank" rel="noopener">HAProxy</a> 是一款开源且免费的反向代理软件，为基于 TCP 和 HTTP 的应用提供高可用、负载均衡和代理功能。它特别适用于流量非常大的网站，为世界上访问量最大的网站提供了强大的支持。多年来，HAProxy 已经成为事实上的标准开源负载均衡器，大多数主流的 Linux 发行版已经自带了该安装包，并且在云平台也经常被使用。</p>
<p>HAProxy 是一个纯粹的反向代理软件，与 nginx 不同的是 haproxy 没有 web 服务功能，而且同时支持 4 层和 7 层代理。Nginx 从 1.9.0 才开始支持 4 层代理，通过 stream 模块支持，该模块默认不会自带安装，需要编译安装的时候手动添加上这个模块。<br><img src="/images/haproxy.png" alt="Alt text"></p>
<p>HAProxy的核心功能：</p>
<ul>
<li>负载均衡：L4 和 L7 两种模式，支持 RR/静态RR/LC/IP Hash/URI Hash/URL_PARAM Hash/HTTP_HEADER Hash等丰富的负载均衡算法；</li>
<li>健康检查：支持 TCP 和 HTTP 两种健康检查模式；</li>
<li>会话保持：对于未实现会话共享的应用集群，可通过 Insert Cookie/Rewrite Cookie/Prefix Cookie，以及上述的多种 Hash 方式实现会话保持；</li>
<li>SSL：HAProxy 可以解析 HTTPS 协议，并能够将请求解密为 HTTP 后向后端传输；</li>
<li>HTTP请求重写与重定向；</li>
<li>监控与统计：HAProxy提供了基于 Web 的统计信息页面，展现健康状态和流量数据。基于此功能，使用者可以开发监控程序来监控 HAProxy 的状态；</li>
</ul>
<h3 id="Centos7-下安装-HAProxy"><a href="#Centos7-下安装-HAProxy" class="headerlink" title="Centos7 下安装 HAProxy"></a>Centos7 下安装 HAProxy</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="regexp">//</span>www.haproxy.org<span class="regexp">/download/</span><span class="number">1.8</span><span class="regexp">/src/</span>haproxy-<span class="number">1.8</span>.<span class="number">20</span>.tar.gz</span><br><span class="line">tar zxvf haproxy-<span class="number">1.8</span>.<span class="number">20</span>.tar.gz</span><br><span class="line">yum groupinstall -y <span class="string">'Development Tools'</span>  <span class="comment"># 安装 gcc 相关软件</span></span><br><span class="line">cd haproxy-<span class="number">1.8</span>.<span class="number">20</span></span><br><span class="line">make TARGET=linux2628  <span class="comment"># 编译：TARGET 和内核版本有关，不同的内核版</span></span><br><span class="line">                       <span class="comment"># 本对应不同值，对应关系在 README</span></span><br><span class="line">make install <span class="comment"># 安装到系统路径</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-HAProxy-搭建一个-L4-层代理"><a href="#使用-HAProxy-搭建一个-L4-层代理" class="headerlink" title="使用 HAProxy 搭建一个 L4 层代理"></a>使用 HAProxy 搭建一个 L4 层代理</h3><p>这里使用 HAProxy 转发流量到后台 3 个 Shadowsocks 节点的 1443/tcp 端口，并配有 TCP 健康检查机制:<br><img src="/images/haproxy-arch.png" alt="Alt text"></p>
<p>HAProxy 的 L4 层代理配置很简单，定义一对 frontend 和 backend，frontend 为 haproxy 前端监听的端口，backend 为后端服务器节点，我们访问 haproxy 不同的端口即可访问到对应的后端服务。frontend 和 backend 通过 default_backend 后面的名称关联。其他的配置项说明见下面配置文件 haproxy.cfg 中注释说明：</p>
<p>新建一个 HAProxy 配置文件：<br>mkdir /etc/haproxy<br>vim /etc/haproxy/haproxy.cfg 填入如下内容:<br>haproxy.cfg:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># demo config for Proxy mode</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># global 为全局配置项，主要和 haproxy 进程本身有关。defaults 为默认配置，当后面的 listen、frontend、banckend 等块没有再次指明相关配置时，会继承 defaults 的配置。</span></span><br><span class="line"></span><br><span class="line">global</span><br><span class="line">    maxconn         20000 #最大连接数</span><br><span class="line">    ulimit-n        204800  #ulimit的数量限制</span><br><span class="line">    log             127.0.0.1 local3</span><br><span class="line">    user             haproxy</span><br><span class="line">    group            haproxy</span><br><span class="line">    chroot          /var/empty</span><br><span class="line">    nbproc      4 #启动后运行的进程数量</span><br><span class="line">    daemon        #以后台形式运行haproxy</span><br><span class="line">    pidfile     /var/run/haproxy.pid</span><br><span class="line">defaults</span><br><span class="line">    log global</span><br><span class="line">    mode tcp</span><br><span class="line">    retries 3 #3次连接失败认为服务不可用，也可以在后面设置</span><br><span class="line">    timeout connect 5s #连接超时</span><br><span class="line">    timeout client 30s #客户端超时</span><br><span class="line">    timeout server 30s #服务器端超时</span><br><span class="line">    option redispatch</span><br><span class="line">    option    nolinger</span><br><span class="line">    no option dontlognull</span><br><span class="line">    option    tcplog</span><br><span class="line">    option log-separate-errors</span><br><span class="line"></span><br><span class="line">listen admin_stats  #监控页面设置</span><br><span class="line">    bind 0.0.0.0:26000 # 监控页面监听端口号</span><br><span class="line">    bind-process 1</span><br><span class="line">    mode http</span><br><span class="line">    log 127.0.0.1 local3 err</span><br><span class="line">    stats refresh 30s ##每隔30秒自动刷新监控页面</span><br><span class="line">    stats uri /admin</span><br><span class="line">    stats realm welcome login\ Haproxy</span><br><span class="line">    stats auth admin:123456</span><br><span class="line">    stats hide-version</span><br><span class="line">    stats admin if TRUE</span><br><span class="line"></span><br><span class="line">frontend shadowsocks</span><br><span class="line">  bind *:1443</span><br><span class="line">  default_backend shadowsocks</span><br><span class="line">backend shadowsocks</span><br><span class="line">  <span class="comment"># balance roundrobin #负载均衡的方式，roundrobin是轮询</span></span><br><span class="line">  <span class="comment"># check inter 1500 心跳检测频率, rise 3 是3次正确认为服务器可用，fall 3是3次失败认为服务器不可用</span></span><br><span class="line">  server ss-node-1 192.168.0.1:1443 check inter 1500 rise 3 fall 3</span><br><span class="line">  server ss-node-1 192.168.0.2:1443 check inter 1500 rise 3 fall 3</span><br><span class="line">  server ss-node-1 192.168.0.3:1443 check inter 1500 rise 3 fall 3</span><br></pre></td></tr></table></figure></p>
<p>测试配置文件是否有效<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haproxy -f /etc/haproxy/haproxy<span class="selector-class">.cfg</span> -c</span><br></pre></td></tr></table></figure></p>
<p>启动 HAProy 服务：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haproxy -f <span class="regexp">/etc/</span>haproxy<span class="regexp">/haproxy.cfg</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以访问 HAProxy 自带的监控页面：上面我们配置的访问地址为 haproxy_ip:26000/admin，账号：admin，密码：123456。HAProxy 自带的监控页面特别好用，可以看到每个后端节点的流量使用情况、在线状态、可以随时将节点从后端集群中剔除或者改变状态。</p>
<p><img src="/images/haproxy-monitor-ui.png" alt="Alt text"></p>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p><a href="http://www.haproxy.org/" target="_blank" rel="noopener">http://www.haproxy.org/</a> | HAProxy 官网<br><a href="https://www.jianshu.com/p/c9f6d55288c0" target="_blank" rel="noopener">https://www.jianshu.com/p/c9f6d55288c0</a> | HAProxy从零开始到掌握<br><a href="https://www.jianshu.com/p/17c2f87bb27f" target="_blank" rel="noopener">https://www.jianshu.com/p/17c2f87bb27f</a> | 简述Haproxy常见的负载均衡调度算法及应用场景详解<br><a href="https://www.serverlab.ca/tutorials/linux/network-services/how-to-configure-haproxy-health-checks/" target="_blank" rel="noopener">https://www.serverlab.ca/tutorials/linux/network-services/how-to-configure-haproxy-health-checks/</a> | HAProxy 健康检查配置</p>
]]></content>
      
        <categories>
            
            <category> HAProxy </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HAProxy </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Cenos7 下搭建 OpenVPN 过程记录]]></title>
      <url>/2019/06/16/Cenos7-%E4%B8%8B%E6%90%AD%E5%BB%BA-OpenVPN-%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p><img src="/images/openvpn-icon.png" alt="Alt text"></p>
<h3 id="OpenVPN-服务端安装配置"><a href="#OpenVPN-服务端安装配置" class="headerlink" title="OpenVPN 服务端安装配置"></a>OpenVPN 服务端安装配置</h3><p>由于不同环境及软件版本命令使用略有差异，特别是 easy-rsa 的使用在 2.0 和 3.0 的差别有点大，所以在此先说明下安装环境及相关软件版本：</p>
<ul>
<li><strong>系统平台：</strong>Centos7</li>
<li><strong><a href="https://openvpn.net/" target="_blank" rel="noopener">OpenVPN</a> 版本：</strong>2.4.7</li>
<li><strong>easy-rsa 版本：</strong>3.0.3</li>
</ul>
<p><strong>尽管不同环境及软件版本命令使用略有所差异，但是整个搭建过程都是一致的</strong>：</p>
<blockquote>
<p>安装相关软件—&gt;生成相关证书：CA 根证书、服务器证书—&gt;配置 open VPN 服务端—&gt;添加防火墙规则：snat—&gt;启动 open VPN 服务端—&gt;创建一个用户测试连接：创建客户端 CA 证书、生成 .ovpn 配置文件、打包相关文件供客户端使用。</p>
</blockquote>
<p><img src="/images/openvpn-install-step.png" alt="Alt text"></p>
<p>1.安装 openvpn、easy-rsa、iptables-services<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> epel-<span class="keyword">release</span></span><br><span class="line">yum -y <span class="keyword">install</span> openvpn easy-rsa iptables-services</span><br></pre></td></tr></table></figure></p>
<p>2.使用 easy-rsa 生成需要的证书及相关文件，在这个阶段会产生一些 key 和证书：</p>
<ul>
<li>CA 根证书</li>
<li>OpenVPN 服务器 ssl 证书</li>
<li>Diffie-Hellman 算法用到的 key</li>
</ul>
<p>2.1 将 easy-rsa 脚本复制到 /etc/openvpn/，该脚本主要用来方便地生成 CA 证书和各种 key<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r <span class="regexp">/usr/</span>share<span class="regexp">/easy-rsa/</span> <span class="regexp">/etc/</span>openvpn<span class="regexp">/</span></span><br></pre></td></tr></table></figure></p>
<p>2.2 跳到 easy-rsa 目录并编辑 vars 文件，添加一些生成证书时用到的变量<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/openvpn/easy-rsa/&lt;easy-rsa 版本号&gt;/  # 查看 easy-rsa 版本号：yum <span class="builtin-name">info</span> easy-rsa</span><br><span class="line">vim vars  # 没这个文件的话新建，填写如下内容（变量值根据实际情况随便填写）:</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">KEY_COUNTRY</span>=<span class="string">"***"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">KEY_PROVINCE</span>=<span class="string">"***"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">KEY_CITY</span>=<span class="string">"***"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">KEY_ORG</span>=<span class="string">"***"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">KEY_EMAIL</span>=<span class="string">"***"</span></span><br><span class="line">source ./vars   # 使变量生效</span><br></pre></td></tr></table></figure></p>
<p>2.3 生成 CA 根证书<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./easyrsa</span> init-pki    <span class="comment">#初始化 pki 相关目录</span></span><br><span class="line"><span class="string">./easyrsa</span> build-ca nopass  <span class="comment">#生成 CA 根证书, 输入 Common Name，名字随便起。</span></span><br></pre></td></tr></table></figure></p>
<p>2.4 生成 OpenVPN 服务器证书和密钥<br>第一个参数 server 为证书名称，可以随便起，比如 <code>./easyrsa build-server-full openvpn nopass</code><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./easyrsa build-server-full<span class="built_in"> server </span>nopass</span><br></pre></td></tr></table></figure></p>
<p>2.5 生成 Diffie-Hellman 算法需要的密钥文件<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./easyrsa</span> gen-dh   <span class="comment">#创建Diffie-Hellman，这可能得等一小会儿</span></span><br></pre></td></tr></table></figure></p>
<p>2.6 生成 tls-auth key，这个 key 主要用于防止 DoS 和 TLS 攻击，这一步其实是可选的，但为了安全还是生成一下，该文件在后面配置 open VPN 时会用到。<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">openvpn</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">genkey</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">secret</span> <span class="comment">ta</span><span class="string">.</span><span class="comment">key</span></span><br></pre></td></tr></table></figure></p>
<p>2.7 将上面生成的相关证书文件整理到  /etc/openvpn/server/certs （这一步完全是为了维护方便）<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/server/</span>certs &amp;&amp; cd <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/server/</span>certs/</span><br><span class="line">cp <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/easy-rsa/</span><span class="number">3</span><span class="meta-keyword">/pki/</span>dh.pem ./     <span class="meta"># SSL 协商时 Diffie-Hellman 算法需要的 key</span></span><br><span class="line">cp <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/easy-rsa/</span><span class="number">3</span><span class="meta-keyword">/pki/</span>ca.crt ./        <span class="meta"># CA 根证书</span></span><br><span class="line">cp <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/easy-rsa/</span><span class="number">3</span><span class="meta-keyword">/pki/</span>issued/server.crt ./    <span class="meta"># open VPN 服务器证书</span></span><br><span class="line">cp <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/easy-rsa/</span><span class="number">3</span><span class="meta-keyword">/pki/</span>private/server.key ./   <span class="meta"># open VPN 服务器证书 key</span></span><br><span class="line">cp <span class="meta-keyword">/etc/</span>openvpn<span class="meta-keyword">/easy-rsa/</span><span class="number">3</span>/ta.key ./   <span class="meta"># tls-auth key</span></span><br></pre></td></tr></table></figure></p>
<p>2.8 创建 open VPN 日志目录<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /<span class="built_in">var</span>/<span class="built_in">log</span>/openvpn/</span><br><span class="line">chown openvpn:openvpn /<span class="built_in">var</span>/<span class="built_in">log</span>/openvpn</span><br></pre></td></tr></table></figure></p>
<p>3.配置 OpenVPN<br>可以从 /usr/share/doc/openvpn-<open vpn版本号="">/sample/sample-config-files 复制一份 demo 到 /etc/openvpn/（openvpn 版本号查看：yum info openvpn。）然后改改，或者从头开始创建一个新的配置文件。我选择新建配置:<br><code>cd  /etc/openvpn/</code><br><code>vim server.conf</code> 填入如下内容（很多配置项不需要特别了解，重要的配置这里注释出来了，其他相关配置项想了解的话见 <a href="https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage" target="_blank" rel="noopener">这里</a>）：<br>server.conf:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">port 1194   # 监听的端口号</span><br><span class="line">proto udp   # 服务端用的协议，udp 能快点，所以我选择 udp</span><br><span class="line">dev tun</span><br><span class="line">ca /etc/openvpn/server/certs/ca.crt  #   CA 根证书路径</span><br><span class="line">cert /etc/openvpn/server/certs/server.crt  # open VPN 服务器证书路径</span><br><span class="line">key /etc/openvpn/server/certs/server.key  # open VPN 服务器密钥路径，This file should be kept secret</span><br><span class="line">dh /etc/openvpn/server/certs/dh.pem  # Diffie-Hellman 算法密钥文件路径</span><br><span class="line">tls-auth /etc/openvpn/server/certs/ta.key 0 #  tls-auth key，参数 0 可以省略，如果不省略，那么客户端</span><br><span class="line"><span class="comment"># 配置相应的参数该配成 1。如果省略，那么客户端不需要 tls-auth 配置</span></span><br><span class="line">server 10.8.0.0 255.255.255.0   # 该网段为 open VPN 虚拟网卡网段，不要和内网网段冲突即可。open VPN 默认为 10.8.0.0/24</span><br><span class="line">push <span class="string">"dhcp-option DNS 8.8.8.8"</span>  #<span class="built_in"> DNS </span>服务器配置，可以根据需要指定其他 ns</span><br><span class="line">push <span class="string">"dhcp-option DNS 8.8.4.4"</span></span><br><span class="line">push <span class="string">"redirect-gateway def1"</span>   # 客户端所有流量都通过 open VPN 转发，类似于代理开全局</span><br><span class="line">compress lzo</span><br><span class="line">duplicate-cn   # 允许一个用户多个终端连接</span><br><span class="line">keepalive 10 120</span><br><span class="line">comp-lzo</span><br><span class="line">persist-key</span><br><span class="line">persist-tun</span><br><span class="line">user openvpn  # open VPN 进程启动用户，openvpn 用户在安装完 openvpn 后就自动生成了</span><br><span class="line">group openvpn</span><br><span class="line">log /var/log/openvpn/server.log  # 指定 log 文件位置</span><br><span class="line">log-append /var/log/openvpn/server.log</span><br><span class="line">status /var/log/openvpn/status.log</span><br><span class="line">verb 3</span><br><span class="line">explicit-exit-notify 1</span><br></pre></td></tr></table></figure></open></p>
<p>4.防火墙相关配置（使用 iptables 添加 snat 规则）<br>4.1 禁用 Centos7 默认的 firewalld，使用经典的 iptables 防火墙管理软件：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">stop</span> firewalld</span><br><span class="line">systemctl <span class="keyword">mask</span> firewalld</span><br></pre></td></tr></table></figure></p>
<p>4.2 禁用 SELinux<br>马上关闭：setenforce 0 | 马上生效<br>永久关闭：sed -i ‘s/SELINUX=enforcing/SELINUX=disabled/g’ /etc/selinux/config | 需要重启服务器生效</p>
<p>4.3 启用iptables<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> iptables</span><br><span class="line">systemctl start iptables</span><br><span class="line">iptables -F   <span class="comment"># 清理所有防火墙规则</span></span><br></pre></td></tr></table></figure></p>
<p>4.4 添加防火墙规则，将 openvpn 的网络流量转发到公网：snat 规则<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iptables -t<span class="built_in"> nat </span>-A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE</span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables   # iptables 规则持久化保存</span><br></pre></td></tr></table></figure></p>
<p>4.5 Linux 服务器启用地址转发<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p <span class="comment"># 这一步一定得执行，否则不会立即生效。</span></span><br></pre></td></tr></table></figure></p>
<p>5.启动 open VPN<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start openvpn@server  <span class="comment"># 启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> openvpn@server  <span class="comment"># 开机自启动</span></span><br><span class="line">systemctl status openvpn@server  <span class="comment"># 查看服务状态</span></span><br></pre></td></tr></table></figure></p>
<h3 id="添加一个-OpenVPN-用户"><a href="#添加一个-OpenVPN-用户" class="headerlink" title="添加一个 OpenVPN 用户"></a>添加一个 OpenVPN 用户</h3><p>OpenVPN 服务端搭建完了，但是我们该如何使用呢？下面以 Mac 平台下使用为例：</p>
<p>要连接到 open VPN 服务端首先得需要一个客户端软件，在 Mac 下推荐使用 <a href="https://tunnelblick.net/" target="_blank" rel="noopener">Tunnelblick</a>，下载地址：<a href="https://tunnelblick.net/。Tunnelblick" target="_blank" rel="noopener">https://tunnelblick.net/。Tunnelblick</a> 是一个开源、免费的 Mac 版 open VPN 客户端软件。</p>
<p>接下来在服务端创建一个 open VPN 用户：其实创建用户的过程就是生成客户端 SSL 证书的过程，然后将其他相关的证书文件、key、.ovpn 文件（客户端配置文件）打包到一起供客户端使用。由于创建一个用户的过程比较繁琐，所以在此将整个过程写成了一个脚本 ovpn_user.sh，脚本内容比较简单，一看就懂：</p>
<p>首先创建一个客户端配置模板文件 sample.ovpn，该文件在脚本中会用到，放到 /etc/openvpn/client/ 目录，内容如下：<br>sample.ovpn:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">client</span><br><span class="line">proto udp</span><br><span class="line">dev tun</span><br><span class="line">remote [open VPN服务端公网 ip，根据实际情况填写] 1194</span><br><span class="line">ca ca.crt</span><br><span class="line">cert admin.crt</span><br><span class="line">key admin.key</span><br><span class="line">tls-auth ta.key 1</span><br><span class="line">remote-cert-tls server</span><br><span class="line">persist-tun</span><br><span class="line">persist-key</span><br><span class="line">comp-lzo</span><br><span class="line">verb 3</span><br><span class="line">mute-replay-warnings</span><br></pre></td></tr></table></figure></p>
<p>下面为创建 open VPN 用户脚本：<br>./ovpn_user.sh:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">OVPN_USER_KEYS_DIR=/etc/openvpn/client/keys</span><br><span class="line">EASY_RSA_VERSION=3</span><br><span class="line">EASY_RSA_DIR=/etc/openvpn/easy-rsa/</span><br><span class="line">PKI_DIR=<span class="variable">$EASY_RSA_DIR</span>/<span class="variable">$EASY_RSA_VERSION</span>/pki</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    rm -rf <span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span></span><br><span class="line">    rm -rf  <span class="variable">$PKI_DIR</span>/reqs/<span class="variable">$user</span>.req</span><br><span class="line">    sed -i <span class="string">'/'</span><span class="string">"<span class="variable">$user</span>"</span><span class="string">'/d'</span> <span class="variable">$PKI_DIR</span>/index.txt</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$EASY_RSA_DIR</span>/<span class="variable">$EASY_RSA_VERSION</span></span><br><span class="line">  <span class="comment"># 生成客户端 ssl 证书文件</span></span><br><span class="line">  ./easyrsa build-client-full <span class="variable">$user</span> nopass</span><br><span class="line">  <span class="comment"># 整理下生成的文件</span></span><br><span class="line">  mkdir -p  <span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span></span><br><span class="line">  cp <span class="variable">$PKI_DIR</span>/ca.crt <span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span>/   <span class="comment"># CA 根证书</span></span><br><span class="line">  cp <span class="variable">$PKI_DIR</span>/issued/<span class="variable">$user</span>.crt <span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span>/   <span class="comment"># 客户端证书</span></span><br><span class="line">  cp <span class="variable">$PKI_DIR</span>/private/<span class="variable">$user</span>.key <span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span>/  <span class="comment"># 客户端证书密钥</span></span><br><span class="line">  cp /etc/openvpn/client/sample.ovpn <span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span>/<span class="variable">$user</span>.ovpn <span class="comment"># 客户端配置文件</span></span><br><span class="line">  sed -i <span class="string">'s/admin/'</span><span class="string">"<span class="variable">$user</span>"</span><span class="string">'/g'</span> <span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span>/<span class="variable">$user</span>.ovpn</span><br><span class="line">  cp /etc/openvpn/server/certs/ta.key <span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span>/ta.key  <span class="comment"># auth-tls 文件</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$OVPN_USER_KEYS_DIR</span></span><br><span class="line">  zip -r <span class="variable">$user</span>.zip <span class="variable">$user</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></p>
<p>执行上面脚本创建一个用户：<code>sh ovpn_user.sh &lt;username&gt;</code>，会在 /etc/openvpn/client/keys 目录下生成以用户名命名的 zip 打包文件，将该压缩包下载到本地解压，然后将里面的 .ovpn 文件拖拽到 Tunnelblick 客户端软件即可使用。<br>压缩包里面文件有如下，示例：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── ca.crt</span><br><span class="line">├── username.crt</span><br><span class="line">├── username.key</span><br><span class="line">├── username.ovpn</span><br><span class="line">└── ta.key</span><br></pre></td></tr></table></figure></p>
<h3 id="删除一个-OpenVPN-用户"><a href="#删除一个-OpenVPN-用户" class="headerlink" title="删除一个 OpenVPN 用户"></a>删除一个 OpenVPN 用户</h3><p>上面我们知道了如何添加一个用户，那么如果公司员工离职了或者其他原因，想删除对应用户 OpenVPN 的使用权，该如何操作呢？其实很简单，OpenVPN 的客户端和服务端的认证主要通过 SSL 证书进行双向认证，所以只要吊销对应用户的 SSL 证书即可。</p>
<ol>
<li><p>编辑 OpenVPN 服务端配置 server.conf 添加如下配置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crl-verify /etc/openvpn/easy-rsa/3/pki/crl.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>吊销用户证书，假设要吊销的用户名为 username</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/openvpn/easy-rsa/3/</span><br><span class="line">./easyrsa revoke username</span><br><span class="line">./easyrsa gen-crl</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 OpenVPN 服务端使其生效</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start openvpn@server</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>为了方便，也将上面步骤整理成了一个脚本，可以一键删除用户：<br>del_ovpn_user.sh:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">OVPN_USER_KEYS_DIR=/etc/openvpn/client/keys</span><br><span class="line">EASY_RSA_VERSION=3</span><br><span class="line">EASY_RSA_DIR=/etc/openvpn/easy-rsa/</span><br><span class="line"><span class="keyword">for</span> user <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="variable">$EASY_RSA_DIR</span>/<span class="variable">$EASY_RSA_VERSION</span></span><br><span class="line">  <span class="built_in">echo</span> -e <span class="string">'yes\n'</span> | ./easyrsa revoke <span class="variable">$user</span></span><br><span class="line">  ./easyrsa gen-crl</span><br><span class="line">  <span class="comment"># 吊销掉证书后清理客户端相关文件</span></span><br><span class="line">  <span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$user</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    rm -rf <span class="variable">$OVPN_USER_KEYS_DIR</span>/<span class="variable">$&#123;user&#125;</span>*</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  systemctl restart openvpn@server</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></p>
<h3 id="安装过程中遇到的问题及解决方法"><a href="#安装过程中遇到的问题及解决方法" class="headerlink" title="安装过程中遇到的问题及解决方法"></a>安装过程中遇到的问题及解决方法</h3><h4 id="问题-1：open-VPN-客户端可以正常连接到服务端，但是无法上网，ping-任何地址都不通，只有服务端公网-ip-可以-ping-通。"><a href="#问题-1：open-VPN-客户端可以正常连接到服务端，但是无法上网，ping-任何地址都不通，只有服务端公网-ip-可以-ping-通。" class="headerlink" title="问题 1：open VPN 客户端可以正常连接到服务端，但是无法上网，ping 任何地址都不通，只有服务端公网 ip 可以 ping 通。"></a>问题 1：open VPN 客户端可以正常连接到服务端，但是无法上网，ping 任何地址都不通，只有服务端公网 ip 可以 ping 通。</h4><p>问题原因及解决方法：主要原因是服务的地址转发功能没打开，其实我前面配置<br>了 echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf，但是没有执行 sysctl -p 使其<br>立即生效，所以才导致出现问题。因此一定要记得两条命令都要执行。</p>
<h4 id="问题-2-open-VPN-可以正常使用，但是看客户端日志却有如下错误："><a href="#问题-2-open-VPN-可以正常使用，但是看客户端日志却有如下错误：" class="headerlink" title="问题 2: open VPN 可以正常使用，但是看客户端日志却有如下错误："></a>问题 2: open VPN 可以正常使用，但是看客户端日志却有如下错误：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-06-15 02:39:03.957926 AEAD Decrypt error: bad packet ID (may be a replay): [ #6361 ] -- see the man<span class="built_in"> page </span>entry <span class="keyword">for</span> --no-replay <span class="keyword">and</span> --replay-window <span class="keyword">for</span> more <span class="builtin-name">info</span> <span class="keyword">or</span> silence this <span class="builtin-name">warning</span> with --mute-replay-warnings</span><br><span class="line">2019-06-15 02:39:23.413750 AEAD Decrypt error: bad packet ID (may be a replay): [ #6508 ] -- see the man<span class="built_in"> page </span>entry <span class="keyword">for</span> --no-replay <span class="keyword">and</span> --replay-window <span class="keyword">for</span> more <span class="builtin-name">info</span> <span class="keyword">or</span> silence this <span class="builtin-name">warning</span> with --mute-replay-warnings</span><br></pre></td></tr></table></figure>
<p>问题原因及解决方法：<br>其实这个问题一般在 open VPN 是 UDP 服务的情况下出现，主要原因是 UDP 数据包重复发送导致，在 Wi-Fi 网络下经常出现，这并不影响使用，但是我们可以选择禁止掉该错误：根据错误提示可知使用 –mute-replay-warnings 参数可以消除该警告，我们使用的 open VPN 是 GUI 的，所以修改客户端 .ovpn 配置文件，末尾添加：mute-replay-warnings 即可解决。</p>
<p>该问题在这里有讨论：<br><a href="https://sourceforge.net/p/openvpn/mailman/message/10655695/" target="_blank" rel="noopener">https://sourceforge.net/p/openvpn/mailman/message/10655695/</a></p>
<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p>关于 open VPN 客户端和服务端配置文件配置项说明：很全面，可以随时查看不懂的配置项<br><a href="https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage" target="_blank" rel="noopener">https://community.openvpn.net/openvpn/wiki/Openvpn24ManPage</a></p>
<p><a href="https://openvpn.net/" target="_blank" rel="noopener">https://openvpn.net/</a> | OpenVPN 官网<br><a href="https://www.fandenggui.com/post/centos7-install-openvpn.html" target="_blank" rel="noopener">https://www.fandenggui.com/post/centos7-install-openvpn.html</a> | Centos7 安装 OpenVPN<br><a href="https://www.howtoing.com/how-to-install-openvpn-on-centos-7" target="_blank" rel="noopener">https://www.howtoing.com/how-to-install-openvpn-on-centos-7</a> | Centos7 安装 OpenVPN</p>
<p><a href="https://www.xiaohui.com/dev/server/20070904-revoke-openvpn-client.htm" target="_blank" rel="noopener">https://www.xiaohui.com/dev/server/20070904-revoke-openvpn-client.htm</a> | 吊销客户端证书<br><a href="https://scott.stevensononthe.net/2015/02/how-to-addremove-additional-users-to-openvpn/" target="_blank" rel="noopener">https://scott.stevensononthe.net/2015/02/how-to-addremove-additional-users-to-openvpn/</a> | 吊销客户端证书<br><a href="https://tunnelblick.net/cConnectedBut.html" target="_blank" rel="noopener">https://tunnelblick.net/cConnectedBut.html</a> | open VPN 一些常见问题<br><a href="https://tunnelblick.net/ipinfo" target="_blank" rel="noopener">https://tunnelblick.net/ipinfo</a> | 本地公网 ip 查看</p>
]]></content>
      
        <categories>
            
            <category> OpenVPN </category>
            
        </categories>
        
        
        <tags>
            
            <tag> OpenVPN </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 ansible 模板化 haproxy 配置文件]]></title>
      <url>/2019/06/11/%E4%BD%BF%E7%94%A8-ansible-%E6%A8%A1%E6%9D%BF%E5%8C%96-haproxy-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>今天使用 ansible 自动化一些日常工作，其中包括 haproxy 的配置变更，我们 haproxy 里面定义了很多 frontend 和 backend，猛一看还不好模版化，其实仔细研究一下发现完全可以通过模板的循环语法动态生成配置文件，在此分享下。首先看一下未模板化时的原始配置：<br><code>haproxy.cfg</code>:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">global</span></span><br><span class="line">    <span class="string">maxconn</span>         <span class="number">20000</span></span><br><span class="line">    <span class="string">ulimit-n</span>        <span class="number">204800</span></span><br><span class="line">    <span class="string">log</span>             <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">local3</span></span><br><span class="line">    <span class="string">user</span>             <span class="string">haproxy</span></span><br><span class="line">    <span class="string">group</span>            <span class="string">haproxy</span></span><br><span class="line">    <span class="string">chroot</span>          <span class="string">/var/empty</span></span><br><span class="line">    <span class="string">nbproc</span>      <span class="number">4</span> <span class="comment">#启动后运行的进程数量</span></span><br><span class="line">    <span class="string">daemon</span>        <span class="comment">#以后台形式运行haproxy</span></span><br><span class="line">    <span class="string">pidfile</span>     <span class="string">/var/run/haproxy.pid</span></span><br><span class="line"><span class="string">defaults</span></span><br><span class="line">    <span class="string">log</span> <span class="string">global</span></span><br><span class="line">    <span class="string">mode</span> <span class="string">tcp</span></span><br><span class="line">    <span class="string">retries</span> <span class="number">3</span> <span class="comment">#3次连接失败认为服务不可用，也可以在后面设置</span></span><br><span class="line">    <span class="string">timeout</span> <span class="string">connect</span> <span class="number">5</span><span class="string">s</span> <span class="comment">#连接超时</span></span><br><span class="line">    <span class="string">timeout</span> <span class="string">client</span> <span class="number">30</span><span class="string">s</span> <span class="comment">#客户端超时</span></span><br><span class="line">    <span class="string">timeout</span> <span class="string">server</span> <span class="number">30</span><span class="string">s</span> <span class="comment">#服务器端超时</span></span><br><span class="line">    <span class="string">option</span> <span class="string">redispatch</span></span><br><span class="line">    <span class="string">option</span>    <span class="string">nolinger</span></span><br><span class="line">    <span class="literal">no</span> <span class="string">option</span> <span class="string">dontlognull</span></span><br><span class="line">    <span class="string">option</span>    <span class="string">tcplog</span></span><br><span class="line">    <span class="string">option</span> <span class="string">log-separate-errors</span></span><br><span class="line"></span><br><span class="line"><span class="string">listen</span> <span class="string">admin_stats</span>  <span class="comment">#监控页面设置</span></span><br><span class="line">    <span class="string">bind</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">:26000</span></span><br><span class="line">    <span class="string">bind-process</span> <span class="number">1</span></span><br><span class="line">    <span class="string">mode</span> <span class="string">http</span></span><br><span class="line">    <span class="string">log</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">local3</span> <span class="string">err</span></span><br><span class="line">    <span class="string">stats</span> <span class="string">refresh</span> <span class="number">30</span><span class="string">s</span> <span class="comment">#每隔30秒自动刷新监控页面</span></span><br><span class="line">    <span class="string">stats</span> <span class="string">uri</span> <span class="string">/admin</span></span><br><span class="line">    <span class="string">stats</span> <span class="string">realm</span> <span class="string">welcome</span> <span class="string">login\</span> <span class="string">Haproxy</span></span><br><span class="line">    <span class="string">stats</span> <span class="string">auth</span> <span class="attr">admin:123456</span></span><br><span class="line">    <span class="string">stats</span> <span class="string">hide-version</span></span><br><span class="line">    <span class="string">stats</span> <span class="string">admin</span> <span class="string">if</span> <span class="literal">TRUE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过配置文件动态生成 hproxy 配置</span></span><br><span class="line"><span class="string">frontend</span> <span class="string">redis</span></span><br><span class="line">  <span class="string">bind</span> <span class="string">*:6379</span></span><br><span class="line">  <span class="string">default_backend</span> <span class="string">redis</span></span><br><span class="line"><span class="string">backend</span> <span class="string">redis</span></span><br><span class="line">  <span class="string">server</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span><span class="string">:6379</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span><span class="string">:6379</span> <span class="string">check</span> <span class="string">inter</span> <span class="number">1500</span> <span class="string">rise</span> <span class="number">3</span> <span class="string">fall</span> <span class="number">3</span></span><br><span class="line"><span class="string">frontend</span> <span class="string">es</span></span><br><span class="line">  <span class="string">bind</span> <span class="string">*:9300</span></span><br><span class="line">  <span class="string">default_backend</span> <span class="string">es</span></span><br><span class="line"><span class="string">backend</span> <span class="string">es</span></span><br><span class="line">  <span class="string">server</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span><span class="string">:9300</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span><span class="string">:9300</span> <span class="string">check</span> <span class="string">inter</span> <span class="number">1500</span> <span class="string">rise</span> <span class="number">3</span> <span class="string">fall</span> <span class="number">3</span></span><br><span class="line"><span class="string">frontend</span> <span class="string">mysql</span></span><br><span class="line">  <span class="string">bind</span> <span class="string">*:3306</span></span><br><span class="line">  <span class="string">default_backend</span> <span class="string">mysql</span></span><br><span class="line"><span class="string">backend</span> <span class="string">mysql</span></span><br><span class="line">  <span class="string">server</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.3</span><span class="string">:3306</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.3</span><span class="string">:3306</span> <span class="string">check</span> <span class="string">inter</span> <span class="number">1500</span> <span class="string">rise</span> <span class="number">3</span> <span class="string">fall</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<p>观察可以发现 frontend 和 backend 是成对出现的，一对为一个完整的配置，所以可以将  frontend 和 backend 对抽象为一个变量列表的元素，我们通过定义一个 ansible 变量列表循环生成同样的配置即可。变量具体定义如下（haproxy_servers 变量），下面为一个完整的测试 playbook。<br><code>playbook.yml</code>:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Test</span> <span class="string">Playbook...</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  become:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    haproxy_servers:</span></span><br><span class="line"><span class="attr">      - frontend:</span> <span class="string">'redis'</span></span><br><span class="line"><span class="attr">        bind_port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          - address:</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.1</span><span class="string">:6379</span></span><br><span class="line"><span class="attr">      - frontend:</span> <span class="string">'es'</span></span><br><span class="line"><span class="attr">        bind_port:</span> <span class="number">9300</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          - address:</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.2</span><span class="string">:9300</span></span><br><span class="line"><span class="attr">      - frontend:</span> <span class="string">'mysql'</span></span><br><span class="line"><span class="attr">        bind_port:</span> <span class="number">3306</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          - address:</span> <span class="number">10.1</span><span class="number">.1</span><span class="number">.3</span><span class="string">:3306</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">Generate</span> <span class="string">haproxy</span> <span class="string">config</span></span><br><span class="line"><span class="attr">      template:</span></span><br><span class="line"><span class="attr">        src:</span> <span class="string">haproxy.j2</span></span><br><span class="line"><span class="attr">        dest:</span> <span class="string">/tmp/haproxy.cfg</span></span><br><span class="line"><span class="attr">        mode:</span> <span class="number">0644</span></span><br><span class="line"><span class="attr">        force:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure></p>
<p>接下来我们看看模板文件 haproxy.j2 的定义：主要通过 jinja2 模板的循环语法遍历 haproxy_servers 变量生成 haproxy 配置。<br><code>haproxy.j2</code>:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span></span><br><span class="line">    maxconn         <span class="number">20000</span></span><br><span class="line">    ulimit-n        <span class="number">204800</span></span><br><span class="line">    log             <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> local3</span><br><span class="line">    user             haproxy</span><br><span class="line">    group            haproxy</span><br><span class="line">    chroot          /var/empty</span><br><span class="line">    nbproc      <span class="number">4</span> <span class="comment">#启动后运行的进程数量</span></span><br><span class="line">    daemon        <span class="comment">#以后台形式运行haproxy</span></span><br><span class="line">    pidfile     /var/run/haproxy.pid</span><br><span class="line">defaults</span><br><span class="line">    log <span class="keyword">global</span></span><br><span class="line">    mode tcp</span><br><span class="line">    retries <span class="number">3</span> <span class="comment">#3次连接失败认为服务不可用，也可以在后面设置</span></span><br><span class="line">    timeout connect <span class="number">5</span>s <span class="comment">#连接超时</span></span><br><span class="line">    timeout client <span class="number">30</span>s <span class="comment">#客户端超时</span></span><br><span class="line">    timeout server <span class="number">30</span>s <span class="comment">#服务器端超时</span></span><br><span class="line">    option redispatch</span><br><span class="line">    option    nolinger</span><br><span class="line">    no option dontlognull</span><br><span class="line">    option    tcplog</span><br><span class="line">    option log-separate-errors</span><br><span class="line"></span><br><span class="line">listen admin_stats  <span class="comment">#监控页面设置</span></span><br><span class="line">    bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">26000</span></span><br><span class="line">    bind-process <span class="number">1</span></span><br><span class="line">    mode http</span><br><span class="line">    log <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> local3 err</span><br><span class="line">    stats refresh <span class="number">30</span>s <span class="comment">#每隔30秒自动刷新监控页面</span></span><br><span class="line">    stats uri /admin</span><br><span class="line">    stats realm welcome login\ Haproxy</span><br><span class="line">    stats auth admin:<span class="number">123456</span></span><br><span class="line">    stats hide-version</span><br><span class="line">    stats admin <span class="keyword">if</span> TRUE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过配置文件动态生成 hproxy 配置</span></span><br><span class="line">&#123;% <span class="keyword">for</span> frontend <span class="keyword">in</span> haproxy_servers %&#125;</span><br><span class="line">frontend &#123;&#123; frontend.frontend &#125;&#125;</span><br><span class="line">  bind *:&#123;&#123; frontend.bind_port &#125;&#125;</span><br><span class="line">  default_backend &#123;&#123; frontend.frontend &#125;&#125;</span><br><span class="line">backend &#123;&#123; frontend.frontend &#125;&#125;</span><br><span class="line">&#123;% <span class="keyword">for</span> backend <span class="keyword">in</span> frontend.backend %&#125;</span><br><span class="line">  server &#123;&#123; backend.address &#125;&#125; &#123;&#123; backend.address &#125;&#125; check inter <span class="number">1500</span> rise <span class="number">3</span> fall <span class="number">3</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试下模板化结果？：我一般用 vagrant + ansible 测试 ansible 脚本，所以直接执行 <code>vagrant rsync &amp;&amp; vagrant provision</code> 即可看到效果。关于  vagrant + ansible 的最佳实践请戳之前的这篇文章：<a href="https://qhh.me/2019/06/07/%E4%BD%BF%E7%94%A8-Vagrant-%E8%B0%83%E8%AF%95-Ansible-Playbook/" target="_blank" rel="noopener">使用 Vagrant 调试 Ansible Playbook</a>。</p>
]]></content>
      
        <categories>
            
            <category> Ansible </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ansible </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何在 Centos7 使用 iptables]]></title>
      <url>/2019/06/09/%E5%A6%82%E4%BD%95%E5%9C%A8-Centos7-%E4%BD%BF%E7%94%A8-iptables/</url>
      <content type="html"><![CDATA[<p><img src="/images/centos-iptables.png" alt="Alt text"></p>
<p>从 Red Hat Enterprise Linux (RHEL) 7 和 CentOS 7 开始，<a href="https://firewalld.org/" target="_blank" rel="noopener">firewalld</a> 便作为系统默认的防火墙软件，替代之前的 iptables。firewalld 使用 <code>firewall-cmd</code> 命令管理防火墙规则，但是对于习惯了 iptables 的用户来说更倾向于使用传统的 iptables 方式，因为没有学习成本，能马上使用。即便 iptables 不再是 RHEL 7 和 CentOS 7 默认的防火墙管理软件，但是它们并没有完全屏蔽 iptables，通过安装依然可以使用。</p>
<h4 id="简单说下-iptables-和-firewalld-区别"><a href="#简单说下-iptables-和-firewalld-区别" class="headerlink" title="简单说下 iptables 和 firewalld 区别"></a>简单说下 iptables 和 firewalld 区别</h4><ul>
<li><a href="https://firewalld.org/" target="_blank" rel="noopener">firewalld</a>  是 Red Hat Enterprise Linux (RHEL) 7 和 CentOS 7 开始开始引进的防火墙管理软件；</li>
<li>firewalld 可以动态修改单条规则，而不需要像iptables那样，在修改了规则后必须得全部刷新才可以生效；</li>
<li>firewalld 在使用上要比 iptables 人性化很多，即使不明白“五张表五条链”而且对 TCP/IP 协议不理解也可以实现大部分功能；</li>
<li>firewalld 需要每个服务都去设置才能放行，因为默认是拒绝。而 iptables 里默认是每个服务是允许，需要拒绝的才去限制；</li>
<li>firewalld 自身并不具备防火墙的功能，而是和 iptables 一样需要通过内核的 <a href="https://www.netfilter.org/" target="_blank" rel="noopener">netfilter</a> 来实现，也就是说 firewalld 和 iptables一样，他们的作用都是用于维护规则，而真正使用规则干活的是内核的 netfilter，只不过 firewalld 和 iptables 的结构以及使用方法不一样罢了；</li>
<li>firewalld 底层调用的命令仍然是 iptables；<br>下图是 iptables 和 firewalld 的关系:<br><img src="/images/iptables-firewalld.png" alt="Alt text"></li>
</ul>
<hr>
<p>下面我们介绍下如何在 Centos7 系统下继续使用传统的 iptables 来管理防火墙规则。</p>
<h4 id="关闭并注销-systemd-管理的-firewalld-服务"><a href="#关闭并注销-systemd-管理的-firewalld-服务" class="headerlink" title="关闭并注销 systemd 管理的 firewalld 服务"></a>关闭并注销 systemd 管理的 firewalld 服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl stop firewalld</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注销 systmed 管理服务的过程相当于将原先指向相应 service 的软件链接</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新指向了 /dev/null</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> systemctl mask firewalld</span></span><br></pre></td></tr></table></figure>
<h4 id="安装并配置-iptables"><a href="#安装并配置-iptables" class="headerlink" title="安装并配置 iptables"></a>安装并配置 iptables</h4><ol>
<li><p>安装 iptables 命令行工具</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y iptables</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 iptables 服务（安装后默认归 systemd 管理）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y iptables-services</span><br></pre></td></tr></table></figure>
<p> 这一步<code>iptables-services</code>安装完后会自动生成 iptables 的规则文件:  <code>/etc/sysconfig/iptables</code></p>
</li>
<li><p>设置开机自启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> iptables</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 iptables 防火墙服务<br>启动防火墙后即可用 <code>iptables -L -n</code> 命令查看当前防火墙规则了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start iptables</span><br><span class="line">$ iptables -L -n</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:22</span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>               destination</span><br><span class="line">REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited</span><br></pre></td></tr></table></figure>
</li>
<li><p>iptables 添加防火墙规则，有两种方法：</p>
<ul>
<li><p>通过 iptables 命令行工具添加：<code>iptables -I INPUT ...</code>；<br>这种方式添加的规则不需要重启 iptables 即可立即生效，但是配置在重启服务器后会丢失，想持久保存下来执行如下命令（该命令会自动把命令行配置的规则写入 <code>/etc/sysconfig/iptables</code>，从而实现 iptables 规则的持久化保存）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service iptables save</span><br></pre></td></tr></table></figure>
<p> ⚠️注意 <code>service iptables save</code> 和 <code>iptables-save</code> 命令的区别：</p>
<ul>
<li><code>service iptables save</code> 作用是将 <code>iptables</code> 命令编辑的防火墙规则持久化保存下来，保存到 <code>/etc/sysconfig/iptables</code>；</li>
<li><code>iptables-save</code> 的作用是将内核中当前存在的防火墙规则导出来，和直接 <code>cat /etc/sysconfig/iptables</code> 的效果是一样的；</li>
</ul>
</li>
<li><p>通过编辑 <code>/etc/sysconfig/iptables</code> 文件添加防火墙规则；<br>通过这种方式添加的防火墙规则，需要重启 iptables 服务才能生效，并且服务器重启后配置的规则依然保留：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl restart iptables</span><br></pre></td></tr></table></figure>
<p>举例：添加/删除 禁止 ping 响应的规则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">添加禁止 ICMP 回显响应规则：</span><br><span class="line">iptables -A INPUT -i eth1 -p icmp -m icmp --icmp-type 8 -j DROP</span><br><span class="line">删除上面规则：</span><br><span class="line">iptables -D INPUT -i eth1 -p icmp -m icmp --icmp-type 8 -j DROP</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查看防火墙状态</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status iptables</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><p><a href="http://shaozhuqing.com/?p=4787" target="_blank" rel="noopener">http://shaozhuqing.com/?p=4787</a> | iptables 和 firewalld 关系<br><a href="https://blog.51cto.com/xjsunjie/1902993" target="_blank" rel="noopener">https://blog.51cto.com/xjsunjie/1902993</a> | 细说firewalld和iptables<br><a href="https://support.rackspace.com/how-to/use-iptables-with-centos-7/" target="_blank" rel="noopener">https://support.rackspace.com/how-to/use-iptables-with-centos-7/</a> | Use iptables with CentOS 7<br><a href="https://o-my-chenjian.com/2017/02/28/Using-Iptables-On-Centos7/" target="_blank" rel="noopener">https://o-my-chenjian.com/2017/02/28/Using-Iptables-On-Centos7/</a> | 在Centos7上使用Iptables</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Vagrant 调试 Ansible Playbook]]></title>
      <url>/2019/06/07/%E4%BD%BF%E7%94%A8-Vagrant-%E8%B0%83%E8%AF%95-Ansible-Playbook/</url>
      <content type="html"><![CDATA[<p> <img src="/images/vagrant-vbox-ansible.png" alt="Alt text"></p>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>本文主要介绍使用 Vagrant 本地调试 Ansible Playbook 的最佳实践。</p>
<p>我平时用 ansible 做一些自动化任务，难免要写很多 playbook，如果直接将写的 playbook 在线上或者真实的服务器运行难免会担心出错，而且很可能会导致严重的错误。最好的方法就是先在本地虚拟机测试好，然后跑到真实的环境。我们可以将 Vagrant 和 ansible 结合使用来轻松地在本地调试 playbook。为什么使用这种方式呢？我觉得有如下好处（当然用了之后就知道有多爽了）：</p>
<ul>
<li>虚拟机用 Vagrant 管理，随时可以方便地删除、重建，这些操作都是简单的命令行；</li>
<li>ansible 脚本在本地虚拟机可以随便折腾，哪怕 VM 折腾坏了，可以马上重建 VM；</li>
<li>所有操作都是基于配置文件，没有界面点触式操作，可以很好地将其工程化，放到 git 仓库统一管理；</li>
</ul>
<h3 id="Vagrant-结合-Ansible-的-workflow"><a href="#Vagrant-结合-Ansible-的-workflow" class="headerlink" title="Vagrant 结合 Ansible 的 workflow"></a>Vagrant 结合 Ansible 的 workflow</h3><p>Vagrant 结合 Ansible 的主要工作原理是使用 Vagrant 的 <a href="https://www.vagrantup.com/docs/provisioning/ansible_local.html" target="_blank" rel="noopener">ansible_local</a> 或者 <a href="https://www.vagrantup.com/docs/provisioning/ansible.html" target="_blank" rel="noopener">ansible</a> 配置器(Provisioner)，这两个的唯一区别是前者会在 provision 时自动在 VM 安装 ansible，后者不会自动安装，需要自行安装。我选择用 ansible_local 配置器，懒得装一遍 ansible… 而且在 <code>vagrant destroy</code> 销毁虚拟机后重建时还能得到与之前一致的配置。</p>
<p>下面介绍下我本地调试 ansible playbook 脚本的 workflow。</p>
<ol>
<li><p>使用 Vagrantfile 定义虚拟机</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.vm.box = <span class="string">"Centos7"</span></span><br><span class="line">  config.vm.hostname= <span class="string">"ansible"</span></span><br><span class="line">  config.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.10.100"</span></span><br><span class="line">  config.vm.provider <span class="symbol">:virtualbox</span> <span class="keyword">do</span> <span class="params">|vbox|</span></span><br><span class="line">      vbox.name = <span class="string">"ansible_vagrant"</span></span><br><span class="line">      vbox.memory = <span class="string">"512"</span></span><br><span class="line">      vbox.cpus = <span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># ansible 相关配置</span></span><br><span class="line">  config.vm.provision <span class="string">"ansible_local"</span> <span class="keyword">do</span> <span class="params">|ansible|</span></span><br><span class="line">    <span class="comment"># ansible 运行时输出详细信息，作用同 ansible-playbook 的 -v 参数</span></span><br><span class="line">    <span class="comment"># ansible.verbose = "v"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 指定运行哪个 playbook</span></span><br><span class="line">    ansible.playbook = <span class="string">"playbook.yml"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Vagrant 工程目录下编写 playbook，示例：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Test</span> <span class="string">Playbook...</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">all</span></span><br><span class="line"><span class="attr">  become:</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">  vars:</span></span><br><span class="line"><span class="attr">    - ip_list:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">remove</span> <span class="string">ip</span> <span class="string">list</span> <span class="string">file</span></span><br><span class="line"><span class="attr">      file:</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">absent</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/tmp/ip.txt</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">test</span> <span class="string">gen</span> <span class="string">file</span></span><br><span class="line"><span class="attr">      shell:</span> <span class="string">echo</span> <span class="string">"<span class="template-variable">&#123;&#123; item &#125;&#125;</span>"</span> <span class="string">&gt;&gt;</span> <span class="string">/tmp/ip.txt</span></span><br><span class="line"><span class="attr">      with_items:</span> <span class="string">"<span class="template-variable">&#123;&#123; ip_list &#125;&#125;</span>"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>playbook 写完后 执行 <code>vagrant up</code> 启动虚拟机，启动过程中会自动执行 Vagrantfile 中配置的 playbook 文件（在 Vagrant 工程目录下）；</p>
</li>
<li>如果 playbook 运行有问题，则继续修改；</li>
<li>执行 <code>vagrant rsync &amp;&amp; vagrant provision</code> 重新运行 playbook；<blockquote>
<p>注意：在执行 vagrant provision 之前，一定要先 vagrant rsync 同步下本地主机和 VM 的共享目录，否则本地修改后不会生效。ansible 脚本的运行最终是在 VM 上面，读取的文件都是在 VM 的 /vagrant 目录。</p>
</blockquote>
</li>
<li>如果测试 playbook 还是有问题则返回到第 4 步继续修改并测试；</li>
<li>如果一切都测试顺利的话，为了保险，最后模拟一下真实的环境：<code>vagrant destroy</code> 销毁 VM，然后 <code>vagrant up</code> 重新创建 VM 并自动运行 ansible playbook。</li>
</ol>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://linux.cn/article-9502-1.html" target="_blank" rel="noopener">https://linux.cn/article-9502-1.html</a> | 使用 Vagrant 测试 Ansible 剧本<br><a href="https://www.vagrantup.com/docs/provisioning/ansible_intro.html" target="_blank" rel="noopener">https://www.vagrantup.com/docs/provisioning/ansible_intro.html</a> | Vagrant 和 Ansible<br><a href="https://www.vagrantup.com/docs/provisioning/ansible_local.html" target="_blank" rel="noopener">https://www.vagrantup.com/docs/provisioning/ansible_local.html</a> | Vagrant ansible_local 配置器<br><a href="https://www.vagrantup.com/docs/provisioning/ansible_common.html" target="_blank" rel="noopener">https://www.vagrantup.com/docs/provisioning/ansible_common.html</a> | Vagrant ansible 和 ansible_local 配置器通用配置</p>
]]></content>
      
        <categories>
            
            <category> Ansible </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ansible </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo next 主题加载自定义 js 文件]]></title>
      <url>/2019/06/02/Hexo-next-%E4%B8%BB%E9%A2%98%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%AE%9A%E4%B9%89-js-%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>为什么要配置 hexo next 主题自定义 js 文件呢？主要原因有两点：</p>
<ul>
<li><p>不可靠：加载第三方站点的 js 依赖其站点的稳定性，如果第三方站点给挂了或者不维护了，那么加载的地址就失效了，访问直接 404… 比如最近就遇到 next 主题”不蒜子”文章 PV 统计功能用不了了，Chrome 抓包发现 <a href="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" target="_blank" rel="noopener">https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js</a> 这个地址 404 了，看了 <a href="http://ibruce.info/" target="_blank" rel="noopener">“不蒜子”官方 blog 通知</a> 才发现原来换成了 <a href="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js。" target="_blank" rel="noopener">https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js。</a></p>
</li>
<li><p>加载速度慢：比如之前将 gitalk 功能用到的 <a href="https://rawgit.com/qhh0205/78e9e0b1f3114db6737f3ed8cdd51d3a/raw/3894c5be5aa2378336b1f5ee0f296fa0b22d06e9/md5.min.js" target="_blank" rel="noopener">https://rawgit.com/qhh0205/78e9e0b1f3114db6737f3ed8cdd51d3a/raw/3894c5be5aa2378336b1f5ee0f296fa0b22d06e9/md5.min.js</a> 文件嵌入到主题，发现每次打开 blog 网站都加载很慢，Chrome 抓包发现是该文件加载缓慢，一直 pending 很久…</p>
</li>
</ul>
<p>那么解决上面两个问题的办法就是可以将远程加载的 js 文件下载下来，放到本地 netx 主题 source/js/src/ 目录下，让 hexo 生成静态网站时，加载生成静态站点本身的 js。下面举两个例子。</p>
<h4 id="next-主题-gitalk-评论功能加载自定义-js"><a href="#next-主题-gitalk-评论功能加载自定义-js" class="headerlink" title="next 主题 gitalk 评论功能加载自定义 js"></a>next 主题 gitalk 评论功能加载自定义 js</h4><ol>
<li>将 <a href="https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js" target="_blank" rel="noopener">https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js</a> 文件下载下来放到 <code>themes/next/source/js/src/</code> 路径下。</li>
<li>修改 <code>themes/next/layout/_third-party/comments/gitalk.swig</code>，加载 <code>md5.min.js</code> 改为 <code>&lt;script src=&quot;/js/src/md5.min.js&quot;&gt;&lt;/script&gt;</code>：<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/md5.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span></span><br><span class="line"><span class="xml">        var gitalk = new Gitalk(&#123;</span></span><br><span class="line"><span class="xml">          clientID: '3840ba8c8d80c18be7e3',</span></span><br><span class="line"><span class="xml">          clientSecret: '1b00f2efe5285973c24da9ed9ac895775eacc8ea',</span></span><br><span class="line"><span class="xml">          repo: '</span><span class="template-variable">&#123;&#123; theme.gitalk.repo &#125;&#125;</span><span class="xml">',</span></span><br><span class="line"><span class="xml">          owner: '</span><span class="template-variable">&#123;&#123; theme.gitalk.githubID &#125;&#125;</span><span class="xml">',</span></span><br><span class="line"><span class="xml">          admin: ['</span><span class="template-variable">&#123;&#123; theme.gitalk.adminUser &#125;&#125;</span><span class="xml">'],</span></span><br><span class="line"><span class="xml">          id: md5(location.pathname),</span></span><br><span class="line"><span class="xml">          distractionFreeMode: '</span><span class="template-variable">&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;</span><span class="xml">'</span></span><br><span class="line"><span class="xml">        &#125;)</span></span><br><span class="line"><span class="xml">        gitalk.render('gitalk-container')</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="next-主题-“不蒜子”-PV-统计功能加载自定义-js"><a href="#next-主题-“不蒜子”-PV-统计功能加载自定义-js" class="headerlink" title="next 主题 “不蒜子” PV 统计功能加载自定义 js"></a>next 主题 “不蒜子” PV 统计功能加载自定义 js</h4><ol>
<li>将 <a href="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" target="_blank" rel="noopener">https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js</a> 文件下载<br>下来放到 <code>themes/next/source/js/src/</code> 路径下。</li>
<li>修改 <code>themes/next/layout/_third-party/analytics/busuanzi-counter.swig</code>，将原先 <code>&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code> 改为 <code>&lt;script async src=&quot;/js/src/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code>：<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.busuanzi_count.enable %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"busuanzi-count"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"/js/src/busuanzi.pure.mini.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.busuanzi_count.site_uv %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-uv"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123; theme.busuanzi_count.site_uv_header &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"busuanzi-value"</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123; theme.busuanzi_count.site_uv_footer &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.busuanzi_count.site_pv %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-pv"</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123; theme.busuanzi_count.site_pv_header &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"busuanzi-value"</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-variable">&#123;&#123; theme.busuanzi_count.site_pv_footer &#125;&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>配置完成后需要 hexo clean &amp;&amp; hexo g 生效…</p>
<h4 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h4><p>怕以下两个远程站点 js 丢了，在此备份一下吧…<br><a href="https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js：" target="_blank" rel="noopener">https://github.com/blueimp/JavaScript-MD5/blob/master/js/md5.min.js：</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;<span class="string">"use strict"</span>;<span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">n,t</span>)</span>&#123;<span class="keyword">var</span> r=(<span class="number">65535</span>&amp;n)+(<span class="number">65535</span>&amp;t);<span class="keyword">return</span>(n&gt;&gt;<span class="number">16</span>)+(t&gt;&gt;<span class="number">16</span>)+(r&gt;&gt;<span class="number">16</span>)&lt;&lt;<span class="number">16</span>|<span class="number">65535</span>&amp;r&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params">n,t</span>)</span>&#123;<span class="keyword">return</span> n&lt;&lt;t|n&gt;&gt;&gt;<span class="number">32</span>-t&#125;<span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params">n,e,o,u,c,f</span>)</span>&#123;<span class="keyword">return</span> t(r(t(t(e,n),t(u,f)),c),o)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params">n,t,r,o,u,c,f</span>)</span>&#123;<span class="keyword">return</span> e(t&amp;r|~t&amp;o,n,t,u,c,f)&#125;<span class="function"><span class="keyword">function</span> <span class="title">u</span>(<span class="params">n,t,r,o,u,c,f</span>)</span>&#123;<span class="keyword">return</span> e(t&amp;o|r&amp;~o,n,t,u,c,f)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">n,t,r,o,u,c,f</span>)</span>&#123;<span class="keyword">return</span> e(t^r^o,n,t,u,c,f)&#125;<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n,t,r,o,u,c,f</span>)</span>&#123;<span class="keyword">return</span> e(r^(t|~o),n,t,u,c,f)&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">n,r</span>)</span>&#123;n[r&gt;&gt;<span class="number">5</span>]|=<span class="number">128</span>&lt;&lt;r%<span class="number">32</span>,n[<span class="number">14</span>+(r+<span class="number">64</span>&gt;&gt;&gt;<span class="number">9</span>&lt;&lt;<span class="number">4</span>)]=r;<span class="keyword">var</span> e,i,a,d,h,l=<span class="number">1732584193</span>,g=<span class="number">-271733879</span>,v=<span class="number">-1732584194</span>,m=<span class="number">271733878</span>;<span class="keyword">for</span>(e=<span class="number">0</span>;e&lt;n.length;e+=<span class="number">16</span>)i=l,a=g,d=v,h=m,g=f(g=f(g=f(g=f(g=c(g=c(g=c(g=c(g=u(g=u(g=u(g=u(g=o(g=o(g=o(g=o(g,v=o(v,m=o(m,l=o(l,g,v,m,n[e],<span class="number">7</span>,<span class="number">-680876936</span>),g,v,n[e+<span class="number">1</span>],<span class="number">12</span>,<span class="number">-389564586</span>),l,g,n[e+<span class="number">2</span>],<span class="number">17</span>,<span class="number">606105819</span>),m,l,n[e+<span class="number">3</span>],<span class="number">22</span>,<span class="number">-1044525330</span>),v=o(v,m=o(m,l=o(l,g,v,m,n[e+<span class="number">4</span>],<span class="number">7</span>,<span class="number">-176418897</span>),g,v,n[e+<span class="number">5</span>],<span class="number">12</span>,<span class="number">1200080426</span>),l,g,n[e+<span class="number">6</span>],<span class="number">17</span>,<span class="number">-1473231341</span>),m,l,n[e+<span class="number">7</span>],<span class="number">22</span>,<span class="number">-45705983</span>),v=o(v,m=o(m,l=o(l,g,v,m,n[e+<span class="number">8</span>],<span class="number">7</span>,<span class="number">1770035416</span>),g,v,n[e+<span class="number">9</span>],<span class="number">12</span>,<span class="number">-1958414417</span>),l,g,n[e+<span class="number">10</span>],<span class="number">17</span>,<span class="number">-42063</span>),m,l,n[e+<span class="number">11</span>],<span class="number">22</span>,<span class="number">-1990404162</span>),v=o(v,m=o(m,l=o(l,g,v,m,n[e+<span class="number">12</span>],<span class="number">7</span>,<span class="number">1804603682</span>),g,v,n[e+<span class="number">13</span>],<span class="number">12</span>,<span class="number">-40341101</span>),l,g,n[e+<span class="number">14</span>],<span class="number">17</span>,<span class="number">-1502002290</span>),m,l,n[e+<span class="number">15</span>],<span class="number">22</span>,<span class="number">1236535329</span>),v=u(v,m=u(m,l=u(l,g,v,m,n[e+<span class="number">1</span>],<span class="number">5</span>,<span class="number">-165796510</span>),g,v,n[e+<span class="number">6</span>],<span class="number">9</span>,<span class="number">-1069501632</span>),l,g,n[e+<span class="number">11</span>],<span class="number">14</span>,<span class="number">643717713</span>),m,l,n[e],<span class="number">20</span>,<span class="number">-373897302</span>),v=u(v,m=u(m,l=u(l,g,v,m,n[e+<span class="number">5</span>],<span class="number">5</span>,<span class="number">-701558691</span>),g,v,n[e+<span class="number">10</span>],<span class="number">9</span>,<span class="number">38016083</span>),l,g,n[e+<span class="number">15</span>],<span class="number">14</span>,<span class="number">-660478335</span>),m,l,n[e+<span class="number">4</span>],<span class="number">20</span>,<span class="number">-405537848</span>),v=u(v,m=u(m,l=u(l,g,v,m,n[e+<span class="number">9</span>],<span class="number">5</span>,<span class="number">568446438</span>),g,v,n[e+<span class="number">14</span>],<span class="number">9</span>,<span class="number">-1019803690</span>),l,g,n[e+<span class="number">3</span>],<span class="number">14</span>,<span class="number">-187363961</span>),m,l,n[e+<span class="number">8</span>],<span class="number">20</span>,<span class="number">1163531501</span>),v=u(v,m=u(m,l=u(l,g,v,m,n[e+<span class="number">13</span>],<span class="number">5</span>,<span class="number">-1444681467</span>),g,v,n[e+<span class="number">2</span>],<span class="number">9</span>,<span class="number">-51403784</span>),l,g,n[e+<span class="number">7</span>],<span class="number">14</span>,<span class="number">1735328473</span>),m,l,n[e+<span class="number">12</span>],<span class="number">20</span>,<span class="number">-1926607734</span>),v=c(v,m=c(m,l=c(l,g,v,m,n[e+<span class="number">5</span>],<span class="number">4</span>,<span class="number">-378558</span>),g,v,n[e+<span class="number">8</span>],<span class="number">11</span>,<span class="number">-2022574463</span>),l,g,n[e+<span class="number">11</span>],<span class="number">16</span>,<span class="number">1839030562</span>),m,l,n[e+<span class="number">14</span>],<span class="number">23</span>,<span class="number">-35309556</span>),v=c(v,m=c(m,l=c(l,g,v,m,n[e+<span class="number">1</span>],<span class="number">4</span>,<span class="number">-1530992060</span>),g,v,n[e+<span class="number">4</span>],<span class="number">11</span>,<span class="number">1272893353</span>),l,g,n[e+<span class="number">7</span>],<span class="number">16</span>,<span class="number">-155497632</span>),m,l,n[e+<span class="number">10</span>],<span class="number">23</span>,<span class="number">-1094730640</span>),v=c(v,m=c(m,l=c(l,g,v,m,n[e+<span class="number">13</span>],<span class="number">4</span>,<span class="number">681279174</span>),g,v,n[e],<span class="number">11</span>,<span class="number">-358537222</span>),l,g,n[e+<span class="number">3</span>],<span class="number">16</span>,<span class="number">-722521979</span>),m,l,n[e+<span class="number">6</span>],<span class="number">23</span>,<span class="number">76029189</span>),v=c(v,m=c(m,l=c(l,g,v,m,n[e+<span class="number">9</span>],<span class="number">4</span>,<span class="number">-640364487</span>),g,v,n[e+<span class="number">12</span>],<span class="number">11</span>,<span class="number">-421815835</span>),l,g,n[e+<span class="number">15</span>],<span class="number">16</span>,<span class="number">530742520</span>),m,l,n[e+<span class="number">2</span>],<span class="number">23</span>,<span class="number">-995338651</span>),v=f(v,m=f(m,l=f(l,g,v,m,n[e],<span class="number">6</span>,<span class="number">-198630844</span>),g,v,n[e+<span class="number">7</span>],<span class="number">10</span>,<span class="number">1126891415</span>),l,g,n[e+<span class="number">14</span>],<span class="number">15</span>,<span class="number">-1416354905</span>),m,l,n[e+<span class="number">5</span>],<span class="number">21</span>,<span class="number">-57434055</span>),v=f(v,m=f(m,l=f(l,g,v,m,n[e+<span class="number">12</span>],<span class="number">6</span>,<span class="number">1700485571</span>),g,v,n[e+<span class="number">3</span>],<span class="number">10</span>,<span class="number">-1894986606</span>),l,g,n[e+<span class="number">10</span>],<span class="number">15</span>,<span class="number">-1051523</span>),m,l,n[e+<span class="number">1</span>],<span class="number">21</span>,<span class="number">-2054922799</span>),v=f(v,m=f(m,l=f(l,g,v,m,n[e+<span class="number">8</span>],<span class="number">6</span>,<span class="number">1873313359</span>),g,v,n[e+<span class="number">15</span>],<span class="number">10</span>,<span class="number">-30611744</span>),l,g,n[e+<span class="number">6</span>],<span class="number">15</span>,<span class="number">-1560198380</span>),m,l,n[e+<span class="number">13</span>],<span class="number">21</span>,<span class="number">1309151649</span>),v=f(v,m=f(m,l=f(l,g,v,m,n[e+<span class="number">4</span>],<span class="number">6</span>,<span class="number">-145523070</span>),g,v,n[e+<span class="number">11</span>],<span class="number">10</span>,<span class="number">-1120210379</span>),l,g,n[e+<span class="number">2</span>],<span class="number">15</span>,<span class="number">718787259</span>),m,l,n[e+<span class="number">9</span>],<span class="number">21</span>,<span class="number">-343485551</span>),l=t(l,i),g=t(g,a),v=t(v,d),m=t(m,h);<span class="keyword">return</span>[l,g,v,m]&#125;<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">var</span> t,r=<span class="string">""</span>,e=<span class="number">32</span>*n.length;<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;e;t+=<span class="number">8</span>)r+=<span class="built_in">String</span>.fromCharCode(n[t&gt;&gt;<span class="number">5</span>]&gt;&gt;&gt;t%<span class="number">32</span>&amp;<span class="number">255</span>);<span class="keyword">return</span> r&#125;<span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">var</span> t,r=[];<span class="keyword">for</span>(r[(n.length&gt;&gt;<span class="number">2</span>)<span class="number">-1</span>]=<span class="keyword">void</span> <span class="number">0</span>,t=<span class="number">0</span>;t&lt;r.length;t+=<span class="number">1</span>)r[t]=<span class="number">0</span>;<span class="keyword">var</span> e=<span class="number">8</span>*n.length;<span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;e;t+=<span class="number">8</span>)r[t&gt;&gt;<span class="number">5</span>]|=(<span class="number">255</span>&amp;n.charCodeAt(t/<span class="number">8</span>))&lt;&lt;t%<span class="number">32</span>;<span class="keyword">return</span> r&#125;<span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">return</span> a(i(d(n),<span class="number">8</span>*n.length))&#125;<span class="function"><span class="keyword">function</span> <span class="title">l</span>(<span class="params">n,t</span>)</span>&#123;<span class="keyword">var</span> r,e,o=d(n),u=[],c=[];<span class="keyword">for</span>(u[<span class="number">15</span>]=c[<span class="number">15</span>]=<span class="keyword">void</span> <span class="number">0</span>,o.length&gt;<span class="number">16</span>&amp;&amp;(o=i(o,<span class="number">8</span>*n.length)),r=<span class="number">0</span>;r&lt;<span class="number">16</span>;r+=<span class="number">1</span>)u[r]=<span class="number">909522486</span>^o[r],c[r]=<span class="number">1549556828</span>^o[r];<span class="keyword">return</span> e=i(u.concat(d(t)),<span class="number">512</span>+<span class="number">8</span>*t.length),a(i(c.concat(e),<span class="number">640</span>))&#125;<span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">var</span> t,r,e=<span class="string">""</span>;<span class="keyword">for</span>(r=<span class="number">0</span>;r&lt;n.length;r+=<span class="number">1</span>)t=n.charCodeAt(r),e+=<span class="string">"0123456789abcdef"</span>.charAt(t&gt;&gt;&gt;<span class="number">4</span>&amp;<span class="number">15</span>)+<span class="string">"0123456789abcdef"</span>.charAt(<span class="number">15</span>&amp;t);<span class="keyword">return</span> e&#125;<span class="function"><span class="keyword">function</span> <span class="title">v</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">return</span> <span class="built_in">unescape</span>(<span class="built_in">encodeURIComponent</span>(n))&#125;<span class="function"><span class="keyword">function</span> <span class="title">m</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">return</span> h(v(n))&#125;<span class="function"><span class="keyword">function</span> <span class="title">p</span>(<span class="params">n</span>)</span>&#123;<span class="keyword">return</span> g(m(n))&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">n,t</span>)</span>&#123;<span class="keyword">return</span> l(v(n),v(t))&#125;<span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">n,t</span>)</span>&#123;<span class="keyword">return</span> g(s(n,t))&#125;<span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">n,t,r</span>)</span>&#123;<span class="keyword">return</span> t?r?s(t,n):C(t,n):r?m(n):p(n)&#125;<span class="string">"function"</span>==<span class="keyword">typeof</span> define&amp;&amp;define.amd?define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> A&#125;):<span class="string">"object"</span>==<span class="keyword">typeof</span> <span class="built_in">module</span>&amp;&amp;<span class="built_in">module</span>.exports?<span class="built_in">module</span>.exports=A:n.md5=A&#125;(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//# sourceMappingURL=md5.min.js.map</span></span><br></pre></td></tr></table></figure></p>
<p><a href="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" target="_blank" rel="noopener">https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js</a>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bszCaller,bszTag;!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> c,d,e,a=!<span class="number">1</span>,b=[];ready=<span class="function"><span class="keyword">function</span>(<span class="params">c</span>)</span>&#123;<span class="keyword">return</span> a||<span class="string">"interactive"</span>===<span class="built_in">document</span>.readyState||<span class="string">"complete"</span>===<span class="built_in">document</span>.readyState?c.call(<span class="built_in">document</span>):b.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> c.call(<span class="keyword">this</span>)&#125;),<span class="keyword">this</span>&#125;,d=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=<span class="number">0</span>,c=b.length;c&gt;a;a++)b[a].apply(<span class="built_in">document</span>);b=[]&#125;,e=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;a||(a=!<span class="number">0</span>,d.call(<span class="built_in">window</span>),<span class="built_in">document</span>.removeEventListener?<span class="built_in">document</span>.removeEventListener(<span class="string">"DOMContentLoaded"</span>,e,!<span class="number">1</span>):<span class="built_in">document</span>.attachEvent&amp;&amp;(<span class="built_in">document</span>.detachEvent(<span class="string">"onreadystatechange"</span>,e),<span class="built_in">window</span>==<span class="built_in">window</span>.top&amp;&amp;(clearInterval(c),c=<span class="literal">null</span>)))&#125;,<span class="built_in">document</span>.addEventListener?<span class="built_in">document</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>,e,!<span class="number">1</span>):<span class="built_in">document</span>.attachEvent&amp;&amp;(<span class="built_in">document</span>.attachEvent(<span class="string">"onreadystatechange"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;/loaded|complete/.test(<span class="built_in">document</span>.readyState)&amp;&amp;e()&#125;),<span class="built_in">window</span>==<span class="built_in">window</span>.top&amp;&amp;(c=setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">try</span>&#123;a||<span class="built_in">document</span>.documentElement.doScroll(<span class="string">"left"</span>)&#125;<span class="keyword">catch</span>(b)&#123;<span class="keyword">return</span>&#125;e()&#125;,<span class="number">5</span>)))&#125;(),bszCaller=&#123;<span class="attr">fetch</span>:<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">var</span> c=<span class="string">"BusuanziCallback_"</span>+<span class="built_in">Math</span>.floor(<span class="number">1099511627776</span>*<span class="built_in">Math</span>.random());<span class="built_in">window</span>[c]=<span class="keyword">this</span>.evalCall(b),a=a.replace(<span class="string">"=BusuanziCallback"</span>,<span class="string">"="</span>+c),scriptTag=<span class="built_in">document</span>.createElement(<span class="string">"SCRIPT"</span>),scriptTag.type=<span class="string">"text/javascript"</span>,scriptTag.defer=!<span class="number">0</span>,scriptTag.src=a,<span class="built_in">document</span>.getElementsByTagName(<span class="string">"HEAD"</span>)[<span class="number">0</span>].appendChild(scriptTag)&#125;,<span class="attr">evalCall</span>:<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">try</span>&#123;a(b),scriptTag.parentElement.removeChild(scriptTag)&#125;<span class="keyword">catch</span>(c)&#123;bszTag.hides()&#125;&#125;)&#125;&#125;&#125;,bszCaller.fetch(<span class="string">"//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;bszTag.texts(a),bszTag.shows()&#125;),bszTag=&#123;<span class="attr">bszs</span>:[<span class="string">"site_pv"</span>,<span class="string">"page_pv"</span>,<span class="string">"site_uv"</span>],<span class="attr">texts</span>:<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">this</span>.bszs.map(<span class="function"><span class="keyword">function</span>(<span class="params">b</span>)</span>&#123;<span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"busuanzi_value_"</span>+b);c&amp;&amp;(c.innerHTML=a[b])&#125;)&#125;,<span class="attr">hides</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.bszs.map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">var</span> b=<span class="built_in">document</span>.getElementById(<span class="string">"busuanzi_container_"</span>+a);b&amp;&amp;(b.style.display=<span class="string">"none"</span>)&#125;)&#125;,<span class="attr">shows</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">this</span>.bszs.map(<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;<span class="keyword">var</span> b=<span class="built_in">document</span>.getElementById(<span class="string">"busuanzi_container_"</span>+a);b&amp;&amp;(b.style.display=<span class="string">"inline"</span>)&#125;)&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[docker-compose 启动 Redis 服务]]></title>
      <url>/2019/05/31/docker-compose-%E5%90%AF%E5%8A%A8-Redis-%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>使用 docker-compose 以 aof 持久化方式启动单节点 Redis。<br>docker-compose.yml:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">redis:4.0.13</span> </span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">    restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">    command:</span> <span class="bullet">--appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="number">6379</span><span class="string">:6379</span></span><br><span class="line"><span class="attr">    volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./redis_data:/data</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx root 和 alias 指令的区别]]></title>
      <url>/2019/05/31/Nginx-root-%E5%92%8C-alias-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>nginx 的 root 和 alias 指令都是用于访问服务器本地文件的，两者区别如下：</p>
<ul>
<li><p>配置语法及适用范围</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">root</span>]</span><br><span class="line">语法：root path</span><br><span class="line">默认值：root html</span><br><span class="line">配置段：http、server、location、<span class="keyword">if</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">alias</span>]</span><br><span class="line">语法：<span class="keyword">alias</span> path</span><br><span class="line">配置段：location</span><br></pre></td></tr></table></figure>
</li>
<li><p>root 的处理结果是：root 路径＋location 路径；</p>
</li>
<li>alias 的处理结果是：使用 alias 路径替换 location 路径；</li>
<li>alias 后面的路径结尾必须是 ‘/‘，而 root 可有可无；</li>
</ul>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><h5 id="当-location-配置为如下时："><a href="#当-location-配置为如下时：" class="headerlink" title="当 location 配置为如下时："></a>当 location 配置为如下时：</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ <span class="regexp">/documents/</span> &#123;</span><br><span class="line">    root <span class="regexp">/var/</span>www-html<span class="regexp">/documents/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求：GET /documents/a.js  —&gt; 相当于请求本地路径：/var/www-html/documents/documents/a.js</p>
<p>请求：GET /documents/html/index.html  —&gt; 相当于请求本地路径：/var/www-html/documents/documents/html/index.html</p>
<h5 id="当-location-配置为如下时：-1"><a href="#当-location-配置为如下时：-1" class="headerlink" title="当 location 配置为如下时："></a>当 location 配置为如下时：</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ^~ <span class="regexp">/documents/</span> &#123;</span><br><span class="line">  alias <span class="regexp">/var/</span>www-html<span class="regexp">/documents/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求：GET /documents/a.js  —&gt; 相当于请求本地路径：/var/www-html/documents/a.js</p>
<p>请求：GET /documents/html/index.html  —&gt; 相当于请求本地路径：/var/www-html/documents/html/index.html</p>
]]></content>
      
        <categories>
            
            <category> Nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wireshark 抓包理解 HTTPS 协议]]></title>
      <url>/2019/05/26/Wireshark-%E6%8A%93%E5%8C%85%E7%90%86%E8%A7%A3-HTTPS-%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<h3 id="HTTPS-简介"><a href="#HTTPS-简介" class="headerlink" title="HTTPS 简介"></a>HTTPS 简介</h3><p>HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer）协议是 HTTP 协议的安全版，在 HTTP 应用层和传输层加入了 SSL/TLS 层，确保数据传输的安全性，所以 HTTPS 协议并不是什么新的协议，仅仅是 HTTP 协议和安全协议的组合。</p>
<p>HTTPS 协议主要解决如下三个通信安全问题：</p>
<ul>
<li>窃听风险（eavesdropping）：第三方可以获知通信内容。</li>
<li>篡改风险（tampering）：第三方可以修改通信内容。</li>
<li>冒充风险（pretending）：第三方可以冒充他人身份参与通信。</li>
</ul>
<p>HTTPS 通过 SSL/TLS 协议解决了上述三个问题，可以达到：</p>
<ul>
<li>加密数据以防止数据中途被窃取；</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变；</li>
<li>认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
</ul>
<p>既然安全问题是 SSL/TLS 保证的，那么就有必要仔细探索下 SSL/TLS 协议的机制，如下为 HTTPS 通信的整个网络协议栈，其中 SSL/TLS 协议又分为两层：</p>
<ul>
<li>握手协议（SSL Handshake Protocol）：它建立在记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li>
<li>记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</li>
</ul>
<p>关于更多 SSL 和 TLS 知识见之前的文章: <a href="https://qhh.me/2019/05/18/%E5%9F%BA%E4%BA%8E-OpenSSL-%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/" target="_blank" rel="noopener">基于 OpenSSL 生成自签名证书</a>。<br><img src="/images/ssl-tls.png" alt="Alt text"></p>
<h3 id="SSL-TLS-通信过程"><a href="#SSL-TLS-通信过程" class="headerlink" title="SSL/TLS 通信过程"></a>SSL/TLS 通信过程</h3><p>开始加密通信之前，客户端和服务器首先必须建立连接和交换参数，这个过程叫做握手（handshake）。SSL/TLS 握手其实就是通过非对称加密，生成对称加密的 session key 的过程。</p>
<p>假定客户端叫做爱丽丝服务器叫做鲍勃，整个握手过程可以用下图说明：<br><img src="/images/ssl_handshake.png" alt="Alt text"></p>
<p>整个握手过程通俗地说分为如下五步（真实的过程涉及的细节比这个多）：</p>
<ul>
<li>第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。</li>
<li>第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。</li>
<li>第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使 用数字证书中的公钥，加密这个随机数，发给鲍勃。</li>
<li>第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。</li>
<li>第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。</li>
</ul>
<p><img src="/images/ssl_handshake2.png" alt="Alt text"></p>
<p>SSL 握手的过程为双方发送消息的过程，这里所说的消息并不是一个独立的 TCP 数据包，而是 SSL 协议的术语。根据服务端实现的不同，可能一个 TCP 包中包含多条消息，而不是每条消息单独发送（每条单独发送效率太低），这个我们后面通过 Wireshark 抓包可以看到。</p>
<p>下图为双方握手过程中互相发送的 SSL 消息：<br><img src="/images/ssl_message.png" alt="Alt text"></p>
<h4 id="客户端发送的初始消息"><a href="#客户端发送的初始消息" class="headerlink" title="客户端发送的初始消息"></a>客户端发送的初始消息</h4><h5 id="Client-Hello-消息"><a href="#Client-Hello-消息" class="headerlink" title="Client Hello 消息"></a>Client Hello 消息</h5><p>客户端发送 Client Hello 消息给服务端来初始化会话消息，该消息包含如下信息：</p>
<ul>
<li>Version Number: 客户端发送它所支持的最高 SSL/TLS 版本。版本 2 代表 SSL 2.0，版本 3 代表 SSL 3.0，版本 3.1 代表 TLS。</li>
<li>Randomly Generated Data：一个 32 字节的客户端随机数，该随机数被服务端生成通信用的对称密钥（master secret）；</li>
<li>Session Identification ：session ID 被客户端用于恢复之前的会话（只有恢复 session 时该字段才有值），这样可以简化 SSL 握手过程，避免每次请求都建立新的连接而握手，握手过程是需要消耗很多计算资源的。已建立的连接信息存储在客户端和服务端各自的 session 缓存中，用 session ID 标识；</li>
<li>Cipher Suite: 客户端发送它所支持的加密套件列表；</li>
<li>Compression Algorithm: 压缩算法，目前该字段几乎不在使用；</li>
</ul>
<h4 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应"></a>服务端响应</h4><h5 id="Server-Hello-消息"><a href="#Server-Hello-消息" class="headerlink" title="Server Hello 消息"></a>Server Hello 消息</h5><p>服务端回复 Server Hello 消息给客户端：</p>
<ul>
<li>Version Number：服务端发送双发所支持的最高的 SSL/TLS 版本；</li>
<li>Randomly Generated Data：一个 32 字节的服务端随机数，被客户端用于生成通信用的对称密钥（master secret）；</li>
<li>Session Identification：该字段有如下三中情况：<ul>
<li>New session ID：客户端和服务端初次建立连接时生成的 session ID。或者客户端尝试恢复 session，但是服务端无法恢复，因此也会生成新的 session ID；</li>
<li>Resumed Session ID：和客户端发送的恢复会话 ID 一致，用于恢复会话；</li>
<li>Null：该字段为 Null，表明这是一个新的 Session，但是服务端不打算用于后续的会话恢复，因此不会产生 session ID，该字段为空；</li>
</ul>
</li>
<li>Cipher Suite: 服务端发送双发支持的最安全的加密套件；</li>
<li>Compression Algorithm：指定双方使用的压缩算法，目前该字段几乎不在使用；</li>
</ul>
<h5 id="Server-Certificate-消息"><a href="#Server-Certificate-消息" class="headerlink" title="Server Certificate 消息"></a>Server Certificate 消息</h5><p>服务端发送自己的 SSL 证书给客户端，证书中包含服务端的公钥，客户端用该证书验证服务端的身份。</p>
<h5 id="Server-Key-Exchange-消息"><a href="#Server-Key-Exchange-消息" class="headerlink" title="Server Key Exchange 消息"></a>Server Key Exchange 消息</h5><p>这个消息是可选的，该消息主要用来传递双方协商密钥的参数，比如双方使用 Diffie-Hellman (迪菲) 算法生成 premaster secret 时，会用该字段传递双方的公共参数。所以具体该字段是什么内容取决于双方协商密钥的加密套件。</p>
<h5 id="Client-Certificate-Request-消息"><a href="#Client-Certificate-Request-消息" class="headerlink" title="Client Certificate Request 消息"></a>Client Certificate Request 消息</h5><p>这个消息也是可选的，只有当服务端也需要验证客户端会用到。有的安全度高的网站会要求验证客户端，确认客户的真实身份，比如银行之类的网站。</p>
<h5 id="Server-Hello-Done-消息"><a href="#Server-Hello-Done-消息" class="headerlink" title="Server Hello Done 消息"></a>Server Hello Done 消息</h5><p>服务器发送 ServerHelloDone 消息，告知客户端服务端这边握手相关的消息发送完毕，等待客户端响应。</p>
<h4 id="客户端回复"><a href="#客户端回复" class="headerlink" title="客户端回复"></a>客户端回复</h4><h5 id="Client-Certificate-消息"><a href="#Client-Certificate-消息" class="headerlink" title="Client Certificate 消息"></a>Client Certificate 消息</h5><p>如果服务端发送了 Client Certificate Request 消息，那么客户端会发送该消息给服务端，包含自己的证书信息，供服务端进行客户端身份认证。</p>
<h5 id="Client-Key-Exchange-消息"><a href="#Client-Key-Exchange-消息" class="headerlink" title="Client Key Exchange 消息"></a>Client Key Exchange 消息</h5><p>根据协商的密钥算法不同，该消息的内容会不同，该消息主要包含密钥协商的参数。比如双方使用 Diffie-Hellman (迪菲) 算法生成 premaster secret 时，会用该字段传递双方的公共参数。</p>
<h5 id="Certificate-Verify-消息"><a href="#Certificate-Verify-消息" class="headerlink" title="Certificate Verify 消息"></a>Certificate Verify 消息</h5><p>该消息只有在 Client Certificate message 消息发送时才发送。客户端通过自己的私钥签名从开始到现在的所有发送过的消息，然后服务端会用客户端的公钥验证这个签名。</p>
<h5 id="Change-Cipher-Spec-消息"><a href="#Change-Cipher-Spec-消息" class="headerlink" title="Change Cipher Spec 消息"></a>Change Cipher Spec 消息</h5><p>通知服务器此消息以后客户端会以之前协商的密钥加密发送数据。</p>
<h5 id="Client-Finished-消息"><a href="#Client-Finished-消息" class="headerlink" title="Client Finished 消息"></a>Client Finished 消息</h5><p>客户端计算生成对称密钥，然后使用该对称密钥加密之前所有收发握手消息的 Hash 值，发送给服务器，服务器将用相同的会话密钥（使用相同方法生成）解密此消息，校验其中的Hash 值。该消息是 SSL 握手协议记录层加密的第一条消息。</p>
<h4 id="服务端最后对客户端响应"><a href="#服务端最后对客户端响应" class="headerlink" title="服务端最后对客户端响应"></a>服务端最后对客户端响应</h4><h5 id="Change-Cipher-Spec-消息-1"><a href="#Change-Cipher-Spec-消息-1" class="headerlink" title="Change Cipher Spec  消息"></a>Change Cipher Spec  消息</h5><p>通知客户端此消息以后服务端将会以之前协商的密钥加密发送数据。</p>
<h5 id="Server-Finished-消息"><a href="#Server-Finished-消息" class="headerlink" title="Server Finished 消息"></a>Server Finished 消息</h5><p>服务器使用对称密钥加密（生成方式与客户端相同）之前所发送的所有握手消息的hash值，发送给客户端去校验。</p>
<p>至此 SSL 握手过程结束，双发之后的通信数据都会用双方协商的对称密钥 Session Key 加密传输。</p>
<p>下图为 SSL/TLS 通信的整个过程：TCP 三次握手 + SSL/TLS 握手：<br><img src="/images/ssl_handshake3.png" alt="Alt text"></p>
<h3 id="Wireshark-抓包分析-SSL-TLS-握手过程"><a href="#Wireshark-抓包分析-SSL-TLS-握手过程" class="headerlink" title="Wireshark 抓包分析 SSL/TLS 握手过程"></a>Wireshark 抓包分析 SSL/TLS 握手过程</h3><p>本节使用 wireshark 抓包工具分析一个完整的 HTTPS 通信过程，看看通信过程中双方消息是如何传送的。前面我们说过，根据服务端实现的不同，可能一个 TCP 包中包含多条 SSL/TLS 消息，而不是每条消息单独发送（每条单独发送效率太低）。</p>
<p>使用如下 wireshark https 包过滤器:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp.<span class="attribute">port</span>==443 <span class="keyword">and</span> (ip.<span class="attribute">dst</span>==104.18.40.252 <span class="keyword">or</span> ip.<span class="attribute">src</span>==104.18.40.252)</span><br></pre></td></tr></table></figure></p>
<p>下面为 Wireshark 抓取的 https 流量包，展示了整个通信过程：建立 TCP 连接 –&gt; SSL/TLS 握手 –&gt; 应用数据加密传输：<br><img src="/images/wireshark_ssl_handshake1.png" alt="Alt text"></p>
<p>上面是一个实际的 SSL/TLS 握手过程，分为如下 5 步：</p>
<ol>
<li>客户端发送 Client Hello 消息给服务端；</li>
<li>服务端回应 Server Hello 消息；</li>
<li>服务端同时回应 Server Certificate、Server Key Exchange 和 Server Hello Done 消息；</li>
<li>客户端发送 Client Key Exchange、Change Cipher Spec 和 Client Finished 消息；</li>
<li>服务端最后发送 Change Cipher Spec 和 Server Finished 消息；</li>
</ol>
<p>下面我们分步分析每个阶段的包的内容，看是否和前面的理论一致。</p>
<h4 id="客户端发送-Client-Hello-消息给服务端"><a href="#客户端发送-Client-Hello-消息给服务端" class="headerlink" title="客户端发送 Client Hello 消息给服务端"></a>客户端发送 Client Hello 消息给服务端</h4><p><img src="/images/wireshark_ssl_handshake2.png" alt="Alt text"></p>
<p>可以看出 TLS 协议确实分为两层：TLS 记录层、TLS 握手层，其中 TLS 握手层基于 TLS 记录层。</p>
<p>另外客户端发送的 Client Hello 消息当中包含的信息也可以看到：</p>
<ul>
<li>Version：客户端支持的 TLS 版本号；</li>
<li>Random：客户端生成的 32 字节随机数；</li>
<li>Session ID：会话 ID；</li>
<li>Cipher Suites：客户端支持的加密套件列表；</li>
<li>Compression Methods：客户端支持的压缩算法；</li>
</ul>
<h4 id="服务端回应-Server-Hello-消息"><a href="#服务端回应-Server-Hello-消息" class="headerlink" title="服务端回应 Server Hello 消息"></a>服务端回应 Server Hello 消息</h4><p><img src="/images/wireshark_ssl_handshake3.png" alt="Alt text"></p>
<p>Server Hello 包含如下信息：</p>
<ul>
<li>Version：双方支持的 TLS 版本号；</li>
<li>Random：服务端生成的 32 字节随机数；</li>
<li>Session ID：会话 ID；</li>
<li>Cipher Suites：双方协商的加密套件；</li>
<li>Compression Methods：压缩算法；</li>
</ul>
<h4 id="服务端同时回应-Server-Certificate、Server-Key-Exchange-和-Server-Hello-Done-消息"><a href="#服务端同时回应-Server-Certificate、Server-Key-Exchange-和-Server-Hello-Done-消息" class="headerlink" title="服务端同时回应 Server Certificate、Server Key Exchange 和 Server Hello Done 消息"></a>服务端同时回应 Server Certificate、Server Key Exchange 和 Server Hello Done 消息</h4><p><img src="/images/wireshark_ssl_handshake4.png" alt="Alt text"></p>
<p>可以看出每个 TLS 记录层是一个消息，服务端同时回复了有 3 个消息：Server Certificate、Server Key Exchange、Server Hello Done。</p>
<p>从 Server Key Exchange 消息可以看出双方密钥协商使用的是 Diffie-Hellman (迪菲) 算法，该消息用于传递 Diffie-Hellman (迪菲) 算法的参数。</p>
<h4 id="客户端发送-Client-Key-Exchange、Change-Cipher-Spec-和-Client-Finished-消息"><a href="#客户端发送-Client-Key-Exchange、Change-Cipher-Spec-和-Client-Finished-消息" class="headerlink" title="客户端发送 Client Key Exchange、Change Cipher Spec 和 Client Finished 消息"></a>客户端发送 Client Key Exchange、Change Cipher Spec 和 Client Finished 消息</h4><p><img src="/images/wireshark_ssl_handshake5.png" alt="Alt text"></p>
<p>可以看出客户端同时回复了 3 个消息：Client Key Exchange、Change Cipher Spec 和 Client Finished 消息。Client Key Exchange 的内容为 Diffie-Hellman (迪菲) 算法的参数，用于生成 premaster key，然后和双方之前的随机数结合生成对称密钥。</p>
<h4 id="服务端最后发送-Change-Cipher-Spec-和-Server-Finished-消息"><a href="#服务端最后发送-Change-Cipher-Spec-和-Server-Finished-消息" class="headerlink" title="服务端最后发送 Change Cipher Spec 和 Server Finished 消息"></a>服务端最后发送 Change Cipher Spec 和 Server Finished 消息</h4><p><img src="/images/wireshark_ssl_handshake6.png" alt="Alt text"></p>
<p> 服务端最后发送 Change Cipher Spec 和 Server Finished 消息，至此 SSL/TLS 握手完毕，接下来双方会用对称加密的方式加密传输数据。</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://segmentfault.com/a/1190000002554673" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002554673</a> | SSL/TLS 原理详解<br><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html</a> | SSL/TLS 协议运行机制概述<br><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html</a> | 图解 SSL/TLS 协议<br><a href="https://www.jianshu.com/p/a3a25c6627ee" target="_blank" rel="noopener">https://www.jianshu.com/p/a3a25c6627ee</a> | Https详解+wireshark抓包演示<br><a href="https://segmentfault.com/a/1190000007283514" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007283514</a> | TLS/SSL 高级进阶<br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc785811(v=ws.10" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc785811(v=ws.10</a>) | 微软 Windows 文档</p>
]]></content>
      
        <categories>
            
            <category> HTTPS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 OpenSSL 生成自签名证书]]></title>
      <url>/2019/05/18/%E5%9F%BA%E4%BA%8E-OpenSSL-%E7%94%9F%E6%88%90%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6/</url>
      <content type="html"><![CDATA[<h3 id="PKI、CA、SSL、TLS、OpenSSL几个概念"><a href="#PKI、CA、SSL、TLS、OpenSSL几个概念" class="headerlink" title="PKI、CA、SSL、TLS、OpenSSL几个概念"></a><p style="color:green;">PKI、CA、SSL、TLS、OpenSSL几个概念</p></h3><h4 id="PKI-和-CA"><a href="#PKI-和-CA" class="headerlink" title=" PKI 和 CA"></a><p style="color:green;"> PKI 和 CA</p></h4><p>PKI 就是 Public Key Infrastructure 的缩写，翻译过来就是公开密钥基础设施。它是利用公开密钥技术所构建的，解决网络安全问题的，普遍适用的一种基础设施。</p>
<p>PKI 是目前唯一的能够基本全面解决安全问题的可能的方案。 PKI 通过电子证书以及管理这些电子证书的一整套设施，维持网络世界的秩序；通过提供一系列的安全服务，为网络电子商务、电子政务提供有力的安全保障。</p>
<p>通俗点说 PKI 就是一整套安全相关标准，然后基于这套标准体系衍生一系列安全相关的产品，主要目的是保证数据在网络上安全、可靠地传输。</p>
<p>PKI 主要由以下组件组成：</p>
<ul>
<li>认证中心 CA(证书签发) ;</li>
<li>X.500目录服务器(证书保存) ;</li>
<li>具有高强度密码算法(SSL)的安全WWW服务器(即配置了 HTTPS 的 apache) ;</li>
<li>Web(安全通信平台): Web 有 Web Client 端和 Web Server 端两部分</li>
<li>自开发安全应用系统 自开发安全应用系统是指各行业自开发的各种具体应用系统，例如银行、证券的应用系统等。</li>
</ul>
<p>CA 是 PKI 的”核心”，即数字证书的申请及签发机关，CA 必须具备权威性的特征，它负责管理 PKI 结构下的所有用户(包括各种应用程序)的证书，把用户的公钥和用户的其他信息捆绑在一起，在网上验证用户的身份，CA 还要负责用户证书的黑名单登记和黑名单发布 。</p>
<p>CA 实现了 PKI 中一些很重要的功能：</p>
<ul>
<li>接收验证最终用户数字证书的申请；</li>
<li>确定是否接受最终用户数字证书的申请-证书的审批；</li>
<li>向申请者颁发、拒绝颁发数字证书-证书的发放；</li>
<li>接收、处理最终用户的数字证书更新请求-证书的更新；</li>
<li>接收最终用户数字证书的查询、撤销；</li>
<li>产生和发布证书废止列表(CRL)；</li>
<li>数字证书的归档；</li>
<li>密钥归档；</li>
<li>历史数据归档；</li>
</ul>
<p>在这么多功能中，CA 的核心功能就是”发放”和”管理”数字证书：<br><img src="/images/ca-arch.png" alt="Alt text"></p>
<h4 id="SSL-和-TLS"><a href="#SSL-和-TLS" class="headerlink" title="SSL 和 TLS"></a><p style="color:green;">SSL 和 TLS</p></h4><p>SSL 和 TLS 协议是介于 HTTP 协议与 TCP 之间的一个可选层，主要用于 Web 客户端和服务器之间进行数据的安全传输：<br><img src="/images/ssl-tls.png" alt="Alt text"></p>
<ul>
<li><strong>SSL:</strong> Secure Socket Layer，安全套接字层），为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层：<br>SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。<br>SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。</li>
<li><strong>TLS:</strong> (Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。<br>TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 RFC 的。该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</li>
</ul>
<p>SSL/TLS协议提供的服务主要有：</p>
<ul>
<li>认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>加密数据以防止数据中途被窃取；</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变；</li>
</ul>
<h4 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a><p style="color:green;">OpenSSL</p></h4><p><img src="/images/openssl.png" alt="Alt text"><br><a href="https://github.com/openssl/openssl" target="_blank" rel="noopener">OpenSSL</a> 是一个开源的加密工具包，主要包括如下三部分：</p>
<ul>
<li><strong>libssl (with platform specific naming)</strong>:<br>   Provides the client and server-side implementations for SSLv3 and TLS.</li>
<li><strong>libcrypto (with platform specific naming)</strong>:<br>   Provides general cryptographic and X.509 support needed by SSL/TLS but<br>   not logically part of it.</li>
<li><strong>openssl</strong>:<br>   A command line tool that can be used for:<pre><code>Creation of key parameters
Creation of X.509 certificates, CSRs and CRLs
Calculation of message digests
Encryption and decryption
SSL/TLS client and server tests
Handling of S/MIME signed or encrypted mail
And more...
</code></pre></li>
</ul>
<h3 id="使用-OpenSSL-生产自签名-SSL-证书过程"><a href="#使用-OpenSSL-生产自签名-SSL-证书过程" class="headerlink" title="使用 OpenSSL 生产自签名 SSL 证书过程"></a><p style="color:green;">使用 OpenSSL 生产自签名 SSL 证书过程</p></h3><p><img src="/images/gen-certificate.png" alt="Alt text"></p>
<p>以下为 Centos7 环境下生成自签名 SSL 证书的具体过程：</p>
<ol>
<li><p>修改 openssl 配置文件</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/pki/tls/openssl.cnf</span><br><span class="line"><span class="comment"># match 表示后续生成的子证书的对应项必须和创建根证书时填的值一样，否则报错。以下配置只规定子证书的 countryName 必须和根证书一致。</span></span><br><span class="line">[ policy_match ] 段配置改成如下：</span><br><span class="line">countryName             = match</span><br><span class="line">stateOrProvinceName     = optional</span><br><span class="line">organizationName        = optional</span><br><span class="line">organizationalUnitName  = optional</span><br><span class="line">commonName              = supplied</span><br><span class="line">emailAddress            = optional</span><br></pre></td></tr></table></figure>
</li>
<li><p>在服务器 pki 的 CA 目录下新建两个文件</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/etc/pki/CA</span> &amp;&amp; touch index.txt serial &amp;&amp; <span class="keyword">echo</span> 01 &gt; serial</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成 CA 根证书密钥</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/etc/</span>pki<span class="regexp">/CA/</span> &amp;&amp; openssl genrsa -out <span class="keyword">private</span><span class="regexp">/cakey.pem 2048 &amp;&amp; chmod 400 private/</span>cakey.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成根证书（根据提示输入信息，除了 Country Name 选项需要记住的，后面的随便填）</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -<span class="keyword">new</span> -x509 -key <span class="keyword">private</span>/cakey.pem -<span class="keyword">out</span> cacert.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成密钥文件</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out nginx.<span class="type">key</span> <span class="number">2048</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>生成证书请求文件（CSR）:<br>A. 根据提示输入信息，除了 Country Name 与前面根证书一致外，其他随便填写<br>B. Common Name 填写要保护的域名，比如：*.qhh.me</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -<span class="keyword">new</span> -<span class="built_in">key</span> nginx.<span class="built_in">key</span> -out nginx.csr</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 openssl 签署 CSR 请求，生成证书</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -<span class="keyword">in</span> nginx.csr -cert <span class="regexp">/etc/</span>pki<span class="regexp">/CA/</span>cacert.pem -keyfile <span class="regexp">/etc/</span>pki<span class="regexp">/CA/</span><span class="keyword">private</span>/cakey.pem -days <span class="number">365</span> -out nginx.crt</span><br><span class="line"></span><br><span class="line">参数项说明：</span><br><span class="line">-<span class="string">in:</span> CSR 请求文件</span><br><span class="line">-<span class="string">cert:</span> 用于签发的根 CA 证书</span><br><span class="line">-<span class="string">keyfile:</span> 根 CA 的私钥文件</span><br><span class="line">-<span class="string">days:</span> 生成的证书的有效天数</span><br><span class="line">-<span class="string">out:</span> 生成证书的文件名</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>至此自签名证书生成完成，最终需要：nginx.key 和 nginx.crt</p>
<h3 id="配置-Nginx-使用自签名证书"><a href="#配置-Nginx-使用自签名证书" class="headerlink" title="配置 Nginx 使用自签名证书"></a><p style="color:green;">配置 Nginx 使用自签名证书</p></h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>     domain;</span><br><span class="line">        <span class="attribute">return</span>  <span class="number">301</span>     https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>  <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">ssl_certificate</span>       ssl/nginx.crt; <span class="comment"># 前面生成的 crt 证书文件</span></span><br><span class="line">        <span class="attribute">ssl_certificate_key</span>   ssl/nginx.key; <span class="comment"># 前面生成的证书私钥</span></span><br><span class="line">        <span class="attribute">server_name</span>     domain;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /var/www-html;</span><br><span class="line">            <span class="attribute">index</span>  index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a><p style="color:green;">相关资料</p></h3><p><a href="http://seanlook.com/2015/01/18/openssl-self-sign-ca/" target="_blank" rel="noopener">http://seanlook.com/2015/01/18/openssl-self-sign-ca/</a> | 基于 OpenSSL 自签署证书<br><a href="http://www.cnblogs.com/littlehann/p/3738141.html" target="_blank" rel="noopener">http://www.cnblogs.com/littlehann/p/3738141.html</a> | openSSL命令、PKI、CA、SSL证书原理<br><a href="https://cnzhx.net/blog/ssl-on-lamp-on-vps/" target="_blank" rel="noopener">https://cnzhx.net/blog/ssl-on-lamp-on-vps/</a><br><a href="http://seanlook.com/2015/01/15/openssl-certificate-encryption/" target="_blank" rel="noopener">http://seanlook.com/2015/01/15/openssl-certificate-encryption/</a> | OpenSSL 与 SSL 数字证书概念贴<br><a href="https://kb.cnblogs.com/page/194742/" target="_blank" rel="noopener">https://kb.cnblogs.com/page/194742/</a> | 数字证书及 CA 的扫盲<br><a href="http://netsecurity.51cto.com/art/200602/21066.htm" target="_blank" rel="noopener">http://netsecurity.51cto.com/art/200602/21066.htm</a> | PKI/CA 技术的介绍<br><a href="http://cnzhx.net/blog/self-signed-certificate-as-trusted-root-ca-in-windows/" target="_blank" rel="noopener">http://cnzhx.net/blog/self-signed-certificate-as-trusted-root-ca-in-windows/</a> | 浏览器添加自签名证书<br><a href="https://aotu.io/notes/2016/08/16/nginx-https/index.html" target="_blank" rel="noopener">https://aotu.io/notes/2016/08/16/nginx-https/index.html</a> | Nginx 配置 HTTPS 服务器</p>
]]></content>
      
        <categories>
            
            <category> HTTPS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> HTTPS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tcpdump使用技巧]]></title>
      <url>/2019/05/07/tcpdump%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<hr>
<p><a href="https://www.tcpdump.org/" target="_blank" rel="noopener">tcpdump</a> 是一个开源的命令行网络封包分析工具，一般用于服务器端网络流量、协议分析。今天有幸看到了有人很好地总结了关于 tcpdump 的使用技巧，在此转载下。<br><u>本文转载自这里：</u><br><u><a href="https://github.com/linuxwiki/SourceWiki/blob/master/%E7%BD%91%E7%BB%9C/tcpdump.md" target="_blank" rel="noopener">https://github.com/linuxwiki/SourceWiki/blob/master/%E7%BD%91%E7%BB%9C/tcpdump.md</a></u></p>
<hr>
<p>作者: 潜水大叔</p>
<p>一般情况下，非HTTP协议的网络分析，在服务器端用<code>tcpdump</code>比较多，在客户端用wireshark比较多，两个抓包软件的语法是一样的。</p>
<h2 id="一、基本语法"><a href="#一、基本语法" class="headerlink" title="一、基本语法"></a>一、基本语法</h2><h3 id="1-1、过滤主机"><a href="#1-1、过滤主机" class="headerlink" title="1.1、过滤主机"></a>1.1、过滤主机</h3><ul>
<li>抓取所有经过eth1，目的或源地址是192.168.1.1的网络数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 host 192.168.1.1</span><br></pre></td></tr></table></figure>
<ul>
<li>指定源地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 src host 192.168.1.1</span><br></pre></td></tr></table></figure>
<ul>
<li>指定目的地址</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 dst host 192.168.1.1</span><br></pre></td></tr></table></figure>
<h3 id="1-2、过滤端口"><a href="#1-2、过滤端口" class="headerlink" title="1.2、过滤端口"></a>1.2、过滤端口</h3><ul>
<li>抓取所有经过eth1，目的或源端口是25的网络数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 port 25</span><br></pre></td></tr></table></figure>
<ul>
<li>指定源端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 src port 25</span><br></pre></td></tr></table></figure>
<ul>
<li>指定目的端口</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 dst port 25</span><br></pre></td></tr></table></figure>
<h3 id="1-3、网络过滤"><a href="#1-3、网络过滤" class="headerlink" title="1.3、网络过滤"></a>1.3、网络过滤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 net 192.168</span><br><span class="line">tcpdump -i eth1 src net 192.168</span><br><span class="line">tcpdump -i eth1 dst net 192.168</span><br></pre></td></tr></table></figure>
<h3 id="1-4、协议过滤"><a href="#1-4、协议过滤" class="headerlink" title="1.4、协议过滤"></a>1.4、协议过滤</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 arp</span><br><span class="line">tcpdump -i eth1 ip</span><br><span class="line">tcpdump -i eth1 tcp</span><br><span class="line">tcpdump -i eth1 udp</span><br><span class="line">tcpdump -i eth1 icmp</span><br></pre></td></tr></table></figure>
<h3 id="1-5、常用表达式"><a href="#1-5、常用表达式" class="headerlink" title="1.5、常用表达式"></a>1.5、常用表达式</h3><pre><code>非 : ! or &quot;not&quot; (去掉双引号)  
且 : &amp;&amp; or &quot;and&quot;  
或 : || or &quot;or&quot;  
</code></pre><ul>
<li>抓取所有经过eth1，目的地址是192.168.1.254或192.168.1.200端口是80的TCP数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓取所有经过eth1，目标MAC地址是00:01:02:03:04:05的ICMP数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'((icmp) and ((ether dst host 00:01:02:03:04:05)))'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓取所有经过eth1，目的网络是192.168，但目的主机不是192.168.1.200的TCP数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'((tcp) and ((dst net 192.168) and (not dst host 192.168.1.200)))'</span></span><br></pre></td></tr></table></figure>
<h2 id="二、高级包头过滤"><a href="#二、高级包头过滤" class="headerlink" title="二、高级包头过滤"></a>二、高级包头过滤</h2><p>首先了解如何从包头过滤信息</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proto[<span class="string">x:</span>y]          : 过滤从x字节开始的y字节数。比如ip[<span class="number">2</span>:<span class="number">2</span>]过滤出<span class="number">3</span>、<span class="number">4</span>字节（第一字节从<span class="number">0</span>开始排）</span><br><span class="line">proto[<span class="string">x:</span>y] &amp; z = <span class="number">0</span>  : proto[<span class="string">x:</span>y]和z的与操作为<span class="number">0</span></span><br><span class="line">proto[<span class="string">x:</span>y] &amp; z !=<span class="number">0</span>  : proto[<span class="string">x:</span>y]和z的与操作不为<span class="number">0</span></span><br><span class="line">proto[<span class="string">x:</span>y] &amp; z = <span class="string">z  :</span> proto[<span class="string">x:</span>y]和z的与操作为z</span><br><span class="line">proto[<span class="string">x:</span>y] = <span class="string">z      :</span> proto[<span class="string">x:</span>y]等于z</span><br></pre></td></tr></table></figure>
<p>操作符 : &gt;, &lt;, &gt;=, &lt;=, =, !=</p>
<h3 id="2-1、IP头"><a href="#2-1、IP头" class="headerlink" title="2.1、IP头"></a>2.1、IP头</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|Version|  IHL  |Type of Service|          Total Length         |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|         Identification        |Flags|      Fragment Offset    |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|  Time to Live |    Protocol   |         Header Checksum       |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                       Source Address                          |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                    Destination Address                        |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                    Options                    |    Padding    | &lt;-- optional</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                            DATA ...                           |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br></pre></td></tr></table></figure>
<p>本文只针对IPv4。</p>
<h3 id="2-2、IP选项设置了吗？"><a href="#2-2、IP选项设置了吗？" class="headerlink" title="2.2、IP选项设置了吗？"></a>2.2、IP选项设置了吗？</h3><p>“一般”的IP头是20字节，但IP头有选项设置，不能直接从偏移21字节处读取数据。IP头有个长度字段可以知道头长度是否大于20字节。</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|Version|  IHL  |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br></pre></td></tr></table></figure>
<p>通常第一个字节的二进制值是：01000101，分成两个部分：</p>
<p>0100 = 4 表示IP版本<br>0101 = 5 表示IP头32 bit的块数，5 x 32 bits = 160 bits or 20 bytes</p>
<p>如果第一字节第二部分的值大于5，那么表示头有IP选项。</p>
<p>下面介绍两种过滤方法（第一种方法比较操蛋，可忽略）：</p>
<p>a. 比较第一字节的值是否大于01000101，这可以判断IPv4带IP选项的数据和IPv6的数据。</p>
<p>01000101十进制等于69，计算方法如下（小提示：用计算器更方便）</p>
<figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">0 </span>: 0  \</span><br><span class="line"><span class="attribute">1 </span>: 2^6 = 64 \ 第一部分 (IP版本)</span><br><span class="line"><span class="attribute">0 </span>: 0   /</span><br><span class="line"><span class="attribute">0 </span>: 0  /</span><br><span class="line"><span class="literal">-</span></span><br><span class="line"><span class="attribute">0 </span>: 0  \</span><br><span class="line"><span class="attribute">1 </span>: 2^2 = 4  \ 第二部分 (头长度)</span><br><span class="line"><span class="attribute">0 </span>: 0   /</span><br><span class="line"><span class="attribute">1 </span>: 2^0 = 1 /</span><br></pre></td></tr></table></figure>
<p>64 + 4 + 1 = 69</p>
<p>如果设置了IP选项，那么第一自己是01000110（十进制70），过滤规则：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'ip[0] &gt; 69'</span></span><br></pre></td></tr></table></figure></p>
<p>IPv6的数据也会匹配，看看第二种方法。</p>
<p>b. 位操作</p>
<p>0100 0101 : 第一字节的二进制<br>0000 1111 : 与操作<br>&lt;=========<br>0000 0101 : 结果  </p>
<p>正确的过滤方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'ip[0] &amp; 15 &gt; 5'</span></span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'ip[0] &amp; 0x0f &gt; 5'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-3、分片标记"><a href="#2-3、分片标记" class="headerlink" title="2.3、分片标记"></a>2.3、分片标记</h3><p>当发送端的MTU大于到目的路径链路上的MTU时就会被分片，这段话有点拗口，权威的请参考《TCP/IP详解》。唉，32借我的书没还，只能凑合写，大家记得看书啊。</p>
<p>分片信息在IP头的第七和第八字节：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|Flags|      Fragment Offset    |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br></pre></td></tr></table></figure>
<p>Bit 0:  保留，必须是0<br>Bit 1:  (DF) 0 = 可能分片, 1 = 不分片<br>Bit 2:  (MF) 0 = 最后的分片, 1 = 还有分片  </p>
<p>Fragment Offset字段只有在分片的时候才使用。</p>
<p>要抓带DF位标记的不分片的包，第七字节的值应该是：</p>
<p>01000000 = 64</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'ip[6] = 64'</span></span><br></pre></td></tr></table></figure>
<h3 id="2-4、抓分片包"><a href="#2-4、抓分片包" class="headerlink" title="2.4、抓分片包"></a>2.4、抓分片包</h3><ul>
<li>匹配MF，分片包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'ip[6] = 32'</span></span><br></pre></td></tr></table></figure>
<p>最后分片包的开始3位是0，但是有Fragment Offset字段。</p>
<ul>
<li>匹配分片和最后分片</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'((ip[6:2] &gt; 0) and (not ip[6] = 64))'</span></span><br></pre></td></tr></table></figure>
<p>测试分片可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -M want -s 3000 192.168.1.1</span><br></pre></td></tr></table></figure>
<h3 id="2-5、匹配小TTL"><a href="#2-5、匹配小TTL" class="headerlink" title="2.5、匹配小TTL"></a>2.5、匹配小TTL</h3><p>TTL字段在第九字节，并且正好是完整的一个字节，TTL最大值是255，二进制为11111111。</p>
<p>可以用下面的命令验证一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ping -M want -s 3000 -t 256 192.168.1.200</span><br><span class="line">ping: ttl 256 out of range</span><br></pre></td></tr></table></figure>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|  Time to Live |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br></pre></td></tr></table></figure>
<ul>
<li>在网关可以用下面的命令看看网络中谁在使用traceroute</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'ip[8] &lt; 5'</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6、抓大于X字节的包"><a href="#2-6、抓大于X字节的包" class="headerlink" title="2.6、抓大于X字节的包"></a>2.6、抓大于X字节的包</h3><ul>
<li>大于600字节</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'ip[2:2] &gt; 600'</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7、更多的IP过滤"><a href="#2-7、更多的IP过滤" class="headerlink" title="2.7、更多的IP过滤"></a>2.7、更多的IP过滤</h3><p>首先还是需要知道TCP基本结构，再次推荐《TCP/IP详解》，卷一就够看的了，避免走火入魔。</p>
<ul>
<li>TCP头</li>
</ul>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0                   1                   2                   3</span><br><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|          Source Port          |       Destination Port        |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                        Sequence Number                        |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                    Acknowledgment Number                      |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|  Data |       |C|E|U|A|P|R|S|F|                               |</span><br><span class="line">| Offset|  Res. |W|C|R|C|S|S|Y|I|            Window             |</span><br><span class="line">|       |       |R|E|G|K|H|T|N|N|                               |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|           Checksum            |         Urgent Pointer        |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                    Options                    |    Padding    |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br><span class="line">|                             data                              |</span><br><span class="line"><span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-<span class="code">+-+</span>-+</span><br></pre></td></tr></table></figure>
<ul>
<li>抓取源端口大于1024的TCP数据包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[0:2] &gt; 1024'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>匹配TCP数据包的特殊标记</li>
</ul>
<p>TCP标记定义在TCP头的第十四个字节</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+</span><br><span class="line">|<span class="string">C</span>|<span class="string">E</span>|<span class="string">U</span>|<span class="string">A</span>|<span class="string">P</span>|<span class="string">R</span>|<span class="string">S</span>|<span class="string">F</span>|</span><br><span class="line">|<span class="string">W</span>|<span class="string">C</span>|<span class="string">R</span>|<span class="string">C</span>|<span class="string">S</span>|<span class="string">S</span>|<span class="string">Y</span>|<span class="string">I</span>|</span><br><span class="line">|<span class="string">R</span>|<span class="string">E</span>|<span class="string">G</span>|<span class="string">K</span>|<span class="string">H</span>|<span class="string">T</span>|<span class="string">N</span>|<span class="string">N</span>|</span><br><span class="line">+-+-+-+-+-+-+-+-+</span><br></pre></td></tr></table></figure>
<p>重复一下TCP三次握手，两个主机是如何勾搭的：</p>
<ol>
<li>源发送SYN</li>
<li>目标回答SYN, ACK</li>
<li>源发送ACK</li>
</ol>
<p>没女朋友的童鞋要学习一下：  </p>
<ol>
<li>MM，你的手有空吗？-_-  </li>
<li>有空，你呢？~_~  </li>
<li>我也有空 *_*  </li>
</ol>
<p>失败的loser是酱紫的：  </p>
<ol>
<li>MM，这是你掉的板砖吗？(SYN) ￣▽￣  </li>
<li>不是，找拍啊？(RST-ACK) ˋ﹏ˊ  </li>
</ol>
<ul>
<li>只抓SYN包，第十四字节是二进制的00000010，也就是十进制的2</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[13] = 2'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓SYN, ACK （00010010 or 18）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[13] = 18'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓SYN或者SYN-ACK</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[13] &amp; 2 = 2'</span></span><br></pre></td></tr></table></figure>
<p>用到了位操作，就是不管ACK位是啥。</p>
<ul>
<li>抓PSH-ACK</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[13] = 24'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓所有包含FIN标记的包（FIN通常和ACK一起，表示幽会完了，回见）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[13] &amp; 1 = 1'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓RST（勾搭没成功，伟大的greatwall对她认为有敏感信息的连接发RST包，典型的棒打鸳鸯）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[13] &amp; 4 = 4'</span></span><br></pre></td></tr></table></figure>
<p>下图详细描述了TCP各种状态的标记，方便分析。</p>
<p><img src="/images/tcp_state_machine.jpg" alt="tcp_state_machine.jpg"></p>
<h3 id="2-8、大叔注"><a href="#2-8、大叔注" class="headerlink" title="2.8、大叔注"></a>2.8、大叔注</h3><p>tcpdump考虑了一些数字恐惧症者的需求，提供了部分常用的字段偏移名字：</p>
<p>icmptype  (ICMP类型字段)<br>icmpcode  (ICMP符号字段)<br>tcpflags  (TCP标记字段)  </p>
<p>ICMP类型值有：</p>
<p>icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect, icmp-echo, icmp-routeradvert, icmp-routersolicit, icmp-timxceed, icmp-paramprob, icmp-tstamp, icmp-tstampreply, icmp-ireq, icmp-ireqreply, icmp-maskreq, icmp-maskreply</p>
<p>TCP标记值：</p>
<p>tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-push, tcp-ack, tcp-urg</p>
<p>这样上面按照TCP标记位抓包的就可以写直观的表达式了：</p>
<ul>
<li>只抓SYN包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[tcpflags] = tcp-syn'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓SYN, ACK</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[tcpflags] &amp; tcp-syn != 0 and tcp[tcpflags] &amp; tcp-ack != 0'</span></span><br></pre></td></tr></table></figure>
<h3 id="2-9、抓SMTP数据"><a href="#2-9、抓SMTP数据" class="headerlink" title="2.9、抓SMTP数据"></a>2.9、抓SMTP数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'((port 25) and (tcp[(tcp[12]&gt;&gt;2):4] = 0x4d41494c))'</span></span><br></pre></td></tr></table></figure>
<p>抓取数据区开始为”MAIL”的包，”MAIL”的十六进制为0x4d41494c。</p>
<h3 id="2-10、抓HTTP-GET数据"><a href="#2-10、抓HTTP-GET数据" class="headerlink" title="2.10、抓HTTP GET数据"></a>2.10、抓HTTP GET数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[(tcp[12]&gt;&gt;2):4] = 0x47455420'</span></span><br></pre></td></tr></table></figure>
<p>“GET “的十六进制是47455420</p>
<h3 id="2-11、抓SSH返回"><a href="#2-11、抓SSH返回" class="headerlink" title="2.11、抓SSH返回"></a>2.11、抓SSH返回</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'tcp[(tcp[12]&gt;&gt;2):4] = 0x5353482D'</span></span><br></pre></td></tr></table></figure>
<p>“SSH-“的十六进制是0x5353482D</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 <span class="string">'(tcp[(tcp[12]&gt;&gt;2):4] = 0x5353482D) and (tcp[((tcp[12]&gt;&gt;2)+4):2] = 0x312E)'</span></span><br></pre></td></tr></table></figure>
<p>抓老版本的SSH返回信息，如”SSH-1.99..”</p>
<h2 id="三、大叔注"><a href="#三、大叔注" class="headerlink" title="三、大叔注"></a>三、大叔注</h2><p>如果是为了查看数据内容，建议用<code>tcpdump -s 0 -w filename</code>把数据包都保存下来，然后用wireshark的Follow TCP Stream/Follow UDP Stream来查看整个会话的内容。</p>
<p><code>-s 0</code>是抓取完整数据包，否则默认只抓68字节。</p>
<p>另外，用tcpflow也可以方便的获取TCP会话内容，支持tcpdump的各种表达式。</p>
<h3 id="3-1、UDP头"><a href="#3-1、UDP头" class="headerlink" title="3.1、UDP头"></a>3.1、UDP头</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="code"> 0      7 8     15 16    23 24    31</span></span><br><span class="line"><span class="code">+--------+</span>--------<span class="code">+--------+</span>--------+</span><br><span class="line">|     Source      |   Destination   |</span><br><span class="line">|      Port       |      Port       |</span><br><span class="line"><span class="code">+--------+</span>--------<span class="code">+--------+</span>--------+</span><br><span class="line">|                 |                 |</span><br><span class="line">|     Length      |    Checksum     |</span><br><span class="line"><span class="code">+--------+</span>--------<span class="code">+--------+</span>--------+</span><br><span class="line">|                                   |</span><br><span class="line">|              DATA ...             |</span><br><span class="line"><span class="code">+-----------------------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抓DNS请求数据</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth1 udp dst port 53</span><br></pre></td></tr></table></figure>
<h3 id="3-2、其他"><a href="#3-2、其他" class="headerlink" title="3.2、其他"></a>3.2、其他</h3><p><code>-c</code>参数对于运维人员来说也比较常用，因为流量比较大的服务器，靠人工CTRL+C还是抓的太多，甚至导致服务器宕机，于是可以用<code>-c</code>参数指定抓多少个包。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time tcpdump -nn -i eth0 <span class="string">'tcp[tcpflags] = tcp-syn'</span> -c 10000 &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>上面的命令计算抓10000个SYN包花费多少时间，可以判断访问量大概是多少。</p>
<h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><blockquote>
<p><a href="http://www.wains.be/pub/networking/tcpdump_advanced_filters.txt" target="_blank" rel="noopener">tcpdump advanced filters</a></p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tcpdump </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Amazon CloudFront CDN + s3 源站跨域配置]]></title>
      <url>/2019/05/06/Amazon-CloudFront-CDN-s3-%E6%BA%90%E7%AB%99%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用 Amazon CloudFront CDN + s3 源站托管前端静态页面，前端跨域请求时报错：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">...</span>blocked <span class="keyword">by</span> CORS policy: No <span class="string">'Access-Control-Allow-Origin'</span> <span class="keyword">header</span> is present <span class="keyword">on</span> the requested resource.</span><br></pre></td></tr></table></figure></p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>配置 Amazon CloudFront CDN 和 s3 支持跨域请求</p>
<h4 id="1-s3-存储桶添加-CORS-配置"><a href="#1-s3-存储桶添加-CORS-配置" class="headerlink" title="1. s3 存储桶添加 CORS 配置"></a>1. s3 存储桶添加 CORS 配置</h4><p>存储桶—&gt;权限—&gt;CORS配置，添加类似下面 xml 格式的 CORS 配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line">   <span class="tag">&lt;<span class="name">CORSConfiguration</span> <span class="attr">xmlns</span>=<span class="string">"http://s3.amazonaws.com/doc/2006-03-01/"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">CORSRule</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">AllowedOrigin</span>&gt;</span>*<span class="tag">&lt;/<span class="name">AllowedOrigin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">AllowedMethod</span>&gt;</span>HEAD<span class="tag">&lt;/<span class="name">AllowedMethod</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">AllowedMethod</span>&gt;</span>PUT<span class="tag">&lt;/<span class="name">AllowedMethod</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">AllowedMethod</span>&gt;</span>GET<span class="tag">&lt;/<span class="name">AllowedMethod</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">MaxAgeSeconds</span>&gt;</span>3000<span class="tag">&lt;/<span class="name">MaxAgeSeconds</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">ExposeHeader</span>&gt;</span>x-amz-server-side-encryption<span class="tag">&lt;/<span class="name">ExposeHeader</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">ExposeHeader</span>&gt;</span>x-amz-request-id<span class="tag">&lt;/<span class="name">ExposeHeader</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">ExposeHeader</span>&gt;</span>x-amz-id-2<span class="tag">&lt;/<span class="name">ExposeHeader</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">AllowedHeader</span>&gt;</span>*<span class="tag">&lt;/<span class="name">AllowedHeader</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">CORSRule</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">CORSConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p> s3 CORS 相关配置项说明：</p>
<ul>
<li><code>&lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt;</code>: 允许访问来源，* 表示允许所有来源访问，具体根据实际情况配置；</li>
<li><code>&lt;AllowedMethod&gt;HEAD&lt;/AllowedMethod&gt;</code>: 允许的请求方法：GET、PUT、POST、DELETE、HEAD，不包含 OPTIONS 请求；</li>
<li><code>&lt;MaxAgeSeconds&gt;3000&lt;/MaxAgeSeconds&gt;</code>: 指定在 Amazon S3 针对特定资源的预检 OPTIONS 请求做出响应后，浏览器缓存该响应的时间（以秒为单位，在本示例中为 3000 秒）。通过缓存响应，在需要重复原始请求时，浏览器无需向 Amazon S3 发送预检请求。</li>
<li>其他配置项解释见这里：<a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/cors.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/cors.html</a></li>
</ul>
<p>使用 curl 测试存储桶 CORS 配置是否正确：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I -v -L -H <span class="comment">'origin: <span class="doctag">&lt;跨域请求的来源域名&gt;</span>' <span class="doctag">&lt;s3资源地址&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果响应头中有如下请求头，则表示配置正确：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Allow-Origin: &lt;curl 请求时 -H 参数指定的值&gt;</span><br><span class="line"><span class="keyword">Access</span>-Control-Allow-Methods: &lt;s3 存储桶 CORS 配置指定的请求方法&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-CloudFront-分发行为中配置正确的”白名单标头”"><a href="#2-CloudFront-分发行为中配置正确的”白名单标头”" class="headerlink" title="2. CloudFront 分发行为中配置正确的”白名单标头”:"></a>2. CloudFront 分发行为中配置正确的”白名单标头”:</h4><p>打开 Amazon CloudFront 控制台—&gt;点击要配置的分发—&gt;选中”行为”列—&gt;选中某条行为配置行，点击”编辑”—&gt;”白名单标头”添加如下标头（CORS 相关配置，必须得添加，否则跨域请求时会出问题）：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Request-Headers</span><br><span class="line">Access-Control-Request-<span class="function"><span class="keyword">Method</span></span></span><br><span class="line"><span class="function"><span class="title">CloudFront</span>-<span class="title">Forwarded</span>-<span class="title">Proto</span></span></span><br><span class="line"><span class="function"><span class="title">Origin</span></span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-CloudFront-缓存行为允许-OPTIONS-请求："><a href="#3-CloudFront-缓存行为允许-OPTIONS-请求：" class="headerlink" title="3. CloudFront 缓存行为允许 OPTIONS 请求："></a>3. CloudFront 缓存行为允许 OPTIONS 请求：</h4><p>打开 Amazon CloudFront 控制台—&gt;点击要配置的分发—&gt;选中”行为”列—&gt;选中某条行为配置行，点击”编辑”—&gt;”缓存的 HTTP 方法” 下面勾选 OPTIONS 复选框</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p>   <a href="https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/cors.html" target="_blank" rel="noopener">https://docs.aws.amazon.com/zh_cn/AmazonS3/latest/dev/cors.html</a><br>   <a href="https://aws.amazon.com/cn/premiumsupport/knowledge-center/no-access-control-allow-origin-error/?nc1=h_ls" target="_blank" rel="noopener">https://aws.amazon.com/cn/premiumsupport/knowledge-center/no-access-control-allow-origin-error/?nc1=h_ls</a></p>
]]></content>
      
        <categories>
            
            <category> Aws </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Aws </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[计算机网络协议学习总结]]></title>
      <url>/2019/05/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h3 id="计算机网络协议分层"><a href="#计算机网络协议分层" class="headerlink" title="计算机网络协议分层"></a>计算机网络协议分层</h3><p>目前关于网络通信的标准有两套协议，分别是 OSI 参考模型和 TCP/IP 模型。OSI 参考模型只用于理论研究，而 TCP/IP 模型更注重于实际应用，他们的关系如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      +-------------------------+             +----------------------+</span><br><span class="line">      |<span class="string">                         </span>|<span class="string">             </span>|<span class="string">                      </span>|</span><br><span class="line">      |<span class="string">         OSI Model       </span>|<span class="string">             </span>|<span class="string">    TCP/IP Model      </span>|</span><br><span class="line">      |<span class="string">                         </span>|<span class="string">             </span>|<span class="string">                      </span>|</span><br><span class="line">      +-------------------------+             +----------------------+</span><br><span class="line">      |<span class="string">    Application Layer    </span>|<span class="string">             </span>|<span class="string">                      </span>|</span><br><span class="line">      +-------------------------+             |<span class="string">                      </span>|</span><br><span class="line">      |<span class="string">    Presentation Layer   </span>|<span class="string">             </span>|<span class="string">  Application Layer   </span>|</span><br><span class="line">      +-------------------------+             |<span class="string">                      </span>|</span><br><span class="line">      |<span class="string">    Session Layer        </span>|<span class="string">             </span>|<span class="string">                      </span>|</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">      |<span class="string">    Transport Layer      </span>|<span class="string">             </span>|<span class="string">  Transport Layer     </span>|</span><br><span class="line">      +-------------------------+             +----------------------+</span><br><span class="line">      |<span class="string">    Network Layer        </span>|<span class="string">             </span>|<span class="string">  Internet Layer      </span>|</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">      |<span class="string">    Data Link Layer      </span>|<span class="string">             </span>|<span class="string">                      </span>|</span><br><span class="line">      +-------------------------+             |<span class="string"> Network Access Layer </span>|</span><br><span class="line">      |<span class="string">    Physical Layer       </span>|<span class="string">             </span>|<span class="string">                      </span>|</span><br><span class="line">      +-------------------------+             +----------------------+</span><br></pre></td></tr></table></figure></p>
<h3 id="TCP-IP-模型各层常见协议"><a href="#TCP-IP-模型各层常见协议" class="headerlink" title="TCP/IP 模型各层常见协议"></a>TCP/IP 模型各层常见协议</h3><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">                          +--------+  +--------+  +-----------+   +--------+                      |</span><br><span class="line"><span class="string">    Application Layer     </span>|<span class="string">  ping  </span>|<span class="string">  </span>|<span class="string"> telnet </span>|<span class="string">  </span>|<span class="string">   OSPF    </span>|<span class="string">   </span>|<span class="string">  DNS   </span>|<span class="string">       User Space     </span>|</span><br><span class="line">                          +---+----+  +----+---+  +----+------+   +---+----+                      |</span><br><span class="line"><span class="string">                              </span>|<span class="string">            </span>|<span class="string">           </span>|<span class="string">              </span>|<span class="string">                           </span>|</span><br><span class="line">--------------------------------------------------------------------------------------socket------------</span><br><span class="line">                              |<span class="string">            </span>|<span class="string">           </span>|<span class="string">              </span>|<span class="string">                           </span>|</span><br><span class="line">                              |<span class="string">       +----+---+       </span>|<span class="string">          +---+----+                      </span>|</span><br><span class="line">    Transport Layer           |<span class="string">       </span>|<span class="string">   TCP  </span>|<span class="string">       </span>|<span class="string">          </span>|<span class="string">  UDP   </span>|<span class="string">                      </span>|</span><br><span class="line">                              |<span class="string">       +--------+----+  </span>|<span class="string">  +-------+--------+                      </span>|</span><br><span class="line">                              |<span class="string">                     </span>|<span class="string">  </span>|<span class="string">  </span>|<span class="string">                                       </span>|</span><br><span class="line">----------------------------------------------------------------------------------                |</span><br><span class="line"><span class="string">                              </span>|<span class="string">                     </span>|<span class="string">  </span>|<span class="string">  </span>|<span class="string">                                       </span>|</span><br><span class="line">                          +---+----+             +--+--+--+-+                                     |</span><br><span class="line"><span class="string">    Internet Layer        </span>|<span class="string">  ICMP  +-------------+    IP    </span>|<span class="string">                       Kernel Space  </span>|</span><br><span class="line">                          +--------+             +-----+----+                                     |</span><br><span class="line"><span class="string">                                                       </span>|<span class="string">                                          </span>|</span><br><span class="line">----------------------------------------------------------------------------------                |</span><br><span class="line"><span class="string">                                                       </span>|<span class="string">                                          </span>|</span><br><span class="line">                           +--------+            +-----+----+      +-------+                      |</span><br><span class="line"><span class="string">    Network Access Layer   </span>|<span class="string">  ARP   +------------+ DataLink +------+ RARP  </span>|<span class="string">                      </span>|</span><br><span class="line">                           +--------+            +-----+----+      +-------+                      |</span><br><span class="line"><span class="string">                                                       </span>|<span class="string">                                          v</span></span><br><span class="line"><span class="string">-------------------------------------------------------+--------------------------  Physical media</span></span><br></pre></td></tr></table></figure>
<h3 id="TCP-IP-数据包的封装与解封"><a href="#TCP-IP-数据包的封装与解封" class="headerlink" title="TCP/IP 数据包的封装与解封"></a>TCP/IP 数据包的封装与解封</h3><p>在 TCP/IP 网络中，通信双方的交互过程就是对协议的封装与解封装的过程，发送方数据处理的方式是从高层到底层，逐层进行数据封装。接收方数据处理的方式是从底层到高层，逐层进行数据解封装。接收方的每一层只把对该层有意义的数据拿走，或者说每一层只能处理发送方同等层的数据，然后把其余的部分传递给上一层，这就是对等层通信的概念。</p>
<p>数据封装（Data Encapsulation）是指将协议数据单元（PDU）封装在一组协议头和尾中的过程。该过程是在协议数据单元（PDU）中实现的，其中每层的 PDU 一般由本层的协议头、协议尾和数据封装构成。</p>
<p>数据解封装是指对端的同等层对数据包解析的过程，通过解拆获取需要的数据，然后将数据传递到上层处理。</p>
<p>不同的协议层对数据包有不同的称谓：</p>
<ul>
<li>TCP 传给 IP 的数据单元称作 TCP 报文段或简称为 TCP 段（TCP segment）；</li>
<li>UDP 数据与 TCP 数据基本一致，唯一的不同是 UDP 传给 IP 的信息单元称作 UDP 数据报（UDP datagram），而且 UDP 的首部长为 8 字节；</li>
<li>IP 传给网络接口层的数据单元称作 IP 数据报(IP datagram)；</li>
<li>在数据链路层传输的数据单元称作帧(Frame )；</li>
</ul>
<p>下面为应用层数据进入 TCP/IP 协议栈时的封装过程（解封装的过程与该过程相反）：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">                                    +-----------------+</span><br><span class="line">                                    |<span class="string"> Application data</span>|</span><br><span class="line">                                    +-----------------+</span><br><span class="line">                                    |<span class="string">                 </span>|</span><br><span class="line">                                    v                 v</span><br><span class="line">                     +--------------------------------+</span><br><span class="line">                     |<span class="string">TCP/UDP header</span>|<span class="string"> Application data</span>|</span><br><span class="line">                     +--------------------------------+</span><br><span class="line">                     |<span class="string">                                </span>|</span><br><span class="line">                     +<span class="variable">&lt;-- TCP segment/UDP datagram --&gt;</span>+</span><br><span class="line">                     v                                v</span><br><span class="line">           +------------------------------------------+</span><br><span class="line">           |<span class="string">IP header</span>|<span class="string">TCP/UDP header</span>|<span class="string"> Application data</span>|</span><br><span class="line">           +------------------------------------------+</span><br><span class="line">           |<span class="string">                                          </span>|</span><br><span class="line">           +<span class="variable">&lt;-------------- IP datagram -------------&gt;</span>+</span><br><span class="line">           v                                          v</span><br><span class="line">+--------------------------------------------------------------+</span><br><span class="line">|<span class="string">Eth header</span>|<span class="string">IP header</span>|<span class="string">TCP/UDP header</span>|<span class="string"> Application data</span>|<span class="string">Eth tail</span>|</span><br><span class="line">+--------------------------------------------------------------+</span><br><span class="line">           |<span class="string">                                          </span>|</span><br><span class="line"><span class="variable">&lt;--------------------  Ethernet frame ---------------&gt;</span>+</span><br><span class="line">           |<span class="string">                                          </span>|</span><br><span class="line">           |<span class="string"> &lt;----------- 40~1500 Bytes ------------&gt; </span>|</span><br></pre></td></tr></table></figure></p>
<h3 id="以太网数据帧封装"><a href="#以太网数据帧封装" class="headerlink" title="以太网数据帧封装"></a>以太网数据帧封装</h3><p>以太网数据帧（也叫 MAC 帧）是网络硬件上面传送数据的最小单位，它承载了上层（网络层）的通信数据，是网络接口层的封包格式。我们一般接触比较多的是网络接口，比如 eht0、eht1…，这些网络接口上处理的主要数据包就是以太网数据帧。以太网数据帧封装格式在 RFC 894 中定义，具体格式如下：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+----------+---------+------+-----------------------------------+------+</span><br><span class="line">|  MAC dst | Mac src |<span class="built_in"> Type </span>|             Data                  | CRC  |</span><br><span class="line">+----------+---------+-------------------------------------------------+</span><br><span class="line">      6         6       2   |          46~1500 Bytes            | 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                     |<span class="built_in"> Type </span>|</span><br><span class="line">                     +------------------------------------------+</span><br><span class="line">                     |0x800 |         <span class="built_in"> IP </span>datagram              |</span><br><span class="line">                     +------+-----------------------------------+</span><br><span class="line">                        2              46~1500 Bytes</span><br><span class="line"></span><br><span class="line">                     |<span class="built_in"> Type </span>|</span><br><span class="line">                     +-------------------------+</span><br><span class="line">                     |0x806 |     ARP      |PAD|</span><br><span class="line">                     +------+------------------+</span><br><span class="line">                         2         28       18</span><br><span class="line"></span><br><span class="line">                     |<span class="built_in"> Type </span>|</span><br><span class="line">                     +-------------------------+</span><br><span class="line">                     |0x8035|     RARP     |PAD|</span><br><span class="line">                     +-------------------------+</span><br><span class="line">                         2         28       18</span><br></pre></td></tr></table></figure></p>
<h3 id="IP-数据报封装"><a href="#IP-数据报封装" class="headerlink" title="IP 数据报封装"></a>IP 数据报封装</h3><p>IP 协议处于网络层，几乎所有上层协议都会使用到 IP 协议。 IP 有两种版本，一种是目前使用最广泛的 IPv4 (Internet Protocol version 4, 因特网协定第四版)， 一种则是预期未来会热门的 IPv6 。<br>IPv4 记录的地址长度为 32 bit（4 Bytes），IPv6 的地址可以达到 128 bit（16 Bytes）。<br>下面为 IP 数据报的封装格式：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">| 4 bits  | 4 bits  |    8 bitys     |3bits|          13 bits             |</span><br><span class="line"><span class="code">+-------------------------------------------------------------------------+</span></span><br><span class="line">| Version |   IHL   |Type of Service |         Total Length               |</span><br><span class="line"><span class="code">+---------+</span>---------------------------------------------------------------+</span><br><span class="line">|             Identification         |Flags|    Fragmentation Offset      |</span><br><span class="line"><span class="code">+-------------------+</span>-----------------------------------------------------+</span><br><span class="line">|    Time To Live   |    Protocol    |           Header Checksum          |</span><br><span class="line"><span class="code">+-------------------+</span>----------------<span class="code">+------------------------------------+</span></span><br><span class="line">|                            Source Address                               |</span><br><span class="line"><span class="code">+-------------------------------------------------------------------------+</span></span><br><span class="line">|                          Destination Address                            |</span><br><span class="line"><span class="code">+-------------------------------------------------------------------------+</span></span><br><span class="line">|                         Options(Up to 40 bytes)                         |</span><br><span class="line"><span class="code">+-------------------------------------------------------------------------+</span></span><br><span class="line">|                                                                         |</span><br><span class="line">|                                  Data                                   |</span><br><span class="line">|                                                                         |</span><br><span class="line"><span class="code">+-------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Version(版本)</code>: 版本号指定 IP 协议的版本，长度为 4 bits。对于 IPv4 来说，其值为 4；</li>
<li><code>IHL(Internet Header Length, IP 数据报头部长度)</code>：IP 数据报的头部长度，不包括数据部分，单位为 4 字节。由于该字段为 4 bits，所以 IP 封包头部最长为 (2^4-1)x4=60 字节；</li>
<li><code>Type of Service(服务类型)</code>：服务类型包括一个 3 位的优先权字段（现已被弃用），4 位的 TOS 字段和 1 位保留字段（必须置0）。4 位 TOS 字段分别表示最小延时、最大吞吐量、最高可靠性和最小费用;</li>
<li><code>Total Length(总长度)</code>：总长度表示整个 IP 数据报的长度，以字节为单位，可以看出最大值为 2^16-1=65535 字节；</li>
<li><code>Identification(标识码)</code>：标示字段唯一的标示主机发送的每一个 IP 数据报，初始值由系统随机生成；</li>
<li><code>Flags</code>: 标志的第一位保留，第二位表示「禁止分片」。如果设置了这个位，系统不对 IP 报文分片。在这种情况下，如果 IP 数据报的长度超过 MTU（Max Transfer Unit，最大传输单元），IP 模块将丢弃该数据报并返回一个 ICMP 差错报文。第三位表示「更多分片」，如果为 1，表示后续还有该 IP 报文的分片；</li>
<li><code>Fragment Offset(分片偏移)</code>: 分片偏移是分片相对原始 IP 数据报开始处的偏移，在接收端组合分片时，根据这个字段决定各分片的先后顺序；</li>
<li><code>Time To Live(TTL, 存活时间)</code>: 表示这个IP封包的存活时间，范围为0-255。当这个IP封包通过一个路由器时， TTL就会减一，当TTL为0时，这个封包将会被直接丢弃；</li>
<li><code>Protocol(协议代码)</code>: 协议字段用来区分上层的协议，其中 ICMP 是 1，TCP 是6，UDP是 17，更多可查看 /etc/protocols 文件；</li>
<li><code>Header Checksum(头部校验码)</code>: 头部校验码由发送端填充，接收端使用 CRC 循环冗余校验算法检查 IP 数据报是否损坏；</li>
<li><code>Source Address</code>: 发送端 IP 地址</li>
<li><code>Destination Address</code>: 接收端 IP 地址</li>
<li><code>Options</code>: 选项部分长度最大为 40 字节，最小为 0 字节。因为头部长度字段最大可表示 15，也就是说 IP 数据报的报头最大可以有 60 字节，而前面这些已经占了 20 字节，故选项部分最多只能有 40 字节。</li>
</ul>
<h3 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h3><p>当要发送的数据大于 MTU 的时候，通常需要进行 IP 分片，将数据分成多个 IP 数据报发送。MTU 一般为 1500 字节。</p>
<p>由上文可知，在 3 位的标志字段中，如果允许分片，则相同的 16 位的标识字段标识这些分片属于同一个数据块，片偏移标识这些分片的先后顺序。</p>
<h3 id="IP-相关的概念"><a href="#IP-相关的概念" class="headerlink" title="IP 相关的概念"></a>IP 相关的概念</h3><h4 id="IP-地址的组成"><a href="#IP-地址的组成" class="headerlink" title="IP 地址的组成"></a>IP 地址的组成</h4><p>IP 地址是一个 32 bits 的数值，为了记忆方便，一般将其写成 4 段以 <code>.</code> 号分隔的十进制形式：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP的表示式： </span><br><span class="line"><span class="number">00000000.00000000</span><span class="number">.00000000</span><span class="number">.00000000</span> ==&gt; <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> </span><br><span class="line"><span class="number">11111111.11111111</span><span class="number">.11111111</span><span class="number">.11111111</span> ==&gt; <span class="number">255.255</span><span class="number">.255</span><span class="number">.255</span></span><br></pre></td></tr></table></figure></p>
<p>一个 IP 地址分为 Net_ID（网络号）和 Host_ID（主机号）两部分：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>~<span class="number">192.168</span><span class="number">.0</span><span class="number">.255</span> 这个Class C 的说明：</span><br><span class="line"><span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.00000000</span></span><br><span class="line"><span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.11111111</span></span><br><span class="line">|----------Net_ID---------|HOST_ID|</span><br></pre></td></tr></table></figure></p>
<h4 id="同一网段"><a href="#同一网段" class="headerlink" title="同一网段"></a>同一网段</h4><p>在同一个物理网段内，主机的 IP 具有相同的 Net_ID（网络号） ，并且具有唯一的 Host_ID（主机号），那么这些 IP 群就是在同一个网段。</p>
<p>在同一个网段内，Net_ID 是不变的，而 Host_ID 则是不可重复，此外，Host_ID 在二进位的表示法当中，不可同时为 0 也不可同时为 1 ，因为全为 0 表示整个网段的地址(Network IP)，而全为 1 则表示为广播的地址(Broadcast IP)。</p>
<h4 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h4><p>InterNIC 将整个 IP 网段分为五种等级， 每种等级的范围主要与 IP 那 32 bits 数值的前面几个位有关，基本定义如下：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">以二进位说明Network第一个数字的定义： </span><br><span class="line"><span class="keyword">Class</span> A : <span class="number">0</span> xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   ==&gt; NetI_D的开头是<span class="number">0</span></span><br><span class="line">          |<span class="type">--net</span>--|<span class="type">---------host</span>------------| <span class="type"></span></span><br><span class="line"><span class="type">Class</span> B : <span class="number">10</span> xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   ==&gt; NetI_D的开头是<span class="number">10</span></span><br><span class="line">          |<span class="type">------net</span>-------|<span class="type">------host</span>------| <span class="type"></span></span><br><span class="line"><span class="type">Class</span> C : <span class="number">110</span> xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   ==&gt; NetI_D的开头是<span class="number">110</span></span><br><span class="line">          |<span class="type">-----------net</span>-----------|<span class="type">-host</span>--| <span class="type"></span></span><br><span class="line"><span class="type">Class</span> D : <span class="number">1110</span> xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   ==&gt; NetI_D的开头是<span class="number">1110</span> </span><br><span class="line"><span class="keyword">Class</span> E : <span class="number">1111</span> xxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx   ==&gt; NetI_D的开头是<span class="number">1111</span></span><br><span class="line"></span><br><span class="line">五种分级在十进位的表示： </span><br><span class="line"><span class="keyword">Class</span> A :   <span class="number">0.</span>xx.xx.xx ~ <span class="number">127.</span>xx.xx.xx </span><br><span class="line"><span class="keyword">Class</span> B : <span class="number">128.</span>xx.xx.xx ~ <span class="number">191.</span>xx.xx.xx </span><br><span class="line"><span class="keyword">Class</span> C : <span class="number">192.</span> xx.xx.xx ~ <span class="number">223.</span>xx.xx.xx </span><br><span class="line"><span class="keyword">Class</span> D : <span class="number">224.</span>xx.xx.xx ~ <span class="number">239.</span>xx.xx.xx </span><br><span class="line"><span class="keyword">Class</span> E : <span class="number">240.</span>xx.xx.xx ~ <span class="number">255.</span>xx.xx.xx</span><br></pre></td></tr></table></figure></p>
<h4 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h4><p>前面我们知道了标准的 5 种 IP 等级划分，在一个 A 类网络中最多能有 2^24-2=16777214 台主机。其实在实际应用中一个网络不可能有这么多主机，有这么多主机意味着时时刻刻都会发生广播(比如 ARP 广播)风暴，导致一个网络的主机通信阻塞，根本不能正常工作。</p>
<p>为了解决上述问题，我们可以将一个大网络切分的更细点，让同一个网络中主机的数据量控制在合理的范围。具体的做法就是通过向 IP 的主机位借位，使其成为网络位，这样主机位就缩短了，从而减少了一个网络中主机的数量。</p>
<p><strong>举例</strong>：一个 C 类 IP 地址网络位有 24 位，主机位有 8 位，那么这种情况下一个 C 类网络中就最多有 2^8-2=254 台主机。如果我们向主机位借一位，使其成为网络位，那么此时网络位就有 25 bit，主机位有 7 bit，所以此时一个网络中最多有 2^7-2=126 台主机。</p>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>子网掩码（Netmask）也是 32 位数值，在数值上，位于 Net_ID（网络位）的为 1，而 Host_ID（主机位）为 0<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>~<span class="number">192.168</span><span class="number">.0</span><span class="number">.255</span> 这个C Class 的Netmask 说明</span><br><span class="line">第一个IP： <span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.00000000</span></span><br><span class="line">最后一个： <span class="number">11000000.10101000</span><span class="number">.00000000</span><span class="number">.11111111</span></span><br><span class="line">         |----------Net_ID---------|--host--|</span><br><span class="line">Netmask ： <span class="number">11111111.11111111</span><span class="number">.11111111</span><span class="number">.00000000</span> &lt;== Netmask 二进位</span><br><span class="line">        ： <span class="number">255</span> . <span class="number">255</span> . <span class="number">255</span> . <span class="number">0</span> &lt;== Netmask十进位</span><br></pre></td></tr></table></figure></p>
<h4 id="网络相关的几个参数"><a href="#网络相关的几个参数" class="headerlink" title="网络相关的几个参数"></a>网络相关的几个参数</h4><ul>
<li><strong>Network</strong>：一个网络中的第一个 IP， Host_ID（网络位） 全为 0 时的 IP 地址，此时表示整个网段；</li>
<li><strong>Broadcast</strong>：一个网络中的最后一个 IP，Host_ID（网络位） 全为 1 时的 IP 地址，即广播地址；</li>
<li><strong>Netmask</strong>：位于 Net_ID（网络位）的为 1，而 Host_ID（主机位）为 0，此时的 IP 即为子网掩码；<br>例题：<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">试着计算出 <span class="number">172.16.0.0</span>，但 Net_ID 占用 <span class="number">23</span> 位时，这个网络的 Netmask, </span><br><span class="line">Network, Broadcast 等参数？</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">解答：</span><br><span class="line">由于 <span class="number">172</span>.<span class="number">16</span>.xxx.xxx 是在 Class B 的等级当中，亦即 Net_ID 是<span class="number">16</span> 位才</span><br><span class="line">对。不过题目给的Net_ID 占用了<span class="number">23</span> 个位！等于是向 Host_ID 借了(<span class="number">23</span>-<span class="number">16</span>) </span><br><span class="line"><span class="number">7</span> 个位用在 Net_ID 当中。所以整个 IP 的位址会变成这样：</span><br><span class="line"></span><br><span class="line">预设： <span class="number">172</span> . <span class="number">16</span> .<span class="number">0000000 0</span>.<span class="number">00000000</span> </span><br><span class="line">      |----Net_ID-------|--Host--| </span><br><span class="line">Network: <span class="number">172</span>.<span class="number">16.0000000</span> <span class="number">0.00000000</span>    <span class="number">172.16.0.0</span></span><br><span class="line">Broadcast: <span class="number">172</span>.<span class="number">16.0000000</span> <span class="number">1.11111111</span>    <span class="number">172.16.1.255</span></span><br><span class="line">Netmask: <span class="number">11111111</span>.<span class="number">11111111</span>.<span class="number">1111111 0</span>.<span class="number">00000000</span>    <span class="number">255.255.254.0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="CIDR-Classless-Interdomain-Routing"><a href="#CIDR-Classless-Interdomain-Routing" class="headerlink" title="CIDR(Classless Interdomain Routing)"></a>CIDR(Classless Interdomain Routing)</h4><p>一般来说，如果我们知道了 Network 以及 Netmask 之后，就可以定义出该网段的所有 IP 了，因此，我们常常会以 Network 以及 Netmask 来表示一个网段，例如这样的写法：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Network/Netmask</span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">24</span>     &lt;==因为 Net_ID 共有 <span class="number">24</span> bits</span><br></pre></td></tr></table></figure></p>
<p>一般我们将一个网段 <code>Network/网络位数量</code> 这种写法称作 CIDR，比如：192.168.0.0/24。</p>
<h3 id="路由概念"><a href="#路由概念" class="headerlink" title="路由概念"></a>路由概念</h3><p>在同一个网段中可以通过局域网广播的方式传递数据报，但是在不同的网段中通信就需要借助于路由器的帮忙了。</p>
<p>我们以下面图示的例子来做说明。下列图示当中共有两个不同的网段，分别是Network A 与Network B，这两个网段是经由一部路由器(Server A) 来进行资料转递的，那么当 PC01 这部主机想要传送资料到 PC11 时， 它的IP 封包该如何传输呢？<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------------+</span><br><span class="line">|<span class="string">                     Network A                    </span>|</span><br><span class="line">|<span class="string">                                                  </span>|</span><br><span class="line">|<span class="string">       +-------+                  +-------+       </span>|</span><br><span class="line">|<span class="string">       </span>|<span class="string">       </span>|<span class="string">                  </span>|<span class="string">       </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string">       </span>|<span class="string"> PC 01 </span>|<span class="string">                  </span>|<span class="string"> PC 02 </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string">       </span>|<span class="string">       </span>|<span class="string">                  </span>|<span class="string">       </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string">       +-------+--------+---------+-------+       </span>|</span><br><span class="line">|<span class="string">    IP: 192.168.0.1     </span>|<span class="string">      IP: 192.168.0.2    </span>|</span><br><span class="line">|<span class="string">    GW:192.168.0.254    </span>|<span class="string">      GW:192.168.0.254   </span>|</span><br><span class="line">+--------------------------------------------------+</span><br><span class="line">                         |</span><br><span class="line"><span class="string">                   192.168.0.254</span></span><br><span class="line"><span class="string">                     +--------+</span></span><br><span class="line"><span class="string">                     </span>|<span class="string">        </span>|</span><br><span class="line">                     |<span class="string">Server A</span>|</span><br><span class="line">                     |<span class="string">        </span>|</span><br><span class="line">                     +--------+</span><br><span class="line">                   192.168.1.254</span><br><span class="line">                         |</span><br><span class="line"><span class="string">+--------------------------------------------------+</span></span><br><span class="line">|<span class="string">                        </span>|<span class="string">                         </span>|</span><br><span class="line">|<span class="string">       +-------+--------+-----------+-------+     </span>|</span><br><span class="line">|<span class="string">       </span>|<span class="string">       </span>|<span class="string">                    </span>|<span class="string">       </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string">       </span>|<span class="string"> PC 11 </span>|<span class="string">                    </span>|<span class="string"> PC 12 </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string">       </span>|<span class="string">       </span>|<span class="string">                    </span>|<span class="string">       </span>|<span class="string">     </span>|</span><br><span class="line">|<span class="string">       +-------+                    +-------+     </span>|</span><br><span class="line">|<span class="string">    IP: 192.168.1.1              IP: 192.168.1.2  </span>|</span><br><span class="line">|<span class="string">    GW:192.168.1.254             GW:192.168.1.254 </span>|</span><br><span class="line">|<span class="string">                                                  </span>|</span><br><span class="line">|<span class="string">                      Network B                   </span>|</span><br><span class="line">+--------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>查询 IP 封包的目标 IP 地址：<br>当 PC01 有 IP 封包需要传送时，主机会查阅 IP 封包头部的目标 IP 地址；</p>
</li>
<li><p>查询本机的路由配置：<br>PC01 主机会分析自己的路由表，当发现目标 IP 与本机 IP 的 Net_ID 相同时(同一网段)，则PC01 会直接透过局域网功能，将数据包直接传送给目的地主机。</p>
</li>
<li><p>查询默认网关(default gateway)：<br>但在本案例中， PC01 与 PC11 并非在同一网段，因此 PC01 会分析路由表当中是否有其他相符合的路由设定，如果没有的话，就直接将该 IP 封包送到默认网关(default gateway)上头去，在本案例当中 default gateway 则是Server A。</p>
</li>
<li><p>送出封包至 gateway 后，不理会封包流向：<br>当 IP 由 PC01 送给 Server A 之后， PC01 就不理会接下来的工作。而 Server A 接收到这个封包后，会依据上述的流程，也分析自己的路由表，然后向后继续传输到正确的目的地主机上。</p>
</li>
</ol>
<h3 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h3><p>TCP 协议处于四层参考模型的第三层，即传输层。同一层的还有 UDP 协议。TCP 和 UDP 的区别是：TCP 是可靠的，面向连接的，基于字节流的服务；UDP 是不可靠的，无连接的，面向数据块的服务。</p>
<p>解释如下：</p>
<ul>
<li>每次使用 TCP 传输数据时，都要先建立一对一的连接，即面向连接的。而使用 UDP 时不必先建立连接，而是直接将数据广播出去就可以，即无连接；</li>
<li>因为 TCP 必须先建立连接，所以 TCP 传输的速度要比 UDP 慢；</li>
<li>TCP 使用一系列机制来保证数据的可靠传输，包括数据确认机制，超时重传机制等。<br>发送 TCP 数据时，应用层需将数据写入到 OS 提供的 buffer 里面，操作系统将其看作一连串的，没有边界的数据流，通过相对序号进行定位；而发送 UDP 数据时，应用层交给 OS 多大的数据包，操作系统就直接发送出去。根本不考虑效率，如果数据太大，可能会在 IP 层进行分片，如果数据太小，则每个数据包的有效载荷会比较低，浪费带宽；</li>
</ul>
<h3 id="TCP-报头格式"><a href="#TCP-报头格式" class="headerlink" title="TCP 报头格式"></a>TCP 报头格式</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">|4 bits|  6 bits |  6 bits |          16 bits           |</span><br><span class="line"><span class="code">+----------------+</span>--------------------------------------+</span><br><span class="line">|        Source Port       |     Destination Port       |</span><br><span class="line"><span class="code">+--------------------------+</span>----------------------------+</span><br><span class="line">|                   Sequence Number                     |</span><br><span class="line"><span class="code">+-------------------------------------------------------+</span></span><br><span class="line">|                  Acknowledge Number                   |</span><br><span class="line"><span class="code">+----------------+</span>---------<span class="code">+----------------------------+</span></span><br><span class="line">|Data  |Reserved |  Code   |           Window           |</span><br><span class="line">|Offset|         |         |                            |</span><br><span class="line"><span class="code">+----------------+</span>--------------------------------------+</span><br><span class="line">|         Checksum         |       Urgent Pointer       |</span><br><span class="line"><span class="code">+--------------------------+</span>----------------------------+</span><br><span class="line">|                 Options(0~40 bytes)                   |</span><br><span class="line"><span class="code">+-------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>Source Port &amp; Destination Port（来源和目的端口）</code>：指明该 TCP 报文是由哪一个应用程序发送给哪一个应用程序的。因为端口号标示这应用层的一个服务进程；</li>
<li><code>Sequence Number（序号）</code>：序号表明该报文段在整个数据流中相对于开始位置的偏移量；</li>
<li><code>Acknowledge Number（确认号）</code>：确认号表明该报文是对对端的哪一个报文的确认，特别声明的是，只有当 ACK 标志为 1 时，确认号才有效。TCP 的数据确认机制就是通过这两个字段来实现的；</li>
<li><code>Data Offset</code>：标识该 TCP 头部有多少个 4 字节，共表示最长 15x4=60 字节。同IP头部；</li>
<li><code>Reserved</code>：保留不用，以便于将来扩展；</li>
<li><code>Code（Control Flag,控制标志码）</code>：共 6 位：S、A、F、U、R、P，含义分别为 S –&gt; SYN，若为 1，表明这是一个请求报文。A –&gt; ACK，若为 1，表明确认号有效，这是一个确认报文。F –&gt; FIN，若为 1，表明这是一个断开连接的请求报文。U –&gt; URG，若为 1，表明紧急指针有效。R –&gt; RST，若为 1，表明这是一个复位报文段，接收端会清空自己的发送缓冲区。P –&gt; PSH，若为 1，提示接收端应用程序应立即从缓冲区中读走数据；</li>
<li><code>Window（滑动窗口）</code>：用于流量控制，告诉对端自己的缓冲区大小，用于 TCP 的滑动窗口机制；</li>
<li><code>Checksum（确认检查码）</code>：由发送端对 TCP 头部和数据部分进行 CRC 循环冗余校验后填充，接收端以此确定该数据报是否损坏；</li>
<li><code>Urgent Pointer（紧急指针）</code>：若 URG 标志为 1，则紧急指针有效，指明 TCP 带外数据的相对位置；</li>
<li><code>Options（选项）</code>：目前此字段仅应用于表示接收端可以接收的最大数据区段容量，若此字段不使用， 表示可以使用任意数据区段的大小，这个字段较少使用。选项最大长度为 40 字节，计算方法和 IP 头部选项的计算方法一致；</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 计算机网络 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[公有云服务器磁盘分区扩展]]></title>
      <url>/2019/04/29/%E5%85%AC%E6%9C%89%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在 web 控制台增加了磁盘空间大小，但是登陆到服务器 df -h 查看还是原先大小，并没有变化。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看设备名称</span></span><br><span class="line">lsblk</span><br><span class="line"><span class="comment"># /dev/xvdb : 磁盘设备名称，扩展该磁盘的第一个分区</span></span><br><span class="line">growpart /dev/xvdb 1</span><br><span class="line"><span class="comment"># /dev/xvdb1: 分区名称，扩展分区文件系统大小</span></span><br><span class="line">resize2fs /dev/xvdb1</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用 Dnsmasq 搭建一个简单的 DNS 服务器]]></title>
      <url>/2019/04/27/%E7%94%A8-Dnsmasq-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84-DNS-%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>本文主要介绍如何通过 <a href="http://www.thekelleys.org.uk/dnsmasq/doc.html" target="_blank" rel="noopener">Dnsmasq</a> 工具搭建一个简单的 DNS 服务器，搭建完成后就可以马上测试使用了。</p>
<h3 id="Dnsmasq-简介"><a href="#Dnsmasq-简介" class="headerlink" title="Dnsmasq 简介"></a>Dnsmasq 简介</h3><p><a href="http://www.thekelleys.org.uk/dnsmasq/doc.html" target="_blank" rel="noopener">Dnsmasq</a> 是一个轻量级的 DNS 缓存、DHCP、TFTP、PXE 服务器。</p>
<p>作为域名解析服务器，dnsmasq 可以通过缓存 DNS 请求来提高对访问过域名的解析速度。</p>
<p>作为 DHCP 服务器，Dnsmasq 可以用于为局域网电脑分配内网 IP 地址和提供路由。DNS 和 DHCP 两个功能可以同时或分别单独实现。</p>
<h3 id="Dnsmasq-的应用场景"><a href="#Dnsmasq-的应用场景" class="headerlink" title="Dnsmasq 的应用场景"></a>Dnsmasq 的应用场景</h3><p>我们一般使用 Dnsmasq 的 DNS 功能，总结了下基于该功能有如下使用场景：</p>
<ul>
<li><p>作为内部局域网的一个 DNS 缓存服务器。通过 DNS 缓存的功能，可以提高应用程序域名解析的速度。比如 <a href="https://kubernetes.io/" target="_blank" rel="noopener">Kubernetes</a> 的 <a href="https://github.com/kubernetes/dns" target="_blank" rel="noopener">kube-dns</a> 组件中就用 dnsmasq 容器作为 DNS 服务器，用 kube-dns 容器作为 dnsmasq 的上游服务器。dnsmasq 本身具有缓存功能，所以可以大大提高集群中服务名的解析速度，而不需要每次解析请求都访问 kube-dns 容器。</p>
</li>
<li><p>实现 DNS 劫持功能。在局域网中，我们有时候可能希望暂时将某个公网域名解析到一个临时的地址，不走公网 DNS。</p>
</li>
</ul>
<h3 id="Dnsmasq-的工作原理"><a href="#Dnsmasq-的工作原理" class="headerlink" title="Dnsmasq 的工作原理"></a>Dnsmasq 的工作原理</h3><p>Dnsmasq 在接受到用户的一个 DNS 请求时，首先会查找 /etc/hosts 这个文件，如果 /etc/hosts 文件没有请求的记录，然后查找 /etc/resolv.conf 中定义的外部 DNS（也叫上游 DNS 服务器，nameserver 配置），外部 DNS 通过递归查询查找到请求后响应给客户端，然后 dnsmasq 将请求结果缓存下来（缓存到内存）供后续的解析请求。</p>
<p>配置 Dnsmasq 为 DNS 缓存服务器，同时在 /etc/hosts 文件中加入本地内网解析，这样一来每当内网机器查询时就会优先查询 hosts 文件，这就等于将 /etc/hosts 共享给全内网机器使用，从而解决内网机器互相识别的问题。相比逐台机器编辑 hosts 文件或者添加 Bind DNS 记录，仅编辑一个 hosts 文件，这简直太容易了。</p>
<h3 id="Dnsmasq-安装"><a href="#Dnsmasq-安装" class="headerlink" title="Dnsmasq 安装"></a>Dnsmasq 安装</h3><p>Dnsmasq 的安装特别简单，以 Centos7 下安装为例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y dnsmasq</span><br></pre></td></tr></table></figure></p>
<h3 id="Dnsmasq-配置及启动"><a href="#Dnsmasq-配置及启动" class="headerlink" title="Dnsmasq 配置及启动"></a>Dnsmasq 配置及启动</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Dnsmasq 的所有的配置都在 <code>/etc/dnsmasq.conf</code> 这一个文件中完成 。官方在配置文件 <code>/etc/dnsmasq.conf</code> 中针对选项和参数等做了比较好的注释说明，我们可以将配置做一次备份，以便以后查阅。默认情况下 dnsmasq.conf 中只开启了最后 include 项，因此可以在 /etc/dnsmasq.conf 的前提下，将自定义的配置放到 /etc/dnsmasq.d 目录下的一个任意名字的配置文件当中。</p>
<blockquote>
<p>注意： /etc/dnsmasq.d/*.conf 的优先级大于 /etc/dnsmasq.conf</p>
</blockquote>
<p>关于 dnsmasq 的配置项非常多，具体配置项含义在 <code>/etc/dnsmasq.conf</code> 中有详细的说明，本文如下配置实现一个简单的 DNS 服务器（配置文件放到了 <code>/etc/dnsmasq.d/</code> 目录下，命名为 <code>dnsmasq.conf</code>）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#dnsmasq 启动监听的端口号</span></span><br><span class="line">port=53</span><br><span class="line"></span><br><span class="line"><span class="comment">#从不转发格式错误的域名</span></span><br><span class="line">domain-needed</span><br><span class="line"></span><br><span class="line"><span class="comment">#默认情况下Dnsmasq会发送查询到它的任何上游DNS服务器上，如果取消注释，</span></span><br><span class="line"><span class="comment">#则Dnsmasq则会严格按照/etc/resolv.conf中的 DNS Server 顺序进</span></span><br><span class="line"><span class="comment">#行查询，直到第一个成功解析成功为止。</span></span><br><span class="line">strict-order</span><br><span class="line"></span><br><span class="line"><span class="comment"># dnsmasq 缓存大小，默认 150</span></span><br><span class="line">cache-size=8192</span><br><span class="line"></span><br><span class="line"><span class="comment">#address 可以将指定的域解析为一个IP地址，即泛域名解析。</span></span><br><span class="line"><span class="comment"># 将 *.taobao.com 解析到 10.10.10.10</span></span><br><span class="line">address=/taobao.com/10.10.10.10</span><br><span class="line"></span><br><span class="line"><span class="comment">#把所有.cn的域名全部通过 114.114.114.114 这台国内DNS服务器来解析</span></span><br><span class="line">server=/cn/114.114.114.114</span><br></pre></td></tr></table></figure></p>
<p>为了验证 /etc/hosts 文件解析是否起作用，我们也向 hosts 文件添加几条记录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.4.29.106      ansible</span><br><span class="line">10.4.24.116      www.baidu.com</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：/etc/hosts 文件修改后需要重启 dnsmasq，否则修改不会生效。<br>重启方法：<code>systemctl restart dnsmasq</code></p>
</blockquote>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置为开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> dnsmasq</span><br><span class="line"><span class="comment"># 启动 dnsmasq 服务</span></span><br><span class="line">systemctl start dnsmasq</span><br></pre></td></tr></table></figure>
<h3 id="测试使用-Dnsmasq"><a href="#测试使用-Dnsmasq" class="headerlink" title="测试使用 Dnsmasq"></a>测试使用 Dnsmasq</h3><p>我们搭建的 DNS 服务器地址为：<code>192.168.10.200</code></p>
<p>使用 dig 命令指定 DNS 服务器地址来查看解析是否生效：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dig @192.168.10.200 ansible</span><br><span class="line">dig @192.168.10.200 www.taobao.com</span><br><span class="line">dig @192.168.10.200 ip.cn</span><br></pre></td></tr></table></figure></p>
<h3 id="验证-Dnsmasq-缓存功能是否生效"><a href="#验证-Dnsmasq-缓存功能是否生效" class="headerlink" title="验证 Dnsmasq 缓存功能是否生效"></a>验证 Dnsmasq 缓存功能是否生效</h3><p>首先使用 dig 查询一个之前未查询过的域名，然后看响应时间是多少：<br>第一次 dig：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dig @192.168.10.200 qhh.me</span><br><span class="line">......                                                                                                                                </span><br><span class="line">;; Query time: 478 msec</span><br><span class="line">;; SERVER: 192.168.10.200<span class="comment">#53(192.168.10.200)</span></span><br><span class="line">;; WHEN: Sat Apr 27 21:45:24 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 56</span><br></pre></td></tr></table></figure></p>
<p>第二次 dig：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dig @192.168.10.200 qhh.me                                                                                                                                   </span><br><span class="line">......</span><br><span class="line">;; Query time: 0 msec</span><br><span class="line">;; SERVER: 192.168.10.200<span class="comment">#53(192.168.10.200)</span></span><br><span class="line">;; WHEN: Sat Apr 27 21:45:32 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 67</span><br></pre></td></tr></table></figure></p>
<p>可以看到两次同样的 dig 查询的时间不一样，第一次 478 ms，第二次 0 ms，说明第二次直接是从缓存中取的数据，没有向上游服务器发起请求。</p>
<h3 id="Dnsmasq-的缓存在哪里？如何查看？"><a href="#Dnsmasq-的缓存在哪里？如何查看？" class="headerlink" title="Dnsmasq 的缓存在哪里？如何查看？"></a>Dnsmasq 的缓存在哪里？如何查看？</h3><p>dnsmasq 的缓存并不是保存在本地磁盘的某个文件，而是存储在内存中，因此是无法直接查看的。当然作为一个 Geek，想要查看缓存的内容也是有办法的：</p>
<ol>
<li><p>dnsmasq 启动参数添加 –log-queries</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/dnsmasq.service</span><br><span class="line">ExecStart=/usr/sbin/dnsmasq -k 改为：ExecStart=/usr/sbin/dnsmasq -k --<span class="built_in">log</span>-queries</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新加载 Systemd Unit 配置文件</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl daemon-reload</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 dnsmasq</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl restart dnsmasq</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行如下命令 dump 出来缓存内容到 journal 日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -SIGUSR1 &lt;PID&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 dump 出来的 dns 记录（dnsmasq 当前缓存的内容）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u dnsmasq</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.thekelleys.org.uk/dnsmasq/doc.html" target="_blank" rel="noopener">http://www.thekelleys.org.uk/dnsmasq/doc.html</a> | dnsmasq 官方文档<br><a href="https://www.hi-linux.com/posts/30947.html" target="_blank" rel="noopener">https://www.hi-linux.com/posts/30947.html</a> | 一篇比较全面的博客<br><a href="https://yq.aliyun.com/articles/582537" target="_blank" rel="noopener">https://yq.aliyun.com/articles/582537</a> | 一篇比较精简的博客<br><a href="http://flux242.blogspot.com/2012/06/dnsmasq-cache-size-tuning.html" target="_blank" rel="noopener">http://flux242.blogspot.com/2012/06/dnsmasq-cache-size-tuning.html</a> | 介绍了 dnsmasq 的基本概念、缓存淘汰机制等相关内容</p>
]]></content>
      
        <categories>
            
            <category> DNS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 kubeadm 搭建 kubernetes 集群]]></title>
      <url>/2019/03/19/%E4%BD%BF%E7%94%A8-kubeadm-%E6%90%AD%E5%BB%BA-kubernetes-%E9%9B%86%E7%BE%A4/</url>
      <content type="html"><![CDATA[<h3 id="kubeadm-简介"><a href="#kubeadm-简介" class="headerlink" title="kubeadm 简介"></a>kubeadm 简介</h3><p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener">kubeadm</a> 是 <a href="https://kubernetes.io/" target="_blank" rel="noopener">k8s 官方</a>提供的用于快速部署 k8s 集群的命令行工具，也是官方推荐的最小化部署 k8s 集群的最佳实践，比起直接用二进制部署能省去很多工作，因为该方式部署的集群的各个组件以 docker 容器的方式启动，而各个容器的启动都是通过该工具配自动化启动起来的。</p>
<p>kubeadm 不仅仅能部署 k8s 集群，还能很方便的管理集群，比如集群的升级、降级、集群初始化配置等管理操作。</p>
<p>kubeadm 的设计初衷是为新用户提供一种便捷的方式来首次试用 Kubernetes， 同时也方便老用户搭建集群测试他们的应用。</p>
<p>kubeadm 的使用案例：</p>
<ul>
<li>新用户可以从 kubeadm 开始来试用 Kubernetes。</li>
<li>熟悉 Kubernetes 的用户可以使用 kubeadm 快速搭建集群并测试他们的应用。</li>
<li>大型的项目可以将 kubeadm 和其他的安装工具一起形成一个比较复杂的系统。</li>
</ul>
<h3 id="安装环境要求"><a href="#安装环境要求" class="headerlink" title="安装环境要求"></a>安装环境要求</h3><ul>
<li>一台或多台运行着下列系统的机器:<ul>
<li>Ubuntu 16.04+</li>
<li>Debian 9</li>
<li>CentOS 7</li>
<li>RHEL 7</li>
<li>Fedora 25/26</li>
<li>HypriotOS v1.0.1+</li>
<li>Container Linux (针对1800.6.0 版本测试)</li>
</ul>
</li>
<li>每台机器 2 GB 或更多的 RAM (如果少于这个数字将会影响您应用的运行内存)</li>
<li>2 CPU 核心或更多(节点少于 2 核的话新版本 kubeadm 会报错)</li>
<li>集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)</li>
<li>禁用 Swap 交换分区。（Swap 分区必须要禁掉，否则安装会报错）</li>
</ul>
<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>本文使用 kubeadm 部署一个 3 节点的 k8s 集群：1 个 master 节点，2 个 node 节点。各节点详细信息如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Hostname</th>
<th style="text-align:left">IP</th>
<th style="text-align:left">OS 发行版</th>
<th style="text-align:left">内存（GB）</th>
<th style="text-align:left">CPU（核）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">k8s-master</td>
<td style="text-align:left">192.168.10.100</td>
<td style="text-align:left">Centos7</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">k8s-node-1</td>
<td style="text-align:left">192.168.10.101</td>
<td style="text-align:left">Centos7</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">k8s-node-2</td>
<td style="text-align:left">192.168.10.102</td>
<td style="text-align:left">Centos7</td>
<td style="text-align:left">2</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<p><img src="/images/k8s-arch.png" alt=""></p>
<h3 id="kubeadm-安装-k8s-集群完整流程"><a href="#kubeadm-安装-k8s-集群完整流程" class="headerlink" title="kubeadm 安装 k8s 集群完整流程"></a>kubeadm 安装 k8s 集群完整流程</h3><ul>
<li>使用 Vagrant 启动 3 台符合上述要求的虚拟机</li>
<li>调整每台虚拟机的服务器参数</li>
<li>各节点安装 docker、kubeadm、kubelet、kubectl 工具</li>
<li>使用 kubeadm 部署 master 节点</li>
<li>安装 Pod 网络插件（CNI）</li>
<li>使用 kubeadm 部署 node 节点</li>
</ul>
<p>接下来我们依次介绍每步的具体细节：</p>
<h4 id="使用-Vagrant-启动-3-台符合上述要求的虚拟机"><a href="#使用-Vagrant-启动-3-台符合上述要求的虚拟机" class="headerlink" title="使用 Vagrant 启动 3 台符合上述要求的虚拟机"></a>使用 Vagrant 启动 3 台符合上述要求的虚拟机</h4><p>Vagrant 的使用在这里不具体介绍了，如需了解请点击<a href="https://blog.csdn.net/qianghaohao/article/details/80038096" target="_blank" rel="noopener">这里</a>。<br>本文用到的 Vagrantfile:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- mode: ruby -*-</span></span><br><span class="line"><span class="comment"># vi: set ft=ruby :</span></span><br><span class="line"><span class="comment"># author: qhh0205</span></span><br><span class="line"></span><br><span class="line">$num_nodes = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  <span class="comment"># k8s 主节点定义及初始化配置</span></span><br><span class="line">  config.vm.define <span class="string">"k8s-master"</span> <span class="keyword">do</span> <span class="params">| k8s_master |</span></span><br><span class="line">    k8s_master.vm.box = <span class="string">"Centos7"</span></span><br><span class="line">    k8s_master.vm.hostname = <span class="string">"k8s-master"</span></span><br><span class="line">    k8s_master.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.10.100"</span></span><br><span class="line">    k8s_master.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">| v |</span></span><br><span class="line">      v.name = <span class="string">"k8s-master"</span></span><br><span class="line">      v.memory = <span class="string">"2048"</span></span><br><span class="line">      v.cpus = <span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># k8s node 节点定义及初始化配置</span></span><br><span class="line">  (<span class="number">1</span>..$num_nodes).each <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">      config.vm.define <span class="string">"k8s-node-<span class="subst">#&#123;i&#125;</span>"</span> <span class="keyword">do</span> <span class="params">|node|</span></span><br><span class="line">        node.vm.box = <span class="string">"Centos7"</span></span><br><span class="line">        node.vm.hostname = <span class="string">"k8s-node-<span class="subst">#&#123;i&#125;</span>"</span></span><br><span class="line">        node.vm.network <span class="string">"private_network"</span>, <span class="symbol">ip:</span> <span class="string">"192.168.10.<span class="subst">#&#123;i+<span class="number">100</span>&#125;</span>"</span></span><br><span class="line">        node.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> <span class="params">|v|</span></span><br><span class="line">          v.name = <span class="string">"k8s-node-<span class="subst">#&#123;i&#125;</span>"</span></span><br><span class="line">          v.memory = <span class="string">"2048"</span></span><br><span class="line">          v.cpus = <span class="number">2</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>进入 Vagrantfile 文件所在目录，执行如下命令启动上述定义的 3 台虚拟机：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure></p>
<h4 id="调整每台虚拟机的服务器参数"><a href="#调整每台虚拟机的服务器参数" class="headerlink" title="调整每台虚拟机的服务器参数"></a>调整每台虚拟机的服务器参数</h4><ol>
<li><p>禁用 swap 分区：<br>临时禁用：<code>swapoff -a</code><br>永久禁用：<code>sed -i &#39;/swap/s/^/#/g&#39; /etc/fstab</code><br>swap 分区必须禁止掉，否则 <code>kubadm init</code> 自检时会报如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR Swap]: running with swap on is not supported. Please <span class="built_in">disable</span> swap</span><br></pre></td></tr></table></figure>
</li>
<li><p>将桥接的 IPv4 流量传递到 iptables 的链：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">$ sysctl --system</span><br></pre></td></tr></table></figure>
<p> 如果不进行这一步的设置，<code>kubadm init</code> 自检时会报如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR FileContent--proc-sys-net-bridge-bridge-nf-call-iptables]: /proc/sys/net/bridge/bridge-nf-call-iptables contents are not <span class="built_in">set</span> to 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭网络防火墙：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="keyword">stop</span> firewalld</span><br><span class="line">systemctl <span class="keyword">disable</span> firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用 SELinux：<br>临时关闭 selinux（不需要重启主机）: <code>setenforce 0</code><br>永久关闭 selinux（需要重启主机才能生效）：<code>sed -i &#39;s/SELINUX=enforcing/SELINUX=disabled/g&#39; /etc/selinux/config</code></p>
</li>
</ol>
<h4 id="各节点安装-docker、kubeadm、kubelet、kubectl-工具"><a href="#各节点安装-docker、kubeadm、kubelet、kubectl-工具" class="headerlink" title="各节点安装 docker、kubeadm、kubelet、kubectl 工具"></a>各节点安装 docker、kubeadm、kubelet、kubectl 工具</h4><h5 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h5><p>配置 Docker yum 源（阿里 yum 源）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sS -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></p>
<p>安装 docker：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install --nogpgcheck -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum install --nogpgcheck -y docker-ce</span><br><span class="line">systemctl <span class="built_in">enable</span> docker &amp;&amp; systemctl start docker</span><br></pre></td></tr></table></figure></p>
<h5 id="安装-kubeadm、kubelet、kubectl-工具"><a href="#安装-kubeadm、kubelet、kubectl-工具" class="headerlink" title="安装 kubeadm、kubelet、kubectl 工具"></a>安装 kubeadm、kubelet、kubectl 工具</h5><p>配置相关工具 yum 源（阿里 yum 源）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p>
<p>安装 kubeadm、kubelet、kubectl：<br>其实 kubeadm、kubelet、kubectl 这三个工具的版本命名是一致的（和 k8s 版本命名一致），我们可以指定安装特定的版本，即安装指定版本的 k8s 集群。</p>
<p>查看哪些版本可以安装：<br><code>yum --showduplicates list kubeadm|kubelet|kubectl</code></p>
<p>在这里我们安装 <code>1.13.2</code> 版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubeadm-1.13.2 kubelet-1.13.2 kubectl-1.13.2</span><br><span class="line"><span class="comment"># 设置 kubelet 开机自启动: kubelet 特别重要，如果服务器重启后 kubelet</span></span><br><span class="line"><span class="comment"># 没有启动，那么 k8s 相关组件的容器就无法启动。在这里不需要把 kubelet 启动</span></span><br><span class="line"><span class="comment"># 起来，因为现在还启动不起来，后续执行的 kubeadm 命令会自动把 kubelet 拉起来。</span></span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-kubeadm-部署-master-节点"><a href="#使用-kubeadm-部署-master-节点" class="headerlink" title="使用 kubeadm 部署 master 节点"></a>使用 kubeadm 部署 master 节点</h4><p>登陆 master 节点执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --kubernetes-version v1.13.2 --image-repository registry.aliyuncs.com/google_containers --pod-network-cidr=10.244.0.0/16 --apiserver-advertise-address=192.168.10.100</span><br></pre></td></tr></table></figure></p>
<p>参数说明：<br><code>--kubernetes-version</code>:  安装指定版本的 k8s 版本，该参数和 kubeadm 的版本有关，特定版本的 kubeadm 并不能安装所有版本的 k8s，最好还是 kubeadm 的版本和该参数指定的版本一致。</p>
<p><code>--image-repository</code>: 该参数仅在高版本（具体哪个版本没仔细查，反正在 1.13.x 中是支持的）的 kubeadm 中支持，用来设置 kubeadm 拉取 k8s 各组件镜像的地址，默认拉取的地址是：<a href="k8s.gcr.io">k8s.gcr.io</a>。众所周知 <a href="k8s.gcr.io">k8s.gcr.io</a> 国内是无法访问的，所以在这里改为阿里云镜像仓库。</p>
<p><code>--pod-network-cidr</code>: 设置 pod ip 的网段 ，网段之所以是 <code>10.244.0.0/16</code>，是因为后面安装 flannel 网络插件时，yaml 文件里面的 ip 段也是这个，两个保持一致，不然可能会使得 Node 间 Cluster IP 不通。这个参数必须得指定，如果这里不设置的话后面安装 flannel 网络插件时会报如下错误：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E0317 17:02:15.077598       1 main.go:289] <span class="builtin-name">Error</span> registering network: failed <span class="keyword">to</span> acquire lease: node <span class="string">"k8s-master"</span> pod cidr <span class="keyword">not</span> assigned</span><br></pre></td></tr></table></figure></p>
<p><code>--apiserver-advertise-address</code>: API server 用来告知集群中其它成员的地址，这个参数也必须得设置，否则 api-server 容器启动不起来，该参数的值为 master 节点所在的本地 ip 地址。</p>
<hr>
<p>题外话：像之前没有 <code>--image-repository</code> 这个参数时，大家为了通过 kubeadm 安装 k8s 都是采用”曲线救国”的方式：先从别的地方把同样的镜像拉到本地（当然镜像的 tag 肯定不是 k8s.gcr.io/xxxx），然后将拉下来的镜像重新打个 tag，tag 命名成和执行 <code>kubeadm init</code> 时真正拉取镜像的名称一致（比如：k8s.gcr.io/kube-controller-manager-amd64:v1.13.2）。这么做显然做了很多不必要的工作，幸好现在有了 <code>--image-repository</code> 这个参数能自定义 kubeadm 拉取 k8s 相关组件的镜像地址了。</p>
<hr>
<p>执行上面命令后，如果出现如下输出（截取了部分），则表示 master 节点安装成功了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[bootstraptoken] creating the <span class="string">"cluster-info"</span> ConfigMap <span class="keyword">in</span> the <span class="string">"kube-public"</span> namespace</span><br><span class="line">[addons] Applied essential addon: CoreDNS</span><br><span class="line">[addons] Applied essential addon: kube-proxy</span><br><span class="line"></span><br><span class="line">Your Kubernetes master has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">"kubectl apply -f [podnetwork].yaml"</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of machines by running the following on each node</span><br><span class="line">as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join 192.168.10.100:6443 --token jm6o42.9ystvjarc6u09pjp --discovery-token-ca-cert-hash sha256:64405f3a90597e0ebf1f33134649196047ce74df575cb1a7b38c4ed1e2f94421</span><br></pre></td></tr></table></figure></p>
<p>根据上面输出知道：要开始使用集群普通用户执行下面命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure></p>
<p>现在就可以使用 kubectl 访问集群了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@k8s-master ~]$ kubectl get node</span><br><span class="line">NAME         STATUS     ROLES    AGE   VERSION</span><br><span class="line">k8s-master   NotReady   master   13m   v1.13.2</span><br></pre></td></tr></table></figure></p>
<p>可以看出现在 master 节点还是 <code>NotReady</code> 状态，这是因为默认情况下，为了保证 master 的安全，master 是不会被分配工作负载的。你可以取消这个限制通过输入（不建议这样做，我们后面会向集群中添加两 node 工作节点）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl taint nodes --all node-role.kubernetes.io/master-</span><br></pre></td></tr></table></figure></p>
<h4 id="安装-Pod-网络插件（CNI）"><a href="#安装-Pod-网络插件（CNI）" class="headerlink" title="安装 Pod 网络插件（CNI）"></a>安装 Pod 网络插件（CNI）</h4><p>Pod 网络插件有很多种，具体见这里：<a href="https://kubernetes.io/docs/concepts/cluster-administration/addons/，我们选择部署" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/addons/，我们选择部署</a> <a href="https://github.com/coreos/flannel" target="_blank" rel="noopener">Flannel</a> 网络插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-kubeadm-部署-node-节点"><a href="#使用-kubeadm-部署-node-节点" class="headerlink" title="使用 kubeadm 部署 node 节点"></a>使用 kubeadm 部署 node 节点</h4><p>前面已经将 master 节点部署完了，接下来部署 node 节点就很简单了，在 node节点执行如下命令将自己加到 k8s 集群中（复制 master 节点安装完后的输出）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.10.100:6443 --token jm6o42.9ystvjarc6u09pjp --discovery-token-ca-cert-hash sha256:64405f3a90597e0ebf1f33134649196047ce74df575cb1a7b38c4ed1e2f94421</span><br></pre></td></tr></table></figure></p>
<p>出现如下输出（截取了部分）表示成功将 node 添加到了集群：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run <span class="string">'kubectl get nodes'</span> on the master to see this node join the cluster.</span><br></pre></td></tr></table></figure></p>
<p>在 master 节点查看 node 状态，如果都为 Ready，则表示集群搭建完成：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@k8s-master ~]$ kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready    master   14m   v1.13.2</span><br><span class="line">k8s-node-1   Ready    &lt;none&gt;   3m    v1.13.2</span><br></pre></td></tr></table></figure></p>
<p>用同样的方法把另一个节点也加入到集群中。</p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://purewhite.io/2017/12/17/use-kubeadm-setup-k8s/" target="_blank" rel="noopener">https://purewhite.io/2017/12/17/use-kubeadm-setup-k8s/</a><br><a href="https://kubernetes.io/zh/docs/setup/independent/install-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/zh/docs/setup/independent/install-kubeadm/</a><br><a href="https://k8smeetup.github.io/docs/admin/kubeadm/" target="_blank" rel="noopener">https://k8smeetup.github.io/docs/admin/kubeadm/</a></p>
]]></content>
      
        <categories>
            
            <category> Kubenetes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Kubenetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[.dockerignore 文件从入门到实践]]></title>
      <url>/2019/02/24/dockerignore-%E6%96%87%E4%BB%B6%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>.dockerignore</code> 文件的作用类似于 git 工程中的 <code>.gitignore</code> 。不同的是 <code>.dockerignore</code> 应用于 docker 镜像的构建，它存在于 docker 构建上下文的根目录，用来排除不需要上传到 docker 服务端的文件或目录。</p>
<p>docker 在构建镜像时首先从构建上下文找有没有 <code>.dockerignore</code> 文件，如果有的话则在上传上下文到 docker 服务端时忽略掉 <code>.dockerignore</code> 里面的文件列表。这么做显然带来的好处是：</p>
<ul>
<li>构建镜像时能避免不需要的大文件上传到服务端，从而拖慢构建的速度、网络带宽的消耗；</li>
<li>可以避免构建镜像时将一些敏感文件及其他不需要的文件打包到镜像中，从而提高镜像的安全性；</li>
</ul>
<h3 id="dockerignore-文件编写方法"><a href="#dockerignore-文件编写方法" class="headerlink" title=".dockerignore 文件编写方法"></a>.dockerignore 文件编写方法</h3><p><code>.dockerignore</code> 文件的写法和 <code>.gitignore</code> 类似，支持正则和通配符，具体规则如下：</p>
<ul>
<li>每行为一个条目；</li>
<li>以 <code>#</code> 开头的行为注释；</li>
<li>空行被忽略；</li>
<li>构建上下文路径为所有文件的根路径；</li>
</ul>
<p><strong>文件匹配规则具体语法如下：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">规则</th>
<th style="text-align:left">行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*/temp*</td>
<td style="text-align:left">匹配根路径下一级目录下所有以 temp 开头的文件或目录</td>
</tr>
<tr>
<td style="text-align:left">*/*/temp*</td>
<td style="text-align:left">匹配根路径下两级目录下所有以 temp 开头的文件或目录</td>
</tr>
<tr>
<td style="text-align:left">temp?</td>
<td style="text-align:left">匹配根路径下以 temp 开头，任意一个字符结尾的文件或目录</td>
</tr>
<tr>
<td style="text-align:left">**/*.go</td>
<td style="text-align:left">匹配所有路径下以 <code>.go</code> 结尾的文件或目录，即递归搜索所有路径</td>
</tr>
<tr>
<td style="text-align:left">*.md<br>!README.md</td>
<td style="text-align:left">匹配根路径下所有以 <code>.md</code> 结尾的文件或目录，但 README.md 除外</td>
</tr>
</tbody>
</table>
<p>⚠️注意事项：<br>如果两个匹配语法规则有包含或者重叠关系，那么以后面的匹配规则为准，比如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.md</span><br><span class="line">!README*.md</span><br><span class="line">README-secret.md</span><br></pre></td></tr></table></figure></p>
<p>这么写的意思是将根路径下所有以 <code>.md</code> 结尾的文件排除，以 <code>README</code> 开头 <code>.md</code> 结尾的文件保留，但是 <code>README-secret.md</code> 文件排除。</p>
<p>再来看看下面这种写法（同上面那种写法只是对换了后面两行的位置）：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*.md</span><br><span class="line">README-secret.md</span><br><span class="line">!README*.md</span><br></pre></td></tr></table></figure></p>
<p>这么写的意思是将根路径下所有以 <code>.md</code> 结尾和名称为 <code>README-secret.md</code> 的文件排除，但所有以 <code>README</code> 开头 <code>.md</code> 结尾的文件保留。这样的话 <code>README-secret.md</code> 依旧会被保留，并不会被排除，因为 <code>README-secret.md</code> 符合 <code>!README*.md</code> 规则。</p>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>前段时间帮前端同学写了一个 Dockerfile，Dockerfile 放在 git 仓库根路径下，发现 git 工程中有很多真正应用跑起来用不到的文件，如果直接在 Dockerfile 中使用 <code>COPY</code> 或 <code>ADD</code> 指令拷贝文件，那么很显然会把很多不需要的文件拷贝到镜像中，从而会拖慢构建镜像的过程，产生的镜像也比较臃肿。解决方法就是编写 <code>.dockerignore</code> 文件，忽略掉不需要的文件，然后放到 docker 构建上下文的根路径下。<code>.dockerignore</code> 及 <code>Dockerfile</code> 文件内容如下：<br>.dockerignore:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">_mockData</span><br><span class="line">deleted</span><br><span class="line">email-templates</span><br><span class="line">script</span><br><span class="line">static</span><br></pre></td></tr></table></figure></p>
<p>Dockerfile:<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">8</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /app/node</span></span><br><span class="line"><span class="bash">WORKDIR /app/node</span></span><br><span class="line"><span class="bash">RUN yarn install</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">EXPOSE 8026</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">CMD [<span class="string">"yarn"</span>, <span class="string">"run"</span>, <span class="string">"tool-dev"</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>使用 <code>.dockerignore</code> 前后上传到 docker 服务端的构建上下文大小对比：<br>使用前（<code>73.36MB</code>）：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker]$ docker build -t tool:<span class="number">5.0</span> -f Dockerfile-frontend-tool .</span><br><span class="line">Sending build context to Docker daemon  <span class="number">73.36M</span>B</span><br><span class="line">Step <span class="number">1</span>/<span class="number">6</span> : FROM <span class="keyword">node</span><span class="title">:8-alpine</span></span><br></pre></td></tr></table></figure></p>
<p>使用后（<code>11.38MB</code>）：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker]$ docker build -t tool:<span class="number">6.0</span> -f Dockerfile-frontend-tool .</span><br><span class="line">Sending build context to Docker daemon  <span class="number">11.38M</span>B</span><br><span class="line">Step <span class="number">1</span>/<span class="number">6</span> : FROM <span class="keyword">node</span><span class="title">:8-alpine</span></span><br></pre></td></tr></table></figure></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/#dockerignore-file</a></p>
]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解 Docker 构建上下文]]></title>
      <url>/2019/02/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Docker-%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      <content type="html"><![CDATA[<p>本文通过具体实践深入解读 Docker 构建上下文的含义，解惑或者纠正很大一部分人对 Docker 构建上下文的理解误区。本文主要讨论如下主题：</p>
<ul>
<li>对 Docker 构建上下文的理解误区</li>
<li>理解 Docker 的架构</li>
<li>理解 docker build 的工作原理</li>
<li>正确理解 Docker 构建上下文</li>
</ul>
<h3 id="对-Docker-构建上下文的理解误区"><a href="#对-Docker-构建上下文的理解误区" class="headerlink" title="对 Docker 构建上下文的理解误区"></a>对 Docker 构建上下文的理解误区</h3><p>我们都知道，构建一个 Docker 镜像非常简单，大家一般都会这么做（当然这么做是完全正确的）：</p>
<ol>
<li>跳到 Dockerfile 所在目录;</li>
<li>执行 <code>docker build</code> 构建命令:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t &lt;imageName:imageTag&gt; .</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过上面的工作流，很容易形成这样的理解误区：</p>
<ul>
<li><code>docker build</code> 后面的 <code>.</code> 为 Dockerfile 所在的目录；</li>
<li>Dockerfile 文件名 必须为 Dockerfile；</li>
</ul>
<p>其实上面这种理解是错误的，要想准确理解其含义，首先我们需要先了解下 Docker 的架构和 <code>docker build</code> 的工作原理。</p>
<h3 id="理解-Docker-的架构"><a href="#理解-Docker-的架构" class="headerlink" title="理解 Docker 的架构"></a>理解 Docker 的架构</h3><p>Docker 是一个典型的 C/S 架构的应用，分为 Docker 客户端（即平时敲的 docker 命令） Docker 服务端（dockerd 守护进程）。</p>
<p>Docker 客户端通过 REST API 和服务端进行交互，docker 客户端每发送一条指令，底层都会转化成 REST API 调用的形式发送给服务端，服务端处理客户端发送的请求并给出响应。</p>
<p>Docker 镜像的构建、容器创建、容器运行等工作都是 Docker 服务端来完成的，Docker 客户端只是承担发送指令的角色。</p>
<p>Docker 客户端和服务端可以在同一个宿主机，也可以在不同的宿主机，如果在同一个宿主机的话，Docker 客户端默认通过 UNIX 套接字(<code>/var/run/docker.sock</code>)和服务端通信。</p>
<p><img src="/images/docker-architecture.png" alt=""></p>
<h3 id="理解-docker-build-的工作原理"><a href="#理解-docker-build-的工作原理" class="headerlink" title="理解 docker build 的工作原理"></a>理解 docker build 的工作原理</h3><p>理解了 Docker 的架构就很容易理解 <code>docker build</code> 构建镜像的工作原理了。docker build 构建镜像的流程大概如下：</p>
<ul>
<li>执行 <code>docker build -t &lt;imageName:imageTag&gt; .</code> ;</li>
<li>Docker 客户端会将构建命令后面指定的路径(<code>.</code>)下的所有文件打包成一个 tar 包，发送给 Docker 服务端;</li>
<li>Docker 服务端收到客户端发送的 tar 包，然后解压，根据 Dockerfile 里面的指令进行镜像的分层构建；</li>
</ul>
<h3 id="正确理解-Docker-构建上下文"><a href="#正确理解-Docker-构建上下文" class="headerlink" title="正确理解 Docker 构建上下文"></a>正确理解 Docker 构建上下文</h3><p>了解了 Docker 的架构和镜像构建的工作原理后，Docker 构建上下文也就容易理解了。Docker 构建上下文就是 Docker 客户端上传给服务端的 tar 文件解压后的内容，也即 <code>docker build</code>  命令行后面指定路径下的文件。</p>
<p>Docker 镜像的构建是在远程服务端进行的，所以客户端需要把构建所需要的文件传输给服务端。服务端以客户端发送的文件为上下文，<em>也就是说 Dockerfile 中指令的工作目录就是服务端解压客户端传输的 tar 包的路径</em>。</p>
<p>关于 <code>docker build</code> 指令的几点重要的说明：</p>
<ol>
<li>如果构建镜像时没有明确指定 Dockerfile，那么 Docker 客户端默认在构建镜像时指定的上下文路径下找名字为 Dockerfile 的构建文件；</li>
<li>Dockerfile 可以不在构建上下文路径下，此时需要构建时通过 <code>-f</code> 参数明确指定使用哪个构建文件，并且名称可以自己任意命名。</li>
</ol>
<p>下面通过具体的实例来理解下:</p>
<p>首先创建一个简单的 demo 工程，工程结构如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">helloworld-app</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── docker</span><br><span class="line">    ├── app-1.0-SNAPSHOT.jar</span><br><span class="line">    ├── hello.txt</span><br><span class="line">    └── html</span><br><span class="line">        └── index.html</span><br></pre></td></tr></table></figure></p>
<p>Dockerfile 内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">COPY hello.txt .</span><br><span class="line">COPY html/index.html .</span><br></pre></td></tr></table></figure></p>
<p>实践1：直接进入 helloworld-app 目录进行镜像构建，以 docker 目录为构建上下文：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t hello-app:1.0 docker</span><br><span class="line">unable to prepare context: unable to evaluate symlinks <span class="keyword">in</span> Dockerfile path: lstat /Users/haohao/opensource/helloworld-app/docker/Dockerfile: no such file or directory</span><br></pre></td></tr></table></figure></p>
<p>可以看出默认 docker 客户端从 docker 构建上下文路径下找名字为 Dockerfile 的构建文件。</p>
<p>实践2：明确指定 Dockerfile 文件进行镜像构建，还是以 docker 目录为构建上下文：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -f Dockerfile -t hello-app:1.0 docker                                                                                 </span><br><span class="line">Sending build context to Docker daemon  96.61MB</span><br><span class="line">Step 1/3 : FROM busybox</span><br><span class="line"> ---&gt; d8233ab899d4</span><br><span class="line">Step 2/3 : COPY hello.txt .</span><br><span class="line"> ---&gt; 3305fc373120</span><br><span class="line">Step 3/3 : COPY html/index.html .</span><br><span class="line"> ---&gt; efdefc4e6eb2</span><br><span class="line">Successfully built efdefc4e6eb2</span><br><span class="line">Successfully tagged hello-app:1.0</span><br></pre></td></tr></table></figure></p>
<p>从输出结果可以得知：</p>
<ul>
<li>构建镜像时客户端会先给服务端发送构建上下路径下的内容（即 docker 目录下的文件）；</li>
<li>Dockerfile 可以不在构建上下文路径下；</li>
<li>Dockerfile 中指令的工作目录是服务端解压客户端传输的 tar 包的路径；</li>
</ul>
<p>实践3：以当前目录为构建上下文路径：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ls</span><br><span class="line">Dockerfile docker</span><br><span class="line">$ docker build -t hello-app:2.0 .</span><br><span class="line">Sending build context to Docker daemon  96.62MB</span><br><span class="line">Step 1/3 : FROM busybox</span><br><span class="line"> ---&gt; d8233ab899d4</span><br><span class="line">Step 2/3 : COPY hello.txt .</span><br><span class="line">COPY failed: <span class="built_in">stat</span> /var/lib/docker/tmp/docker-builder375982663/hello.txt: no such file or directory</span><br></pre></td></tr></table></figure></p>
<p>可以看出：</p>
<ul>
<li>镜像构建上下文路径并不是  Dockerfile 文件所在的路径；</li>
<li>Dockerfile 中指令的工作目录是服务端解压客户端传输的 tar 包的路径，因为 COPY 指令失败了，意味着当前目录并没有 hello.txt 文件；</li>
</ul>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/build/</a><br><a href="https://yeasy.gitbooks.io/docker_practice/content/image/build.html" target="_blank" rel="noopener">https://yeasy.gitbooks.io/docker_practice/content/image/build.html</a></p>
]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 进程树查看工具 pstree]]></title>
      <url>/2019/02/16/Linux-%E8%BF%9B%E7%A8%8B%E6%A0%91%E6%9F%A5%E7%9C%8B%E5%B7%A5%E5%85%B7-pstree/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="http://psmisc.sourceforge.net/" target="_blank" rel="noopener">pstree</a> 是 Linux 下的一个用于展示进程树结构的工具，类似于 <a href="https://linux.die.net/man/1/tree" target="_blank" rel="noopener">tree</a> 展示目录树一样，可视化地查看进程的继承关系。pstree 工具其实是 <a href="http://psmisc.sourceforge.net/" target="_blank" rel="noopener">PSmisc 工具集</a>的成员之一，PSmisc 工具集由 4 个实用的 Linux 进程管理工具（通过 Linux 的 /proc 文件系统实现）组成：</p>
<ul>
<li><em>fuser</em> - identifies what processes are using files.</li>
<li><em>killall</em> - kills a process by its name, similar to a pkill found in some other Unices.</li>
<li><em>pstree</em> - Shows currently running processes in a tree format.</li>
<li><em>peekfd</em> - Peek at file descriptors of running processes.</li>
</ul>
<blockquote>
<p><strong>pstree 带来的方便之处:</strong><br>一条命令就可以很轻松地追溯某个进程的继承关系，再也不需要通过多次执行 <code>ps -ef</code> 一级一级的查看进程的继承关系。</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="On-Fedora-Red-Hat-CentOS"><a href="#On-Fedora-Red-Hat-CentOS" class="headerlink" title="On Fedora/Red Hat/CentOS"></a>On Fedora/Red Hat/CentOS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y psmisc</span><br></pre></td></tr></table></figure>
<h4 id="On-Mac-OS"><a href="#On-Mac-OS" class="headerlink" title="On Mac OS"></a>On Mac OS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install pstree</span><br></pre></td></tr></table></figure>
<h4 id="On-Ubuntu-Debian-APT"><a href="#On-Ubuntu-Debian-APT" class="headerlink" title="On Ubuntu/Debian APT"></a>On Ubuntu/Debian APT</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install psmisc</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><code>pstree [选项]</code></p>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><blockquote>
<p>-a：显示每个程序的完整指令，包含路径，参数或是常驻服务的标示；<br>-c：不使用精简标示法；<br>-G：使用VT100终端机的列绘图字符；<br>-h：列出树状图时，特别标明现在执行的程序；<br>-H&lt;程序识别码&gt;：此参数的效果和指定”-h”参数类似，但特别标明指定的程序；<br>-l：采用长列格式显示树状图；<br>-n：用程序识别码排序。预设是以程序名称来排序；<br>-p：显示程序识别码；<br>-u：显示用户名称；<br>-U：使用UTF-8列绘图字符；<br>-V：显示版本信息。</p>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li><p>显示 PID 为 2858 进程的进程树;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker ~]$ pstree 2858</span><br><span class="line">dockerd─┬─2*[docker-proxy───4*[&#123;docker-proxy&#125;]]</span><br><span class="line">        └─9*[&#123;dockerd&#125;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示 PID 为 2858 进程的进程树，同时列出每个进程的 pid;<br><em>注意：可以观察出，大括号括起来的为线程！</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker ~]$ pstree -p 2858</span><br><span class="line">dockerd(2858)─┬─docker-proxy(4378)─┬─&#123;docker-proxy&#125;(4379)</span><br><span class="line">              │                    ├─&#123;docker-proxy&#125;(4380)</span><br><span class="line">              │                    ├─&#123;docker-proxy&#125;(4381)</span><br><span class="line">              │                    └─&#123;docker-proxy&#125;(4382)</span><br><span class="line">              ├─docker-proxy(6582)─┬─&#123;docker-proxy&#125;(6583)</span><br><span class="line">              │                    ├─&#123;docker-proxy&#125;(6585)</span><br><span class="line">              │                    ├─&#123;docker-proxy&#125;(6586)</span><br><span class="line">              │                    └─&#123;docker-proxy&#125;(6587)</span><br><span class="line">              ├─&#123;dockerd&#125;(2997)</span><br><span class="line">              ├─&#123;dockerd&#125;(2998)</span><br><span class="line">              ├─&#123;dockerd&#125;(2999)</span><br><span class="line">              ├─&#123;dockerd&#125;(3000)</span><br><span class="line">              ├─&#123;dockerd&#125;(3222)</span><br><span class="line">              ├─&#123;dockerd&#125;(3223)</span><br><span class="line">              ├─&#123;dockerd&#125;(3224)</span><br><span class="line">              ├─&#123;dockerd&#125;(4480)</span><br><span class="line">              └─&#123;dockerd&#125;(4493)</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示 PID 为 2858 进程的进程树，同时列出每个进程的 pid 和启动进程的命令行;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@docker ~]$ pstree -p 2858 -a</span><br><span class="line">dockerd,2858 -H fd://</span><br><span class="line">  ├─docker-proxy,4378 -proto tcp -host-ip 0.0.0.0 -host-port 3306 -container-ip 172.17.0.2 -container-port 3306</span><br><span class="line">  │   ├─&#123;docker-proxy&#125;,4379</span><br><span class="line">  │   ├─&#123;docker-proxy&#125;,4380</span><br><span class="line">  │   ├─&#123;docker-proxy&#125;,4381</span><br><span class="line">  │   └─&#123;docker-proxy&#125;,4382</span><br><span class="line">  ├─docker-proxy,6582 -proto tcp -host-ip 0.0.0.0 -host-port 8080 -container-ip 172.17.0.3 -container-port 80</span><br><span class="line">  │   ├─&#123;docker-proxy&#125;,6583</span><br><span class="line">  │   ├─&#123;docker-proxy&#125;,6585</span><br><span class="line">  │   ├─&#123;docker-proxy&#125;,6586</span><br><span class="line">  │   └─&#123;docker-proxy&#125;,6587</span><br><span class="line">  ├─&#123;dockerd&#125;,2997</span><br><span class="line">  ├─&#123;dockerd&#125;,2998</span><br><span class="line">  ├─&#123;dockerd&#125;,2999</span><br><span class="line">  ├─&#123;dockerd&#125;,3000</span><br><span class="line">  ├─&#123;dockerd&#125;,3222</span><br><span class="line">  ├─&#123;dockerd&#125;,3223</span><br><span class="line">  ├─&#123;dockerd&#125;,3224</span><br><span class="line">  ├─&#123;dockerd&#125;,4480</span><br><span class="line">  └─&#123;dockerd&#125;,4493</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接执行 <code>pstree</code> 默认列出整个系统的进程树;</p>
</li>
</ol>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="http://man.linuxde.net/pstree" target="_blank" rel="noopener">http://man.linuxde.net/pstree</a><br><a href="http://psmisc.sourceforge.net" target="_blank" rel="noopener">http://psmisc.sourceforge.net</a><br><a href="https://www.wikiwand.com/en/Pstree" target="_blank" rel="noopener">https://www.wikiwand.com/en/Pstree</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 启动 MySQL 最佳实践]]></title>
      <url>/2019/01/27/Docker-%E5%90%AF%E5%8A%A8-MySQL-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p>本文主要介绍使用 Docker 启动 MySQL 服务的最佳实践，Docker 镜像来自 <a href="https://hub.docker.com/_/mysql" target="_blank" rel="noopener">docker 官方镜像</a>。</p>
<h3 id="启动一个-MySql-5-7-实例"><a href="#启动一个-MySql-5-7-实例" class="headerlink" title="启动一个 MySql 5.7 实例"></a>启动一个 MySql 5.7 实例</h3><p>关于版本的选择，修改镜像 tag 即可，支持的 tag 在 <a href="https://hub.docker.com/_/mysql" target="_blank" rel="noopener">docker hub 仓库</a> 有说明。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql5.<span class="number">7</span> --restart always -p <span class="number">3306</span>:<span class="number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="number">12345</span> \</span><br><span class="line">-v /home/vagrant/mysql5.<span class="number">7</span>/<span class="symbol">data:</span>/var/<span class="class"><span class="keyword">lib</span>/<span class="title">mysql</span> -<span class="title">d</span> <span class="title">mysql</span>:5.7</span></span><br></pre></td></tr></table></figure></p>
<p>参数说明</p>
<ul>
<li><code>--name mysql5.7</code>: 指定运行容器名称</li>
<li><code>--restart always</code>: 容器意外退出后自动重启</li>
<li><code>-p 3306:3306</code>: 映射主机 3306 端口到容器 3306 端口</li>
<li><code>-e MYSQL_ROOT_PASSWORD=12345</code>: 指定 msyql root 密码，该参数是为必须的</li>
<li><code>-v /home/vagrant/mysql5.7/data:/var/lib/mysql</code>: mysql 数据持久化，主机 /home/vagrant/mysql5.7/data 目录挂载到容器 /var/lib/mysql 目录</li>
</ul>
<h3 id="连接-MySql"><a href="#连接-MySql" class="headerlink" title="连接 MySql"></a>连接 MySql</h3><p>mysql 容器连接服务端：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">run</span> -<span class="keyword">it</span> <span class="comment">--rm mysql:5.7 mysql -hxxx -uxxx -p***</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：如果在 mysql server 端所在的主机连接，-h 参数不能是 localhost，应该为主机所在的内网 ip。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> MySQL </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis 常用命令总结]]></title>
      <url>/2019/01/19/Redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="Redis-常用命令总结"><a href="#Redis-常用命令总结" class="headerlink" title="Redis 常用命令总结"></a>Redis 常用命令总结</h2><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><p>redis-cli 是 redis 的客户端工具，有很多实用的参数。</p>
<p><img src="/images/redis-cli.png" alt=""></p>
<h3 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h3><p>redis-benchmark 为 redis 提供的性能测试工具，对 redis 各种数据的操作进行测试，并给出测试结果。如下为 GET 操作的测试报告样例：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">====== GET ======</span><br><span class="line"> <span class="number"> 20000 </span>requests completed in 0.36 seconds</span><br><span class="line"> <span class="number"> 100 </span>parallel clients</span><br><span class="line"> <span class="number"> 3 </span>bytes payload</span><br><span class="line">  keep alive: 1</span><br><span class="line"></span><br><span class="line">62.01% &lt;=<span class="number"> 1 </span>milliseconds</span><br><span class="line">97.57% &lt;=<span class="number"> 2 </span>milliseconds</span><br><span class="line">99.99% &lt;=<span class="number"> 3 </span>milliseconds</span><br><span class="line">100.00% &lt;=<span class="number"> 3 </span>milliseconds</span><br><span class="line">55865.92 requests per second</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/redis-benchmark.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 Docker Compose 容器化搭建 Wordpress]]></title>
      <url>/2019/01/14/%E5%9F%BA%E4%BA%8E-Docker-Compose-%E5%AE%B9%E5%99%A8%E5%8C%96%E6%90%AD%E5%BB%BA-Wordpress/</url>
      <content type="html"><![CDATA[<p>最近由于业务需求帮公司搞了几个 Wordpress 作为官网，中间也是踩了不少坑，倒不是搭建 wordpress 难，主要是 wordpress 本身坑就挺多的，比如迁移、使用过程中文件上传大小的限制问题、迁移后域名无法变更问题等等。</p>
<p>接下来演示如何基于 Docker Compose 来容器化搭建一个可靠、易维护的 Wordpress 网站，可靠指的是服务挂了会自愈（当然是 docker 本身的功能了），易维护指的是即使后面做服务的迁移也是非常方便的，只是简单的文件拷贝，然后 docker compose 启动，没有任何其他的维护成本。</p>
<p><strong>架构</strong>：非容器化 nginx 反向代理 + Docker Compose （ Wordpress + MySql）</p>
<p><img src="/images/nginx-wordpress-docker.png" alt=""></p>
<h3 id="Docker-Compose-工程"><a href="#Docker-Compose-工程" class="headerlink" title="Docker Compose 工程"></a>Docker Compose 工程</h3><p>Wordpress Docker Compose 工程目录结构：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wordpress</span><br><span class="line">├── db_data  # mysql 数据目录</span><br><span class="line">├── docker-compose.yaml  # docker-compose 文件</span><br><span class="line">├── upload.ini  # php 文件上传相关配置</span><br><span class="line">└── wp_site  # wordpress 静态资源存储目录</span><br></pre></td></tr></table></figure></p>
<p>docker-compose.yaml:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.3'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">   db:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">./db_data:/var/lib/mysql</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line"><span class="attr">       MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_PASSWORD:</span> <span class="string">example</span></span><br><span class="line"></span><br><span class="line"><span class="attr">   wordpress:</span></span><br><span class="line"><span class="attr">     depends_on:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">db</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">wordpress:5.0.3</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">./wp_site:/var/www/html</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">./uploads.ini:/usr/local/etc/php/conf.d/uploads.ini</span></span><br><span class="line"><span class="attr">     ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"9000:80"</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_HOST:</span> <span class="attr">db:3306</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_PASSWORD:</span> <span class="string">example</span></span><br></pre></td></tr></table></figure></p>
<p>uploads.ini:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">file_uploads</span> <span class="string">=</span> <span class="string">On</span></span><br><span class="line"><span class="string">memory_limit</span> <span class="string">=</span> <span class="number">128</span><span class="string">M</span></span><br><span class="line"><span class="string">upload_max_filesize</span> <span class="string">=</span> <span class="number">512</span><span class="string">M</span></span><br><span class="line"><span class="string">post_max_size</span> <span class="string">=</span> <span class="number">128</span><span class="string">M</span></span><br><span class="line"><span class="string">max_execution_time</span> <span class="string">=</span> <span class="number">600</span></span><br></pre></td></tr></table></figure></p>
<h3 id="外部-Nginx-配置文件"><a href="#外部-Nginx-配置文件" class="headerlink" title="外部 Nginx  配置文件"></a>外部 Nginx  配置文件</h3><p>https_server.conf（网站配置文件）:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>      <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> example.com;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span>  https://<span class="variable">$host</span><span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>      <span class="number">443</span>;</span><br><span class="line">        <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">ssl_certificate</span> crts/example/example_com.crt;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span> crts/example/example_com.key;</span><br><span class="line">        <span class="attribute">server_name</span> example.com;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span>   http://localhost:9002;</span><br><span class="line">                <span class="attribute">include</span> conf.d/common.cfg;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Forwarded-Proto https;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>common.cfg（Nginx 相关配置项）:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_set_header</span>   Host             <span class="variable">$host</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span>   X-Real-IP        <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="attribute">proxy_set_header</span>  X-Forwarded-For  <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"><span class="attribute">client_max_body_size</span>       <span class="number">128m</span>;</span><br><span class="line"><span class="attribute">client_body_buffer_size</span>    <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">client_body_temp_path</span>      /tmp/client_body_temp;</span><br><span class="line"><span class="attribute">proxy_connect_timeout</span>      <span class="number">40</span>;</span><br><span class="line"><span class="attribute">proxy_send_timeout</span>         <span class="number">20</span>;</span><br><span class="line"><span class="attribute">proxy_read_timeout</span>         <span class="number">20</span>;</span><br><span class="line"><span class="attribute">proxy_buffer_size</span>          <span class="number">256k</span>;</span><br><span class="line"><span class="attribute">proxy_buffers</span>              <span class="number">32</span> <span class="number">64k</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>进入 docker compose 工程目录执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>相关 docker compose 指令：<br><code>docker-compose stop</code>: 停止已启动的服务，停止后容器还在，只是退出了；<br><code>docker-compose start</code>: 启动已停止的服务；<br><code>docker-compose down</code>: 停止并清理掉启动的 Docker 容器、卷、网络等相关资源；<br><code>docker-compose logs -f</code>: 实时查看日志</p>
]]></content>
      
        <categories>
            
            <category> Wordpress </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Wordpress </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[构建 Docker 镜像上传到 docker hub]]></title>
      <url>/2019/01/13/%E6%9E%84%E5%BB%BA-Docker-%E9%95%9C%E5%83%8F%E4%B8%8A%E4%BC%A0%E5%88%B0-docker-hub/</url>
      <content type="html"><![CDATA[<p>本文演示如何将自己构建的 Docker 镜像推送到 <a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a>来实现镜像的共享。</p>
<ol>
<li>注册一个 docker hub 账号<br>举例：账号名为 qhh0205</li>
<li><p>写一个 Dockerfile<br>举例：该 Dockerfile 安装了指定版本的 ant 和 jmeter，GitHub 仓库地址：<a href="https://github.com/qhh0205/docker-ant-jmeter" target="_blank" rel="noopener">https://github.com/qhh0205/docker-ant-jmeter</a></p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">FROM <span class="symbol">openjdk:</span><span class="number">8</span></span><br><span class="line">MAINTAINER qhh0205 &lt;qhh0205<span class="variable">@gmail</span>.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ant default version: 1.10.5</span></span><br><span class="line"><span class="comment"># jmeter default version: 5.0</span></span><br><span class="line"><span class="comment"># Specify version by docker build --build-arg &lt;varname&gt;=&lt;value&gt; ...</span></span><br><span class="line"></span><br><span class="line">ARG ANT_VERSION=<span class="number">1.10</span>.<span class="number">5</span></span><br><span class="line">ENV ANT_HOME=<span class="regexp">/opt/ant</span></span><br><span class="line"></span><br><span class="line">ARG JMETER_VERSION=<span class="number">5.0</span></span><br><span class="line">ENV JMETER_HOME /opt/jmeter</span><br><span class="line"></span><br><span class="line">RUN apt-get -y update &amp;&amp; \</span><br><span class="line">apt-get -y install wget</span><br><span class="line"></span><br><span class="line"><span class="comment"># Installs Ant</span></span><br><span class="line">RUN wget --no-check-certificate --no-cookies <span class="symbol">http:</span>/<span class="regexp">/archive.apache.org/dist</span><span class="regexp">//ant</span><span class="regexp">/binaries/apache</span>-ant-<span class="variable">$&#123;</span>ANT_VERSION&#125;-bin.tar.gz \</span><br><span class="line">&amp;&amp; tar -zvxf apache-ant-<span class="variable">$&#123;</span>ANT_VERSION&#125;-bin.tar.gz -C /opt/ \</span><br><span class="line">&amp;&amp; ln -s /opt/apache-ant-<span class="variable">$&#123;</span>ANT_VERSION&#125; /opt/ant \</span><br><span class="line">&amp;&amp; rm -f apache-ant-<span class="variable">$&#123;</span>ANT_VERSION&#125;-bin.tar.gz</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$&#123;</span>PATH&#125;<span class="symbol">:/opt/ant/bin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Installs Jmeter</span></span><br><span class="line">RUN wget --no-check-certificate --no-cookies <span class="symbol">https:</span>/<span class="regexp">/archive.apache.org/dist</span><span class="regexp">//jmeter</span><span class="regexp">/binaries/apache</span>-jmeter-<span class="variable">$&#123;</span>JMETER_VERSION&#125;.tgz \</span><br><span class="line">&amp;&amp; tar -zvxf apache-jmeter-<span class="variable">$&#123;</span>JMETER_VERSION&#125;.tgz -C /opt/ \</span><br><span class="line">&amp;&amp; ln -s /opt/apache-jmeter-<span class="variable">$&#123;</span>JMETER_VERSION&#125; /opt/jmeter \</span><br><span class="line">&amp;&amp; rm -f apache-jmeter-<span class="variable">$&#123;</span>JMETER_VERSION&#125;.tgz</span><br><span class="line"></span><br><span class="line">ENV PATH <span class="variable">$PATH</span><span class="symbol">:/opt/jmeter/bin</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像<br>进入 Dockerfile 所在目录，执行构建命令:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> <span class="keyword">build </span>-t qhh0205/ant-jmeter:<span class="number">1</span>.<span class="number">10</span>.<span class="number">5</span>-<span class="number">5</span>.<span class="number">0</span> .</span><br></pre></td></tr></table></figure>
<p> 参数说明：<br> <code>qhh0205/ant-jmeter:1.10.5-5.0</code>: docker 镜像 tag 名称<br> <code>qhh0205</code>: docker hub 账号名<br> <code>ant-jmeter</code>: dcoker hub 仓库名<br> <code>1.10.5-5.0</code>: 镜像 tag</p>
</li>
<li><p>登陆 docker hub 账号</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker login</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>上传镜像</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">push</span> qhh0205/ant-jmeter:<span class="number">1.10</span><span class="meta">.5</span>-<span class="number">5.0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Docker </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 Ansible 统计服务器资源利用率]]></title>
      <url>/2019/01/10/%E4%BD%BF%E7%94%A8-Ansible-%E7%BB%9F%E8%AE%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E5%88%A9%E7%94%A8%E7%8E%87/</url>
      <content type="html"><![CDATA[<p>分享一个 ansible playbook，统计服务器 CPU、内存、磁盘利用率，3 条 shell 脚本实现统计:</p>
<p>CPU 利用率统计：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -bn1 | grep load | awk <span class="string">'&#123;printf "CPU Load: %.2f\n", $(NF-2)&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>内存利用率统计：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -m | awk <span class="string">'NR==2&#123;printf "Memory Usage: %s/%sMB (%.2f%%)\n", $3,$2,$3*100/$2 &#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>磁盘利用率统计（列出每块磁盘利用率）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h -t ext2 -t ext4 | grep -vE <span class="string">'^Filesystem|tmpfs|cdrom'</span> | awk <span class="string">'&#123; print "Disk Usage:"" " $1 " " $3"/"$2" ""("$5")"&#125;'</span></span><br></pre></td></tr></table></figure></p>
<p>Ansible playbook: <code>server-cpu-mem-disk-usage.yml</code><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Statistics</span> <span class="string">CPU</span> <span class="string">Memory</span> <span class="string">Disk</span> <span class="string">Utilization</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">"<span class="template-variable">&#123;&#123; hosts &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  become:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">  remote_user:</span> <span class="string">"<span class="template-variable">&#123;&#123; user &#125;&#125;</span>"</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">no</span></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">"Statistics CPU Memory Disk Utilization..."</span></span><br><span class="line"><span class="attr">      shell:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        free -m | awk 'NR==2&#123;printf "Memory Usage: %s/%sMB (%.2f%%)\n", $3,$2,$3*100/$2 &#125;'</span></span><br><span class="line"><span class="string">        df -h -t ext2 -t ext4 | grep -vE '^Filesystem|tmpfs|cdrom' | awk '&#123; print "Disk Usage:"" " $1 " " $3"/"$2" ""("$5")"&#125;'</span></span><br><span class="line"><span class="string">        top -bn1 | grep load | awk '&#123;printf "CPU Load: %.2f\n", $(NF-2)&#125;'</span></span><br><span class="line"><span class="string"></span><span class="attr">      register:</span> <span class="string">out</span></span><br><span class="line"><span class="attr">    - debug:</span> <span class="string">var=out.stdout_lines</span></span><br></pre></td></tr></table></figure></p>
<p>输出结果样例：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ok: [gke-test-standard-pool] =&gt; &#123;</span><br><span class="line">    "out.stdout_lines": [</span><br><span class="line">        "Memory Usage: 8766/16052MB (54.61%)",</span><br><span class="line">        "Disk Usage: /dev/root 449M/1.2G (37%)",</span><br><span class="line">        "Disk Usage: /dev/sda8 28K/12M (1%)",</span><br><span class="line">        "Disk Usage: /dev/sda1 61G/95G (64%)",</span><br><span class="line">        <span class="string">"CPU Load: 0.92"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Ansible </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ansible </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于谷歌云 gcp 的动态 Ansible inventory 实践]]></title>
      <url>/2019/01/09/%E5%9F%BA%E4%BA%8E%E8%B0%B7%E6%AD%8C%E4%BA%91-gcp-%E7%9A%84%E5%8A%A8%E6%80%81-Ansible-inventory-%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h3 id="关于-Ansible-inventory-说明"><a href="#关于-Ansible-inventory-说明" class="headerlink" title="关于 Ansible inventory 说明"></a>关于 Ansible inventory 说明</h3><p>ansible inventory 文件可以分为如下两类：</p>
<ol>
<li>静态 inventory：主机信息写死到文件，这种情况一般适用于管理少量主机，对于成百上千规模的主机人工管理主机清单文件显然是不合理的；</li>
<li>动态 inventory：ansible 根据脚本动态获取云提供商的主机清单文件，这样可以省去人工维护静态清单文件的繁琐工作，对于大批量主机管理也是非常可靠的；</li>
</ol>
<h3 id="Ansible-动态获取云提供商主机-inventory-原理"><a href="#Ansible-动态获取云提供商主机-inventory-原理" class="headerlink" title="Ansible 动态获取云提供商主机 inventory 原理"></a>Ansible 动态获取云提供商主机 inventory 原理</h3><p>ansible 通过 <code>-i</code> 参数指定动态 inventory 目录，该目录底下放置获取云提供商主机清单的脚本（ansible 社区提供的一般是 Python 脚本），ansible 在执行时该脚本会自动执行并将结果保存到内存中。</p>
<p>那么上面说的获取云提供商主机清单的可执行脚本在哪里获取呢？在 <a href="https://github.com/ansible/ansible/tree/devel/contrib/inventory" target="_blank" rel="noopener">这里</a> （ansible 官方源码仓库：社区提供的脚本）获取，这里有各个云提供商对应的主机清单脚本(*.py)及配置文件(*.ini)，比如谷歌的 <code>gce.py</code> 和 <code>gce.ini</code>，Aws 的 <code>ec2.py</code> 和 <code>ec2.ini</code> 等等。</p>
<h3 id="基于-gcp-的动态-inventory-使用"><a href="#基于-gcp-的动态-inventory-使用" class="headerlink" title="基于 gcp 的动态 inventory 使用"></a>基于 gcp 的动态 inventory 使用</h3><p>下面是配置使用谷歌云动态 ansible inventory 的详细步骤</p>
<ol>
<li><p>相关软件包安装;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install apache-libcloud pycrypto</span><br></pre></td></tr></table></figure>
</li>
<li><p>谷歌云控制台创建一个服务账号（需要有 gce 的访问权限），获取 json 认证文件;</p>
</li>
<li><p>从 <a href="https://github.com/ansible/ansible/tree/devel/contrib/inventory" target="_blank" rel="noopener">ansible 官方仓库</a> 下载 <code>gce.py</code> 和 <code>gce.ini</code> 文件;</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p inventories/gcp-dynamic-inventory</span><br><span class="line"><span class="built_in">cd</span> inventories/gcp-dynamic-inventory</span><br><span class="line">wget https://github.com/ansible/ansible/blob/devel/contrib/inventory/gce.py</span><br><span class="line">wget https://github.com/ansible/ansible/blob/devel/contrib/inventory/gce.ini</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑 <code>gce.ini</code> 配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[gce]</span><br><span class="line">libcloud_secrets =</span><br><span class="line">gce_service_account_email_address = &lt;服务账号邮箱：在第 2 步的 json 认证文件里面可以找到&gt;</span><br><span class="line">gce_service_account_pem_file_path = &lt;第 2 步中 json 认证文件路径：绝对路径&gt;</span><br><span class="line">gce_project_id = &lt;gcp 项目 id&gt;</span><br><span class="line">gce_zone =</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试配置的正确性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果输出一个很长的 json 串表示没问题</span></span><br><span class="line">./gce.py --list</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 ansible 任务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible -i inventories/gcp-dynamic-inventory &lt;pattern&gt; -m &lt;module_name&gt; -a <span class="string">'module_args'</span></span><br><span class="line"></span><br><span class="line">Ex:</span><br><span class="line">  <span class="comment"># 查看 asia-east1-a 区域的所有主机时间</span></span><br><span class="line">  ansible -i inventories/gcp-dynamic-inventory asia-east1<span class="_">-a</span> -m shell -a <span class="string">'date'</span></span><br></pre></td></tr></table></figure>
<p> <strong>参数说明：</strong><br> <code>inventories/gcp-dynamic-inventory</code>:  gce.py 脚本所在的目录，ansible 运行时会自动在该目录下执行该脚本获取主机清单；</p>
<p> <code>pattern</code>：./gce.py –list 执行结果的 json 顶级节点都可以作为 ansible 的目标主机；</p>
<p> 最佳实践：可以给 gce 主机添加 tag，然后通过 tag 对主机分组；</p>
</li>
<li><p><code>gce.ini</code> 文件位置<br><code>gce.ini</code> 文件没必要必须和 <code>gce.py</code> 在一个目录，可以设置环境变量放到系统其他目录，这样就可以将配置和脚本分离，避免敏感配置放到代码仓库。设置方法：<code>~/.bashrc</code> 文件添加如下内容:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[ -s <span class="string">"<span class="variable">$HOME</span>/.ansible/gce.ini"</span> ]] &amp;&amp; <span class="built_in">export</span> GCE_INI_PATH=<span class="string">"<span class="variable">$HOME</span>/.ansible/gce.ini"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>  ansible 执行时可以通过 <code>--list-host</code> 参数先测试下本次操作影响到哪些主机，不会真正执行 task；</p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://temikus.net/ansible-gcp-dynamic-inventory-bootstrap" target="_blank" rel="noopener">https://temikus.net/ansible-gcp-dynamic-inventory-bootstrap</a></p>
<p><a href="https://medium.com/vimeo-engineering-blog/orchestrating-gce-instances-with-ansible-d825a33793cd" target="_blank" rel="noopener">https://medium.com/vimeo-engineering-blog/orchestrating-gce-instances-with-ansible-d825a33793cd</a></p>
]]></content>
      
        <categories>
            
            <category> Ansible </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Ansible </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[谷歌云对象存储 gcs 开启日志记录功能]]></title>
      <url>/2019/01/06/%E8%B0%B7%E6%AD%8C%E4%BA%91%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-gcs-%E5%BC%80%E5%90%AF%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%8A%9F%E8%83%BD/</url>
      <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>有时候我们需要对 gcs 开启日志记录功能，一方面可以分析统计每个针对 gcs 的 http 请求的详细信息，另一方面还可以用于问题调试用途，比如我们对一个存储分区的对象配置了生命周期，可以看其访问日志判断配置是否生效。</p>
<p><strong>gcs 日志记录功能记录两种类型日志</strong></p>
<p>访问日志：访问日志是每小时创建一次，记录对指定存储分区发出的所有请求的信息；<br>存储日志：存储分区过去 24 小时内存储空间平均使用量，以字节为单位；</p>
<p><a href="https://cloud.google.com/storage/docs/access-logs?hl=zh-cn&amp;refresh=1" target="_blank" rel="noopener">https://cloud.google.com/storage/docs/access-logs?hl=zh-cn&amp;refresh=1</a></p>
<h3 id="gcs-开启日志记录功能步骤"><a href="#gcs-开启日志记录功能步骤" class="headerlink" title="gcs 开启日志记录功能步骤"></a>gcs 开启日志记录功能步骤</h3><p>以开启 gs://gcs-bucket 存储分区日志记录功能为例：</p>
<ol>
<li><p>创建一个存储分区用于存储日志记录，名字随便起：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsutil mb -l asia <span class="string">gs:</span><span class="comment">//gcs-bucket-logs-record</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置权限以使 Cloud Storage 对该存储分区具有 WRITE 权限</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsutil acl ch -g cloud-storage-analytics<span class="meta">@google</span>.<span class="string">com:</span>W <span class="string">gs:</span><span class="comment">//gcs-bucket-logs-record</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为存储分区开启日志记录功能<br>命令格式：<code>gsutil logging set on -b &lt;日志存储分区&gt; &lt;要开启日志记录功能的存储分区&gt;</code></p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsutil logging <span class="keyword">set</span> on <span class="comment">-b gs:</span>//<span class="comment">gcs-bucket-logs-record gs:</span>//<span class="comment">gcs-bucket</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>检查日志记录功能是否开启成功</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsutil logging <span class="keyword">get</span> gs:<span class="comment">//gcs-bucket</span></span><br></pre></td></tr></table></figure>
<p> 如果开启成功会显示：<code>{&quot;logBucket&quot;: &quot;gcs-bucket-logs-record&quot;, &quot;logObjectPrefix&quot;: &quot;gcs-bucket&quot;}</code></p>
<p> 另外，开启成功后过 2 小时左右就可以在 gs://gcs-bucket-logs-record 看到日志文件产生了，日志文件格式为 csv。</p>
</li>
<li><p>关闭日志记录功能</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gsutil logging <span class="keyword">set</span> off <span class="comment">gs:</span>//<span class="comment">gcs-bucket</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>日志文件命名格式及日志内容格式见文档详细说明</strong></p>
<p><a href="https://cloud.google.com/storage/docs/access-logs?hl=zh-cn&amp;refresh=1" target="_blank" rel="noopener">https://cloud.google.com/storage/docs/access-logs?hl=zh-cn&amp;refresh=1</a></p>
]]></content>
      
        <categories>
            
            <category> Google Cloud Platform </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Google Cloud Platform </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[非容器化 gitlab 进行容器化改造]]></title>
      <url>/2018/12/02/%E9%9D%9E%E5%AE%B9%E5%99%A8%E5%8C%96-gitlab-%E8%BF%9B%E8%A1%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%94%B9%E9%80%A0/</url>
      <content type="html"><![CDATA[<p>本文主要介绍非容器化（通过 yum 在 Linux 服务器安装）gitlab 进行容器化改造的两种方法，都是基于 Kubernetes 平台，均采用 helm 部署。第一种是基于自建 k8s 平台部署 gitlab，第二种是基于 Google GKE 平台部署 gitlab。</p>
<p>Docker 镜像采用<a href="https://hub.docker.com/r/gitlab/gitlab-ee" target="_blank" rel="noopener">基于 Omnibus 安装包的镜像</a>，gitlab 的各个组件都运行在同一个容器中。关于 GitLab Ominibus 镜像和云原生镜像的区别见<a href="https://docs.gitlab.com/ee/install/docker.html" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="gitlab-容器化改造（基于自建-k8s-平台部署-gitlab）"><a href="#gitlab-容器化改造（基于自建-k8s-平台部署-gitlab）" class="headerlink" title="gitlab 容器化改造（基于自建 k8s 平台部署 gitlab）"></a>gitlab 容器化改造（基于自建 k8s 平台部署 gitlab）</h3><h4 id="一、搭建和原先版本一致的-gitlab"><a href="#一、搭建和原先版本一致的-gitlab" class="headerlink" title="一、搭建和原先版本一致的 gitlab"></a>一、搭建和原先版本一致的 gitlab</h4><p>github helm gitlab-ee chart：<a href="https://github.com/helm/charts/tree/master/stable/gitlab-ee" target="_blank" rel="noopener">https://github.com/helm/charts/tree/master/stable/gitlab-ee</a></p>
<p>在此 helm chart 基础上将备份目录也(/var/opt/gitlab/backups)通过PVC持久化，方便数据的备份恢复: <a href="https://github.com/qhh0205/helm-charts/tree/master/gitlab-ee" target="_blank" rel="noopener">https://github.com/qhh0205/helm-charts/tree/master/gitlab-ee</a></p>
<ol>
<li>手动创建需要的 pv（基于 nfs）<br><a href="https://github.com/qhh0205/kubernetes-resources/tree/master/gitlab-pv" target="_blank" rel="noopener">https://github.com/qhh0205/kubernetes-resources/tree/master/gitlab-pv</a></li>
<li>部署<br>其他自定义参数修改 values-custom.yaml 文件，比如镜像版本、硬件配置等参数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:qhh0205/helm-charts.git</span><br><span class="line"><span class="built_in">cd</span> helm-charts/gitlab-ee</span><br><span class="line">helm install --name gitlab --<span class="built_in">set</span> externalUrl=http://domain/,gitlabRootPassword=xxxx -f values-custom.yaml ./ --namespace=gitlab</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="二、数据恢复"><a href="#二、数据恢复" class="headerlink" title="二、数据恢复"></a>二、数据恢复</h4><ol>
<li>拷贝 gitlab 备份文件到容器外挂nfs目录(/data/nfs/gitlab/gitlab-data-backups（nfs路径）—&gt;/var/opt/gitlab/backups（容器路径）)；</li>
<li>进入容器：<br>kubectl exec -it pod_name /bin/sh -n gitlab </li>
<li>gitlab-ctl reconfigure</li>
<li>chown git:git 1543237967_2018_11_26_10.1.3-ee_gitlab_backup.tar</li>
<li>chown -R git:root /gitlab-data # 由于 gitlab-rake 执行过程中 默认用户名是 git，所以需要把该目录的属主改成 git，否则恢复时报错权限问题；</li>
<li>gitlab-rake gitlab:backup:restore<br>根据提示输入相关信息<br>YES<br>YES<br>gitlab-ctl restart </li>
</ol>
<h3 id="gitlab-容器化改造（基于-Google-云-GKE-平台）"><a href="#gitlab-容器化改造（基于-Google-云-GKE-平台）" class="headerlink" title="gitlab 容器化改造（基于 Google 云 GKE 平台）"></a>gitlab 容器化改造（基于 Google 云 GKE 平台）</h3><h4 id="一、搭建和原先版本一致的-gitlab-1"><a href="#一、搭建和原先版本一致的-gitlab-1" class="headerlink" title="一、搭建和原先版本一致的 gitlab"></a>一、搭建和原先版本一致的 gitlab</h4><p>github helm gitlab-ee chart：<a href="https://github.com/helm/charts/tree/master/stable/gitlab-ee" target="_blank" rel="noopener">https://github.com/helm/charts/tree/master/stable/gitlab-ee</a></p>
<p>在此 helm chart 基础上将备份目录也(/var/opt/gitlab/backups)通过PVC持久化，方便数据的备份恢复:<br><a href="https://github.com/qhh0205/helm-charts/tree/master/gitlab-ee" target="_blank" rel="noopener">https://github.com/qhh0205/helm-charts/tree/master/gitlab-ee</a></p>
<p>其他自定义参数修改 values-custom.yaml 文件，比如镜像版本、硬件配置等参数。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:qhh0205/helm-charts.git</span><br><span class="line"><span class="built_in">cd</span> helm-charts/gitlab-ee</span><br><span class="line">helm install --name gitlab --<span class="built_in">set</span> externalUrl=http://domain/,gitlabRootPassword=xxxx -f values-custom.yaml ./ --namespace=gitlab</span><br></pre></td></tr></table></figure></p>
<h4 id="二、数据迁移恢复"><a href="#二、数据迁移恢复" class="headerlink" title="二、数据迁移恢复"></a>二、数据迁移恢复</h4><ol>
<li><p>将 gitlab 备份文件拷贝到 k8s gitlab pod 容器目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl cp 1543237967_2018_11_26_10.1.3-ee_gitlab_backup.tar \</span><br><span class="line">namespace/pod_name:/var/opt/gitlab/backups -n gitlab</span><br></pre></td></tr></table></figure>
</li>
<li><p>gitlab-ctl reconfigure</p>
</li>
<li>chown git:git 1543237967_2018_11_26_10.1.3-ee_gitlab_backup.tar</li>
<li>chown -R git:root /gitlab-data # 由于 git-rake 执行过程中 默认用户名是 git，所以需要把该目录的属主改成git，否则恢复时报错权限问题；</li>
<li>gitlab-rake gitlab:backup:restore<br>根据提示输入相关信息<br>YES<br>YES<br>gitlab-ctl restart </li>
</ol>
<h3 id="外部访问"><a href="#外部访问" class="headerlink" title="外部访问"></a>外部访问</h3><ol>
<li>Kong Ingress</li>
<li>NodePort</li>
<li>LoadBalancer（云提供商平台，比如 Google GKE）</li>
</ol>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul>
<li>容器化安装 gitlab：<a href="https://docs.gitlab.com/ee/install/docker.html" target="_blank" rel="noopener">https://docs.gitlab.com/ee/install/docker.html</a></li>
<li>gitlab 数据存放目录修改：<a href="https://blog.whsir.com/post-1490.html" target="_blank" rel="noopener">https://blog.whsir.com/post-1490.html</a></li>
<li>gitlab 安装软件和硬件需求：<a href="https://docs.gitlab.com/ce/install/requirements.html" target="_blank" rel="noopener">https://docs.gitlab.com/ce/install/requirements.html</a></li>
<li>Omnibus GitLab documentation: <a href="https://docs.gitlab.com/omnibus/README.html" target="_blank" rel="noopener">https://docs.gitlab.com/omnibus/README.html</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 文件与目录管理相关命令总结]]></title>
      <url>/2018/12/02/Linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p><img src="/images/linux_file_dir_cmd.jpg" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 解析 Spring pom 文件获取 jar 包名称]]></title>
      <url>/2018/11/18/Python-%E8%A7%A3%E6%9E%90-Spring-pom-%E6%96%87%E4%BB%B6%E8%8E%B7%E5%8F%96-jar-%E5%8C%85%E5%90%8D%E7%A7%B0/</url>
      <content type="html"><![CDATA[<p>前段时间在做持续集成有个小需求是根据 pom 文件获取 jar 包名称，在网上搜寻一番，整理了一份脚本，可以直接使用，通过解析 pom 文件获取(xml2pydict.py)：<br>使用示例：<code>python xml2pydict.py pom.xml</code><br>输出结果：jar 包名称<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/10/22 下午5:53</span></span><br><span class="line"><span class="comment"># @Author  : haohao.qiang</span></span><br><span class="line"><span class="comment"># @Mail    : qhh0205@gmail.com</span></span><br><span class="line"><span class="comment"># @File    : xml2pydict.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> xml.parsers <span class="keyword">import</span> expat</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ElementTree</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlListConfig</span><span class="params">(list)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, aList)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> aList:</span><br><span class="line">            <span class="keyword">if</span> element:</span><br><span class="line">                <span class="comment"># treat like dict</span></span><br><span class="line">                <span class="keyword">if</span> len(element) == <span class="number">1</span> <span class="keyword">or</span> element[<span class="number">0</span>].tag != element[<span class="number">1</span>].tag:</span><br><span class="line">                    self.append(XmlDictConfig(element))</span><br><span class="line">                <span class="comment"># treat like list</span></span><br><span class="line">                <span class="keyword">elif</span> element[<span class="number">0</span>].tag == element[<span class="number">1</span>].tag:</span><br><span class="line">                    self.append(XmlListConfig(element))</span><br><span class="line">            <span class="keyword">elif</span> element.text:</span><br><span class="line">                text = element.text.strip()</span><br><span class="line">                <span class="keyword">if</span> text:</span><br><span class="line">                    self.append(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XmlDictConfig</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Example usage:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    tree = ElementTree.parse('your_file.xml')</span></span><br><span class="line"><span class="string">    root = tree.getroot()</span></span><br><span class="line"><span class="string">    xmldict = XmlDictConfig(root)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Or, if you want to use an XML string:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    root = ElementTree.XML(xml_string)</span></span><br><span class="line"><span class="string">    xmldict = XmlDictConfig(root)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    And then use xmldict for what it is... a dict.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, parent_element)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> parent_element.items():</span><br><span class="line">            self.update(dict(parent_element.items()))</span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> parent_element:</span><br><span class="line">            <span class="keyword">if</span> element:</span><br><span class="line">                <span class="comment"># treat like dict - we assume that if the first two tags</span></span><br><span class="line">                <span class="comment"># in a series are different, then they are all different.</span></span><br><span class="line">                <span class="keyword">if</span> len(element) == <span class="number">1</span> <span class="keyword">or</span> element[<span class="number">0</span>].tag != element[<span class="number">1</span>].tag:</span><br><span class="line">                    aDict = XmlDictConfig(element)</span><br><span class="line">                <span class="comment"># treat like list - we assume that if the first two tags</span></span><br><span class="line">                <span class="comment"># in a series are the same, then the rest are the same.</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># here, we put the list in dictionary; the key is the</span></span><br><span class="line">                    <span class="comment"># tag name the list elements all share in common, and</span></span><br><span class="line">                    <span class="comment"># the value is the list itself</span></span><br><span class="line">                    aDict = &#123;element[<span class="number">0</span>].tag: XmlListConfig(element)&#125;</span><br><span class="line">                <span class="comment"># if the tag has attributes, add those to the dict</span></span><br><span class="line">                <span class="keyword">if</span> element.items():</span><br><span class="line">                    aDict.update(dict(element.items()))</span><br><span class="line">                self.update(&#123;element.tag: aDict&#125;)</span><br><span class="line">            <span class="comment"># this assumes that if you've got an attribute in a tag,</span></span><br><span class="line">            <span class="comment"># you won't be having any text. This may or may not be a</span></span><br><span class="line">            <span class="comment"># good idea -- time will tell. It works for the way we are</span></span><br><span class="line">            <span class="comment"># currently doing XML configuration files...</span></span><br><span class="line">            <span class="keyword">elif</span> element.items():</span><br><span class="line">                self.update(&#123;element.tag: dict(element.items())&#125;)</span><br><span class="line">            <span class="comment"># finally, if there are no child tags and no attributes, extract</span></span><br><span class="line">            <span class="comment"># the text</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.update(&#123;element.tag: element.text&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    xml = sys.argv[<span class="number">1</span>]</span><br><span class="line">    oldcreate = expat.ParserCreate</span><br><span class="line">    expat.ParserCreate = <span class="keyword">lambda</span> encoding, sep: oldcreate(encoding, <span class="keyword">None</span>)</span><br><span class="line">    tree = ElementTree.parse(xml)</span><br><span class="line">    root = tree.getroot()</span><br><span class="line">    xmldict = XmlDictConfig(root)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"&#123;&#125;-&#123;&#125;.&#123;&#125;"</span>.format(xmldict.get(<span class="string">'artifactId'</span>), xmldict.get(<span class="string">'version'</span>), xmldict.get(<span class="string">'packaging'</span>))</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 文件权限属性相关总结]]></title>
      <url>/2018/11/18/Linux-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%B1%9E%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="Linux-文件权限属性相关总结"><a href="#Linux-文件权限属性相关总结" class="headerlink" title="Linux 文件权限属性相关总结"></a>Linux 文件权限属性相关总结</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p><img src="/images/linux_file_attr_pem.png" alt=""></p>
<h3 id="文件权限与属性修改"><a href="#文件权限与属性修改" class="headerlink" title="文件权限与属性修改"></a>文件权限与属性修改</h3><ul>
<li>chgrp: 更改文件属组</li>
<li>chown: 更改文件属主</li>
<li>chmod: 更改文件权限，SUID、SGID、SBIT 等属性</li>
</ul>
<h4 id="1-更改文件属组"><a href="#1-更改文件属组" class="headerlink" title="1. 更改文件属组"></a>1. 更改文件属组</h4><p>更改时组名必须存在，即在必须在 <code>/etc/group</code> 文件内存在，否则报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">命令格式: chgrp [-R] group_name dirname/filename ...</span><br><span class="line">选顷参数:</span><br><span class="line">-R : 递归(recursive)更改，即连同子目彔下的所有文件、目录</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 vagrant vagrant 5 Nov 17 19:04 aa</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># chgrp root aa</span></span><br><span class="line">[root@centos7 vagrant]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 vagrant root 5 Nov 17 19:04 aa</span><br></pre></td></tr></table></figure></p>
<h4 id="2-更改文件属主"><a href="#2-更改文件属主" class="headerlink" title="2. 更改文件属主"></a>2. 更改文件属主</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">命令格式: </span><br><span class="line">chown [-R] 账号名称 文件或目彔（只更改属主）</span><br><span class="line">chown [-R] 账号名称:组名 文件或目彔（属主和属组同时更改）</span><br><span class="line">选顷参数:</span><br><span class="line">-R : 递归(recursive)更改，即连同子目彔下的所有文件、目录</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 vagrant root 5 Nov 17 19:04 aa</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># chown root aa</span></span><br><span class="line">[root@centos7 vagrant]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 root root 5 Nov 17 19:04 aa</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># chown vagrant:vagrant aa</span></span><br><span class="line">[root@centos7 vagrant]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 vagrant vagrant 5 Nov 17 19:04 aa</span><br></pre></td></tr></table></figure>
<p><strong>Tips:</strong><br><code>chown</code> 也能修改属组：<code>chown .group_name filename</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 vagrant]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 vagrant vagrant 5 Nov 17 19:04 aa</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># chown .root aa</span></span><br><span class="line">[root@centos7 vagrant]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--. 1 vagrant root 5 Nov 17 19:04 aa</span><br></pre></td></tr></table></figure></p>
<h4 id="3-更改文件权限"><a href="#3-更改文件权限" class="headerlink" title="3. 更改文件权限"></a>3. 更改文件权限</h4><p>更改文件权限使用 chmod 命令，该命令有两种使用方式：以数字或者符号来进行权限的变更。</p>
<ul>
<li><p>数字方式更改</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">命令格式: chmod [-R] xyz 文件或目录</span><br><span class="line">选项参数：</span><br><span class="line">-R: 递归(recursive)更改，即连同子目彔下的所有文件、目录</span><br><span class="line">xyz: 权限数字</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r--.<span class="number"> 1 </span>vagrant root<span class="number"> 5 </span>Nov<span class="number"> 17 </span>19:04 aa</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># chmod 755 aa</span></span><br><span class="line">[root@centos7 vagrant]<span class="comment"># ls -l</span></span><br><span class="line">total 4</span><br><span class="line">-rwxr-xr-x.<span class="number"> 1 </span>vagrant root<span class="number"> 5 </span>Nov<span class="number"> 17 </span>19:04 aa</span><br></pre></td></tr></table></figure>
</li>
<li><p>符号方式更改<br><img src="/images/linux_chmod.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">将文件权限设置为: -rwxr-xr-x</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># chmod u=rwx,g=rx,o=rx aa</span></span><br><span class="line">给所有人赋予文件可写权限</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># chmod a+w aa</span></span><br><span class="line">所在组和其他组人去除可写权限</span><br><span class="line">[root@centos7 vagrant]<span class="comment"># chmod g-x,o-x aa</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文件与目录的权限区别"><a href="#文件与目录的权限区别" class="headerlink" title="文件与目录的权限区别"></a>文件与目录的权限区别</h3><p>Linux 下文件与目录的权限（r、w、x）有很大的不同，具体如下：<br><img src="/images/linux_file_dir_pem.png" alt=""></p>
<h3 id="Linux-FHS-标准"><a href="#Linux-FHS-标准" class="headerlink" title="Linux FHS 标准"></a>Linux FHS 标准</h3><p>Linux FHS（<a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">Filesystem Hierarchy Standard</a>）文一种规范，规范 Linux 各发行版的目录结构，什么目录下该存放什么类型的文件。大概规范如下（其中灰色部分目录不能在系统的不同磁盘设备，因为都是和系统启动有关的，必须在系统盘所在的磁盘）：</p>
<p><img src="/images/linux_fhs.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 Hexo 的 GitHub Pages 配置 CloudFlare CDN]]></title>
      <url>/2018/11/04/%E5%9F%BA%E4%BA%8E-Hexo-%E7%9A%84-GitHub-Pages-%E9%85%8D%E7%BD%AE-CloudFlare-CDN/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>由于 GitHub Pages 在国外，静态博客页面在国内访问速度可能会非常慢，我们可以用 CDN 来加速，对比了下 CloudFlare CDN 和 腾讯云 CDN，发现 CloudFlare 免费版没有流量限制（腾讯云 CDN 每月由流量限制），而且配置起来非常简单，所以在此选用 CloudFlare CDN 来加速页面访问。</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul>
<li>个人域名</li>
<li>CloudFlare 账号</li>
<li>基于 hexo 的 github_username.github.io 静态博客</li>
</ul>
<h3 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h3><ol>
<li>在 Hexo 博客 source 文件夹新建名为 CNAME 的文件，内容为个人域名；</li>
<li><code>hexo g &amp;&amp; hexo d</code> 部署生产的静态页面到 GitHub；</li>
<li>进入 CloudFlare 控制台，点击添加站点，输入个人域名，根据向导进行操作；</li>
<li><p>在 CloudFlare DNS 配置页面配置两个 CNAME 均指向 github_username.github.io 地址：<br>根域名(@) CNAME 到 <code>github_username.github.io</code><br>子域名(www) CNAME 到 <code>github_username.github.io</code></p>
<blockquote>
<p>⚠️注意：其实一般的域名提供商是不支持根域名 CNAME ，只有子域名才可以，但是 CloudFlare 通过 <a href="https://support.cloudflare.com/hc/en-us/articles/200169056-CNAME-Flattening-RFC-compliant-support-for-CNAME-at-the-root" target="_blank" rel="noopener">CNAME Flattening</a> 技术支持这种配置。这么做的好处是我们不需要再一个个添加以 GitHub Pages 的 IP 为值的 A 记录了，同时还能提高后续的可维护性，后续即使 GitHub Pages 的 IP 发生了变化，也不影响，CloudFlare 会通过 <a href="https://support.cloudflare.com/hc/en-us/articles/200169056-CNAME-Flattening-RFC-compliant-support-for-CNAME-at-the-root" target="_blank" rel="noopener">CNAME Flattening</a> 技术 自动解析出来。</p>
</blockquote>
<p> <img src="/images/cloudflare1.png" alt=""></p>
</li>
<li>将个人域名的 NS 记录修改为 CloudFlare 的 NS；</li>
<li>等 CloudFlare DNS 解析生效后，并且 CloudFlare 站点状态为 Active 即表示配置生效。<br><img src="/images/cloudflare2.png" alt=""></li>
</ol>
<h3 id="CloudFlare-CDN-HTTP-强制跳转-HTTPS"><a href="#CloudFlare-CDN-HTTP-强制跳转-HTTPS" class="headerlink" title="CloudFlare CDN HTTP 强制跳转 HTTPS"></a>CloudFlare CDN HTTP 强制跳转 HTTPS</h3><p>默认情况下配置完成后 HTTPS 是开启的，会在 24 小时内给你配的站点颁发 https 证书，并且证书是自动更新的。我们可以在 CloudFlare 控制台配置 HTTP 强制跳转 HTTPS：<br><img src="/images/cloudflare3.png" alt=""><br><img src="/images/cloudflare4.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 Kubernetes 的 Jenkins 主从通信异常解决]]></title>
      <url>/2018/10/14/%E5%9F%BA%E4%BA%8E-Kubernetes-%E7%9A%84-Jenkins-%E4%B8%BB%E4%BB%8E%E9%80%9A%E4%BF%A1%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p><a href="https://qhh0205.github.io/2018/10/14/%E5%9F%BA%E4%BA%8E-Kubernetes-%E7%9A%84%E5%8A%A8%E6%80%81-Jenkins-slave-%E9%83%A8%E7%BD%B2/" target="_blank" rel="noopener">基于 Kubernetes 部署 Jenkins 动态 slave</a> 后，运行 Jenkins Job 会抛java.nio.channels.ClosedChannelException 异常完整的异常栈如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">FATAL: java<span class="selector-class">.nio</span><span class="selector-class">.channels</span><span class="selector-class">.ClosedChannelException</span></span><br><span class="line">java<span class="selector-class">.nio</span><span class="selector-class">.channels</span><span class="selector-class">.ClosedChannelException</span></span><br><span class="line">Also:   hudson<span class="selector-class">.remoting</span><span class="selector-class">.Channel</span><span class="variable">$CallSiteStackTrace</span>: Remote call to JNLP4-connect connection from <span class="number">10.244</span>.<span class="number">8.1</span>/<span class="number">10.244</span>.<span class="number">8.1</span>:<span class="number">55340</span></span><br><span class="line">		at hudson<span class="selector-class">.remoting</span><span class="selector-class">.Channel</span><span class="selector-class">.attachCallSiteStackTrace</span>(Channel<span class="selector-class">.java</span>:<span class="number">1741</span>)</span><br><span class="line">		at hudson<span class="selector-class">.remoting</span><span class="selector-class">.Request</span><span class="selector-class">.call</span>(Request<span class="selector-class">.java</span>:<span class="number">202</span>)</span><br><span class="line">		at hudson<span class="selector-class">.remoting</span><span class="selector-class">.Channel</span><span class="selector-class">.call</span>(Channel<span class="selector-class">.java</span>:<span class="number">954</span>)</span><br><span class="line">		at hudson<span class="selector-class">.FilePath</span><span class="selector-class">.act</span>(FilePath<span class="selector-class">.java</span>:<span class="number">1071</span>)</span><br><span class="line">		at hudson<span class="selector-class">.FilePath</span><span class="selector-class">.act</span>(FilePath<span class="selector-class">.java</span>:<span class="number">1060</span>)</span><br><span class="line">		at hudson<span class="selector-class">.FilePath</span><span class="selector-class">.mkdirs</span>(FilePath<span class="selector-class">.java</span>:<span class="number">1245</span>)</span><br><span class="line">		at hudson<span class="selector-class">.model</span><span class="selector-class">.AbstractProject</span><span class="selector-class">.checkout</span>(AbstractProject<span class="selector-class">.java</span>:<span class="number">1202</span>)</span><br><span class="line">		at hudson<span class="selector-class">.model</span><span class="selector-class">.AbstractBuild</span><span class="variable">$AbstractBuildExecution</span>.defaultCheckout(AbstractBuild<span class="selector-class">.java</span>:<span class="number">574</span>)</span><br><span class="line">		at jenkins<span class="selector-class">.scm</span><span class="selector-class">.SCMCheckoutStrategy</span><span class="selector-class">.checkout</span>(SCMCheckoutStrategy<span class="selector-class">.java</span>:<span class="number">86</span>)</span><br><span class="line">		at hudson<span class="selector-class">.model</span><span class="selector-class">.AbstractBuild</span><span class="variable">$AbstractBuildExecution</span>.run(AbstractBuild<span class="selector-class">.java</span>:<span class="number">499</span>)</span><br><span class="line">		at hudson<span class="selector-class">.model</span><span class="selector-class">.Run</span><span class="selector-class">.execute</span>(Run<span class="selector-class">.java</span>:<span class="number">1819</span>)</span><br><span class="line">		at hudson<span class="selector-class">.model</span><span class="selector-class">.FreeStyleBuild</span><span class="selector-class">.run</span>(FreeStyleBuild<span class="selector-class">.java</span>:<span class="number">43</span>)</span><br><span class="line">		at hudson<span class="selector-class">.model</span><span class="selector-class">.ResourceController</span><span class="selector-class">.execute</span>(ResourceController<span class="selector-class">.java</span>:<span class="number">97</span>)</span><br><span class="line">		at hudson<span class="selector-class">.model</span><span class="selector-class">.Executor</span><span class="selector-class">.run</span>(Executor<span class="selector-class">.java</span>:<span class="number">429</span>)</span><br><span class="line">Caused: hudson<span class="selector-class">.remoting</span><span class="selector-class">.RequestAbortedException</span></span><br><span class="line">	at hudson<span class="selector-class">.remoting</span><span class="selector-class">.Request</span><span class="selector-class">.abort</span>(Request<span class="selector-class">.java</span>:<span class="number">340</span>)</span><br><span class="line">	at hudson<span class="selector-class">.remoting</span><span class="selector-class">.Channel</span><span class="selector-class">.terminate</span>(Channel<span class="selector-class">.java</span>:<span class="number">1038</span>)</span><br><span class="line">	at org<span class="selector-class">.jenkinsci</span><span class="selector-class">.remoting</span><span class="selector-class">.protocol</span><span class="selector-class">.impl</span><span class="selector-class">.ChannelApplicationLayer</span><span class="selector-class">.onReadClosed</span>(ChannelApplicationLayer<span class="selector-class">.java</span>:<span class="number">209</span>)</span><br><span class="line">	at org<span class="selector-class">.jenkinsci</span><span class="selector-class">.remoting</span><span class="selector-class">.protocol</span><span class="selector-class">.ApplicationLayer</span><span class="selector-class">.onRecvClosed</span>(ApplicationLayer<span class="selector-class">.java</span>:<span class="number">222</span>)</span><br><span class="line">	at org<span class="selector-class">.jenkinsci</span><span class="selector-class">.remoting</span><span class="selector-class">.protocol</span><span class="selector-class">.ProtocolStack</span><span class="variable">$Ptr</span>.onRecvClosed(ProtocolStack<span class="selector-class">.java</span>:<span class="number">832</span>)</span><br><span class="line">	at org<span class="selector-class">.jenkinsci</span><span class="selector-class">.remoting</span><span class="selector-class">.protocol</span><span class="selector-class">.FilterLayer</span><span class="selector-class">.onRecvClosed</span>(FilterLayer<span class="selector-class">.java</span>:<span class="number">287</span>)</span><br><span class="line">	at org<span class="selector-class">.jenkinsci</span><span class="selector-class">.remoting</span><span class="selector-class">.protocol</span><span class="selector-class">.impl</span><span class="selector-class">.SSLEngineFilterLayer</span><span class="selector-class">.onRecvClosed</span>(SSLEngineFilterLayer<span class="selector-class">.java</span>:<span class="number">172</span>)</span><br><span class="line">	at org<span class="selector-class">.jenkinsci</span><span class="selector-class">.remoting</span><span class="selector-class">.protocol</span><span class="selector-class">.ProtocolStack</span><span class="variable">$Ptr</span>.onRecvClosed(ProtocolStack<span class="selector-class">.java</span>:<span class="number">832</span>)</span><br><span class="line">	at org<span class="selector-class">.jenkinsci</span><span class="selector-class">.remoting</span><span class="selector-class">.protocol</span><span class="selector-class">.NetworkLayer</span><span class="selector-class">.onRecvClosed</span>(NetworkLayer<span class="selector-class">.java</span>:<span class="number">154</span>)</span><br><span class="line">	at org<span class="selector-class">.jenkinsci</span><span class="selector-class">.remoting</span><span class="selector-class">.protocol</span><span class="selector-class">.impl</span><span class="selector-class">.NIONetworkLayer</span><span class="selector-class">.ready</span>(NIONetworkLayer<span class="selector-class">.java</span>:<span class="number">142</span>)</span><br><span class="line">	at org<span class="selector-class">.jenkinsci</span><span class="selector-class">.remoting</span><span class="selector-class">.protocol</span><span class="selector-class">.IOHub</span><span class="variable">$OnReady</span>.run(IOHub<span class="selector-class">.java</span>:<span class="number">795</span>)</span><br><span class="line">	at jenkins<span class="selector-class">.util</span><span class="selector-class">.ContextResettingExecutorService</span>$<span class="number">1</span>.run(ContextResettingExecutorService<span class="selector-class">.java</span>:<span class="number">28</span>)</span><br><span class="line">	at jenkins<span class="selector-class">.security</span><span class="selector-class">.ImpersonatingExecutorService</span>$<span class="number">1</span>.run(ImpersonatingExecutorService<span class="selector-class">.java</span>:<span class="number">59</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">1149</span>)</span><br><span class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="variable">$Worker</span>.run(ThreadPoolExecutor<span class="selector-class">.java</span>:<span class="number">624</span>)</span><br><span class="line">	at java<span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread<span class="selector-class">.java</span>:<span class="number">748</span>)</span><br><span class="line">Finished: FAILURE</span><br></pre></td></tr></table></figure></p>
<h4 id="原因及解决方法"><a href="#原因及解决方法" class="headerlink" title="原因及解决方法"></a>原因及解决方法</h4><h5 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h5><p>抛 java.nio.channels.ClosedChannelException 异常的原因是 Jenkins Slave Pod 在 Jenkins Job 运行时突然挂掉，然后 Master Pod 无法和 Slave Pod 进行通信。那么解决方法就是找到 Slave Pod 经常挂掉的原因，经排查是 Slave Pod 的资源限制不合理，配置的 CPU 和内存太小，导致 Pod 在运行是很容易超出资源限制，然后被 k8s Kill 掉。</p>
<h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p> 打开 Jenkins 设置 Slave Pod 模版的资源限制：<br>Jenkins-&gt;系统管理-&gt;系统设置-&gt;云-&gt;镜像-&gt;Kubernetes Pod Template-&gt;Container Template-&gt;高级，然后根据实际情况调整 CPU 和内存需求。</p>
<h4 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h4><p><a href="https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes/issues/118" target="_blank" rel="noopener">https://github.com/GoogleCloudPlatform/continuous-deployment-on-kubernetes/issues/118</a><br><a href="https://medium.com/@garunski/closedchannelexception-in-jenkins-with-kubernetes-plugin-a7788f1c62a9" target="_blank" rel="noopener">https://medium.com/@garunski/closedchannelexception-in-jenkins-with-kubernetes-plugin-a7788f1c62a9</a></p>
]]></content>
      
        <categories>
            
            <category> DevOps </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于 Kubernetes 的动态 Jenkins slave 部署]]></title>
      <url>/2018/10/14/%E5%9F%BA%E4%BA%8E-Kubernetes-%E7%9A%84%E5%8A%A8%E6%80%81-Jenkins-slave-%E9%83%A8%E7%BD%B2/</url>
      <content type="html"><![CDATA[<p>采用官方 Helm Chart 部署，服务对外暴露方式为 KongIngress.</p>
<p>官方 Jenkins Chart 仓库：<a href="https://github.com/helm/charts/tree/master/stable/jenkins" target="_blank" rel="noopener">https://github.com/helm/charts/tree/master/stable/jenkins</a></p>
<h3 id="1-创建-jenkins-pv"><a href="#1-创建-jenkins-pv" class="headerlink" title="1. 创建 jenkins pv"></a>1. 创建 jenkins pv</h3><p>pv 底层类型为 nfs<br>jenkins_pv.yaml:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">kubectl</span> <span class="string">create</span> <span class="bullet">-f</span> <span class="string">jenkins_pv.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">jenkins-pv</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">jenkins</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">50</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  persistentVolumeReclaimPolicy:</span> <span class="string">Retain</span></span><br><span class="line"><span class="attr">  nfs:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/data1/nfs/jenkins</span></span><br><span class="line"><span class="attr">    server:</span> <span class="number">10.4</span><span class="number">.37</span><span class="number">.91</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-创建-namespace"><a href="#2-创建-namespace" class="headerlink" title="2. 创建 namespace"></a>2. 创建 namespace</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">kubectl create ns jenkins</span></span><br></pre></td></tr></table></figure>
<h3 id="3-采用-KongIngress-方式对外暴露服务"><a href="#3-采用-KongIngress-方式对外暴露服务" class="headerlink" title="3. 采用 KongIngress 方式对外暴露服务"></a>3. 采用 KongIngress 方式对外暴露服务</h3><p>修改 values.yml 文件:<br>3.1. Master.ServiceType 改为 ClusterIP<br>3.2. HostName 取消注释，值设置为 Jenkins 访问域名：example.com<br>3.3. rbac 设置为 true；<br>3.4. Master.Ingress.Annotations 添加如下内容：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ingress.plugin.konghq.com:</span> <span class="string">jenkins-kong-ingress</span></span><br><span class="line"><span class="string">kubernetes.io/ingress.class:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure></p>
<p>3.5. values.yaml Master 节点下添加 Kong Ingress 相关变量<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">KongIngress:</span></span><br><span class="line"><span class="attr">  Name:</span> <span class="string">jenkins-kong-ingress</span></span><br><span class="line"><span class="attr">  Route:</span></span><br><span class="line"><span class="attr">    StripPath:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    PreserveHost:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  Proxy:</span></span><br><span class="line"><span class="attr">    ConnectTimeout:</span> <span class="number">10000</span></span><br><span class="line"><span class="attr">    Retries:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">    ReadTimeout:</span> <span class="number">60000</span></span><br><span class="line"><span class="attr">    WriteTimeout:</span> <span class="number">60000</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-编辑-jenkins-master-ingress-yaml-添加-KongIngress-资源对象"><a href="#4-编辑-jenkins-master-ingress-yaml-添加-KongIngress-资源对象" class="headerlink" title="4. 编辑 jenkins-master-ingress.yaml 添加  KongIngress 资源对象"></a>4. 编辑 jenkins-master-ingress.yaml 添加  KongIngress 资源对象</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">configuration.konghq.com/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KongIngress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.Master.KongIngress.Name</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">route:</span></span><br><span class="line"><span class="attr">  strip_path:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.Master.KongIngress.Route.StripPath</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  preserve_host:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.Master.KongIngress.Route.PreserveHost</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">proxy:</span></span><br><span class="line"><span class="attr">  connect_timeout:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.Master.KongIngress.Proxy.ConnectTimeout</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  retries:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.Master.KongIngress.Proxy.Retries</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  read_timeout:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.Master.KongIngress.Proxy.ReadTimeout</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">  write_timeout:</span> <span class="string">&#123;&#123;</span> <span class="string">.Values.Master.KongIngress.Proxy.WriteTimeout</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="5-helm-打包"><a href="#5-helm-打包" class="headerlink" title="5. helm 打包"></a>5. helm 打包</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm <span class="keyword">package</span> <span class="title">jenkins</span></span><br></pre></td></tr></table></figure>
<h3 id="6-重新生成-chart-索引"><a href="#6-重新生成-chart-索引" class="headerlink" title="6. 重新生成 chart 索引"></a>6. 重新生成 chart 索引</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm repo <span class="keyword">index</span> .</span><br></pre></td></tr></table></figure>
<h3 id="7-helm-部署"><a href="#7-helm-部署" class="headerlink" title="7. helm 部署"></a>7. helm 部署</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">helm</span> <span class="comment">install</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">name</span> <span class="comment">jenkins</span> <span class="comment">helm_local_repo/jenkins</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">namespace</span> <span class="comment">jenkins</span></span><br></pre></td></tr></table></figure>
<h3 id="8-获取-Jenkins-初始密码"><a href="#8-获取-Jenkins-初始密码" class="headerlink" title="8. 获取 Jenkins 初始密码"></a>8. 获取 Jenkins 初始密码</h3><p> 执行 <code>kubectl get secret jenkins -n jenkins -o yaml</code> 得到 jenkins-admin-password 的 base64 编码值，然后通过 base64 解码，得到密码：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'base64d_str' <span class="string">| base64 -d</span></span><br></pre></td></tr></table></figure></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/OoTEtPNEORn_sFYG8rzaqA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/OoTEtPNEORn_sFYG8rzaqA</a></p>
]]></content>
      
        <categories>
            
            <category> DevOps </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Jenkins </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[容器化部署 Wordpress  的一个坑]]></title>
      <url>/2018/10/13/%E5%AE%B9%E5%99%A8%E5%8C%96%E9%83%A8%E7%BD%B2-Wordpress-%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</url>
      <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>非容器化 nginx + docker-compose 容器化 wordpress 后，媒体库上传图片报错：HTTP 错误</p>
<p><img src="/images/wp-http-error.png" alt=""></p>
<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>其实这个问题的原因非常多，网上文章一大堆（<a href="https://www.duoluodeyu.com/2402.html" target="_blank" rel="noopener">https://www.duoluodeyu.com/2402.html</a> ），但是本文中所遇到同样问题的原因却比较诡异：<em>nginx client_max_body_size 参数必须要和 PHP 的 post_max_size 参数值一致。</em></p>
<h4 id="1-修改-Wordpress-容器-PHP-参数"><a href="#1-修改-Wordpress-容器-PHP-参数" class="headerlink" title="1.修改 Wordpress 容器 PHP 参数"></a>1.修改 Wordpress 容器 PHP 参数</h4><p>新建 uploads.ini 文件，将该文件挂载到容器：/usr/local/etc/php/conf.d/uploads.ini 文件<br>uploads.ini：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">file_uploads</span> = <span class="literal">On</span></span><br><span class="line"><span class="attr">memory_limit</span> = <span class="number">128</span>M</span><br><span class="line"><span class="attr">upload_max_filesize</span> = <span class="number">512</span>M</span><br><span class="line"><span class="attr">post_max_size</span> = <span class="number">128</span>M</span><br><span class="line"><span class="attr">max_execution_time</span> = <span class="number">600</span></span><br></pre></td></tr></table></figure></p>
<p>docker-compose 文件添加卷，将文件挂载到容器<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">volumes:</span></span><br><span class="line">       - .<span class="regexp">/wp_site:/</span>var<span class="regexp">/www/</span>html</span><br><span class="line">       - .<span class="regexp">/uploads.ini:/</span>usr<span class="regexp">/local/</span>etc<span class="regexp">/php/</span>conf.d/uploads.ini</span><br></pre></td></tr></table></figure></p>
<h4 id="2-修改-nginx-client-max-body-size-参数配置"><a href="#2-修改-nginx-client-max-body-size-参数配置" class="headerlink" title="2. 修改 nginx client_max_body_size 参数配置"></a>2. 修改 nginx client_max_body_size 参数配置</h4><p>这个是坑的地方，这个参数的值必须要和上一步 PHP post_max_size 参数的值一致，否则还是报同样的 HTTP 错误。之前没注意这个问题，按照网上各种配置调整，均不起作用，后来经过各种猜测测试，其实问题的根因就在这里：nginx client_max_body_size 参数必须要和 php post_max_size 参数的值一致。</p>
<h3 id="附件（完整的-Wordpress-docker-compose-yaml）"><a href="#附件（完整的-Wordpress-docker-compose-yaml）" class="headerlink" title="附件（完整的 Wordpress docker-compose.yaml）"></a>附件（完整的 Wordpress docker-compose.yaml）</h3><p>容器外挂文件 uploads.ini 是定义 PHP 的一些参数配置，比如最大文件上传大小、POST 请求体大小限制、内存大小限制等等，这个文件挂载是可选的，但是如果要自定义 PHP 参数可以这么做。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3.3'</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">   db:</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">mysql:5.7</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">./db_data:/var/lib/mysql</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       MYSQL_ROOT_PASSWORD:</span> <span class="string">somewordpress</span></span><br><span class="line"><span class="attr">       MYSQL_DATABASE:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       MYSQL_PASSWORD:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">   wordpress:</span></span><br><span class="line"><span class="attr">     depends_on:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">db</span></span><br><span class="line"><span class="attr">     image:</span> <span class="attr">wordpress:latest</span></span><br><span class="line"><span class="attr">     volumes:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">./wp_site:/var/www/html</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">./uploads.ini:/usr/local/etc/php/conf.d/uploads.ini</span></span><br><span class="line"><span class="attr">     ports:</span></span><br><span class="line"><span class="bullet">       -</span> <span class="string">"9001:80"</span></span><br><span class="line"><span class="attr">     restart:</span> <span class="string">always</span></span><br><span class="line"><span class="attr">     environment:</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_HOST:</span> <span class="attr">db:3306</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_USER:</span> <span class="string">wordpress</span></span><br><span class="line"><span class="attr">       WORDPRESS_DB_PASSWORD:</span> <span class="string">wordpress</span></span><br></pre></td></tr></table></figure></p>
<h3 id="相关参考文档"><a href="#相关参考文档" class="headerlink" title="相关参考文档"></a>相关参考文档</h3><p><a href="https://www.duoluodeyu.com/2402.html" target="_blank" rel="noopener">https://www.duoluodeyu.com/2402.html</a><br><a href="https://github.com/docker-library/wordpress/issues/10" target="_blank" rel="noopener">https://github.com/docker-library/wordpress/issues/10</a></p>
]]></content>
      
        <categories>
            
            <category> Wordpress </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Wordpress </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[kubeadm 安装的 k8s 集群 delete node 后重新添加回集群问题解决]]></title>
      <url>/2018/09/11/kubeadm-%E5%AE%89%E8%A3%85%E7%9A%84-k8s-%E9%9B%86%E7%BE%A4-delete-node-%E5%90%8E%E9%87%8D%E6%96%B0%E6%B7%BB%E5%8A%A0%E5%9B%9E%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>前不久公司同事误操作，直接 kubectl delete node node_ip 从集群中删除了一个 node，后来未知原因服务器给宕机了，重启服务器后 docker、kubelet 等服务器都自动重启了（用 systemd 管理），但是 node 一直是 Not Ready 状态，按理来说执行如下命令把节点添加回集群即可：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --<span class="keyword">token</span> xxxxxxx master_ip:6443 --discovery-<span class="keyword">token</span>-<span class="keyword">ca</span>-cert-hash sha256:xxxxxxx</span><br></pre></td></tr></table></figure></p>
<p>但是执行如上命令后报错如下(提示 10250 端口被占用)：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@com10-81 ~]# kubeadm join --token xxxx 10.4.37.167:6443 --discovery-token-ca-cert-hash sha256:xxxxxx</span><br><span class="line">[preflight] Running pre-flight checks.</span><br><span class="line">	[<span class="builtin-name">WARNING</span> SystemVerification]: docker version is greater than the most recently validated version. Docker version: 17.12.1-ce. Max validated version: 17.03</span><br><span class="line">	[<span class="builtin-name">WARNING</span> FileExisting-crictl]: crictl <span class="keyword">not</span> found <span class="keyword">in</span><span class="built_in"> system </span>path</span><br><span class="line">[preflight] Some fatal errors occurred:</span><br><span class="line">	[<span class="builtin-name">ERROR</span> Port-10250]:<span class="built_in"> Port </span>10250 is <span class="keyword">in</span> use</span><br><span class="line">	[<span class="builtin-name">ERROR</span> FileAvailable--etc-kubernetes-pki-ca.crt]: /etc/kubernetes/pki/ca.crt already exists</span><br><span class="line">	[<span class="builtin-name">ERROR</span> FileAvailable--etc-kubernetes-kubelet.conf]: /etc/kubernetes/kubelet.conf already exists</span><br></pre></td></tr></table></figure></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>出现如上问题的主要原因是之前 kubeadm init 初始化过，所以一些配置文件及服务均已存在，重新执行 kubeadm join 时必然<br>会导致冲突，解决方法如下：<br>1.先执行 kubeadm reset，重新初始化节点配置：<br><code>kubeadm reset</code><br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@com10-<span class="number">81</span> ~]<span class="comment"># kubeadm reset</span></span><br><span class="line">[preflight] Running pre-flight checks.</span><br><span class="line">[reset] Stopping the kubelet service.</span><br><span class="line">[reset] Unmounting mounted directories in <span class="string">"/var/lib/kubelet"</span></span><br><span class="line">[reset] Removing kubernetes-managed containers.</span><br><span class="line">[reset] No etcd manifest found in <span class="string">"/etc/kubernetes/manifests/etcd.yaml"</span>. Assuming external etcd.</span><br><span class="line">[reset] Deleting contents <span class="keyword">of</span> stateful <span class="symbol">directories:</span> [<span class="regexp">/var/lib</span><span class="regexp">/kubelet /etc</span><span class="regexp">/cni/net</span>.d /var/<span class="class"><span class="keyword">lib</span>/<span class="title">dockershim</span> /<span class="title">var</span>/<span class="title">run</span>/<span class="title">kubernetes</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>2.然后执行 kubeadm join 添加节点到集群（如果 token 失效，到主节点执行：kubeadm token create 重新生成）：<br><code>kubeadm join --token xxxxx master_ip:6443 --discovery-token-ca-cert-hash sha256:xxxx</code><br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@com10<span class="number">-81</span> ~]<span class="comment"># kubeadm join --token xxxxx 10.4.37.167:6443 --discovery-token-ca-cert-hash sha256:xxxxxxx</span></span><br><span class="line">[preflight] Running pre-flight checks.</span><br><span class="line">	[WARNING SystemVerification]: docker <span class="built_in">version</span> <span class="keyword">is</span> <span class="keyword">greater than</span> <span class="keyword">the</span> most recently validated <span class="built_in">version</span>. Docker <span class="built_in">version</span>: <span class="number">17.12</span><span class="number">.1</span>-ce. Max validated <span class="built_in">version</span>: <span class="number">17.03</span></span><br><span class="line">	[WARNING FileExisting-crictl]: crictl <span class="keyword">not</span> found <span class="keyword">in</span> system path</span><br><span class="line">[preflight] Starting <span class="keyword">the</span> kubelet service</span><br><span class="line">[discovery] Trying <span class="keyword">to</span> connect <span class="keyword">to</span> API Server <span class="string">"10.4.37.167:6443"</span></span><br><span class="line">[discovery] Created cluster-info discovery client, requesting info <span class="keyword">from</span> <span class="string">"https://10.4.37.167:6443"</span></span><br><span class="line">[discovery] Requesting info <span class="keyword">from</span> <span class="string">"https://10.4.37.167:6443"</span> again <span class="keyword">to</span> validate TLS <span class="keyword">against</span> <span class="keyword">the</span> pinned public key</span><br><span class="line">[discovery] Cluster info signature <span class="keyword">and</span> <span class="built_in">contents</span> are valid <span class="keyword">and</span> TLS certificate validates <span class="keyword">against</span> pinned roots, will use API Server <span class="string">"10.4.37.167:6443"</span></span><br><span class="line">[discovery] Successfully established connection <span class="keyword">with</span> API Server <span class="string">"10.4.37.167:6443"</span></span><br><span class="line"></span><br><span class="line">This node has joined <span class="keyword">the</span> cluster:</span><br><span class="line">* Certificate signing request was sent <span class="keyword">to</span> master <span class="keyword">and</span> a response</span><br><span class="line">  was received.</span><br><span class="line">* The Kubelet was informed <span class="keyword">of</span> <span class="keyword">the</span> new secure connection details.</span><br><span class="line"></span><br><span class="line">Run 'kubectl <span class="keyword">get</span> nodes' <span class="keyword">on</span> <span class="keyword">the</span> master <span class="keyword">to</span> see this node join <span class="keyword">the</span> cluster.</span><br></pre></td></tr></table></figure></p>
<p>PS: k8s 集群 /etc/kubernetes/pki/ca.crt 证书(任何一节点都有该文件) sha256 编码获取（kubeadm join 添加集群节点时需要该证书的 sha256 编码串认证）：<br><code>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed &#39;s/^.* //&#39;</code></p>
<p>到此节点添加回集群了，但是直接执行 kubectl 相关的命令可能还会报如下错误：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@com10-81 ~]# kubectl <span class="builtin-name">get</span> pod</span><br><span class="line">The<span class="built_in"> connection </span><span class="keyword">to</span> the<span class="built_in"> server </span>localhost:8080 was refused - did you specify the right host <span class="keyword">or</span> port?</span><br><span class="line">You have mail <span class="keyword">in</span> /var/spool/mail/root</span><br></pre></td></tr></table></figure></p>
<p>问题原因及解决方法:<br>很明显 kubelet 加载的配置文件(/etc/kubernetes/kubelet.conf)有问题，可能服务器重启的缘故，启动后该文件丢失了，导致里面的连接 master 节点的配置及其他配置给丢了，因此会默认连接 localhost:8080 端口。解决方法很简单：拷贝其他任一节点的该文件，然后重启 kubelet (systemctl restart kublete)即可。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://stackoverflow.com/questions/41732265/how-to-use-kubeadm-to-create-kubernetest-cluster" target="_blank" rel="noopener">https://stackoverflow.com/questions/41732265/how-to-use-kubeadm-to-create-kubernetest-cluster</a><br><a href="https://blog.csdn.net/mailjoin/article/details/79686934" target="_blank" rel="noopener">https://blog.csdn.net/mailjoin/article/details/79686934</a></p>
]]></content>
      
        <categories>
            
            <category> Kubenetes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[通过 CeSi + Supervisor 可视化集中管理服务器节点进程]]></title>
      <url>/2018/07/21/%E9%80%9A%E8%BF%87-CeSi-Supervisor-%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8A%82%E7%82%B9%E8%BF%9B%E7%A8%8B/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#%E9%80%9A%E8%BF%87-cesi--supervisor-%E5%8F%AF%E8%A7%86%E5%8C%96%E9%9B%86%E4%B8%AD%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%8A%82%E7%82%B9%E8%BF%9B%E7%A8%8B">通过 CeSi + Supervisor 可视化集中管理服务器节点进程</a><ul>
<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>
<li><a href="#supervisor-%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">Supervisor 的安装及基本使用</a><ul>
<li><a href="#1-%E5%AE%89%E8%A3%85">1. 安装</a></li>
<li><a href="#2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">2. 基本使用</a><ul>
<li><a href="#21-%E5%90%AF%E5%8A%A8-supervisor">2.1 启动 supervisor</a></li>
<li><a href="#22-supervisor-%E5%AE%A2%E6%88%B7%E7%AB%AF-supervisorctl">2.2 Supervisor 客户端 supervisorctl</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE-cesi">安装配置 CeSi</a><ul>
<li><a href="#1-%E7%AE%80%E4%BB%8B">1. 简介</a></li>
<li><a href="#2-%E5%AE%89%E8%A3%85">2. 安装</a></li>
<li><a href="#3-%E9%85%8D%E7%BD%AE">3. 配置</a></li>
<li><a href="#4-%E5%90%AF%E5%8A%A8">4. 启动</a></li>
</ul>
</li>
<li><a href="#supervisor-%E6%9C%8D%E5%8A%A1%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8">Supervisor 服务设置开机自启动</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>
</ul>
</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="http://supervisord.org" target="_blank" rel="noopener">Supervisor</a> 是一个用 <code>Python</code> 写的进程管理工具，可以很方便的用来启动、重启、关闭进程。类似于 <code>Linux</code> 的 <code>systemd</code> 守护进程一样，通过统一的命令来管理系统的各个服务，当管理的服务挂掉时会自动重新拉起。<code>Supervisor</code> 还提供了很多<a href="http://supervisord.org/plugins.html" target="_blank" rel="noopener">第三方插件</a>，比如后面会讲到的 <a href="https://github.com/Gamegos/cesi" target="_blank" rel="noopener">CeSi</a>，该工具是 <code>Supervisor</code> 的 <code>WebUI</code>，可以通过这个统一的 <code>WebUI</code> 集中化管理各个服务器节点的进程。</p>
<p><code>Supervisor</code> 和 <code>Docker</code> 的架构类似，也是 <code>C/S</code> 架构，服务端是 <code>supervisord</code>，客户端是 <code>supervisorctl</code> 。客户端主要是用来控制服务端所管理的进程，比如控制服务的启动、关闭、重启、查看服务状态，还可以重启服务端、重载配置文件等。服务端管控各个服务的正常运行，当有服务异常退出时会自动拉起。</p>
<h3 id="Supervisor-的安装及基本使用"><a href="#Supervisor-的安装及基本使用" class="headerlink" title="Supervisor 的安装及基本使用"></a>Supervisor 的安装及基本使用</h3><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><p><code>Supervisor</code> 的安装特别简单，由于是 <code>Python</code> 写的，因此可以通过 <code>pip</code> 一键安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure></p>
<p><em>在此我提供了一个 <a href="https://gist.github.com/qhh0205/435ce1a7d29c935e743378b61e28b541" target="_blank" rel="noopener">Sueprvisor 一键安装配置脚本</a>，简化了 <code>Supervisor</code> 的初始配置。</em></p>
<h4 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h4><p>安装完成后系统会多出如下三个命令：</p>
<blockquote>
<p><code>supervisord</code> ：Supervisor 的服务端；<br><code>supervisorctl</code>：Supervisor 的客户端；<br><code>echo_supervisord_conf</code>：Supervisor 服务端默认配置文件生成工具；</p>
</blockquote>
<h5 id="2-1-启动-supervisor"><a href="#2-1-启动-supervisor" class="headerlink" title="2.1 启动 supervisor"></a>2.1 启动 <code>supervisor</code></h5><p>首先通过如下命令将 <code>supervisor</code> 的默认配置生成到 <code>/etc/supervisord.conf</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure></p>
<p><code>Supervisor</code> 配置文件格式是 <code>INI</code> 格式，因此看起来比较直观，很多配置项的含义已在上面生成的配置文件中以注释的形式说明，以下简要说明一下我在生产环境目前使用的配置，为了减少篇幅，在此只列出了非注释的内容：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[unix_http_server]</span></span><br><span class="line"><span class="attr">file</span>=/tmp/supervisor.sock   ; 服务端套接字文件路径，supervisorctl 客户端会使用该文件和服务端通信</span><br><span class="line"><span class="section">[inet_http_server]</span>         <span class="comment">; Supervisor 服务端提供的 http 服务，很多 Supervisor 的 WebUI</span></span><br><span class="line">                           <span class="comment">;都是通过访问该服务来实现统一管理的，比如后面要讲的 CeSi Web UI</span></span><br><span class="line"><span class="attr">port</span>=<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">9001</span>          ; ip_address:port specifier, *:port for all iface</span><br><span class="line"><span class="section">[supervisord]</span> <span class="comment">; Supervisor 服务端配置</span></span><br><span class="line"><span class="attr">logfile</span>=/tmp/supervisord.log ; 服务端日志文件路径</span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">50</span>MB        ; max main logfile bytes b4 rotation; default <span class="number">50</span>MB</span><br><span class="line"><span class="attr">logfile_backups</span>=<span class="number">10</span>           ; # of main logfile backups; <span class="number">0</span> means none, default <span class="number">10</span></span><br><span class="line"><span class="attr">loglevel</span>=debug               ; log level; default info; others: debug,warn,trace</span><br><span class="line"><span class="attr">pidfile</span>=/tmp/supervisord.pid ; supervisord pidfile; default supervisord.pid</span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">false</span>               ; start in foreground if <span class="literal">true</span>; default <span class="literal">false</span></span><br><span class="line"><span class="attr">minfds</span>=<span class="number">1024</span>                  ; min. avail startup file descriptors; default <span class="number">1024</span></span><br><span class="line"><span class="attr">minprocs</span>=<span class="number">200</span>                 ; min. avail process descriptors;default <span class="number">200</span></span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="section">[rpcinterface:supervisor]</span></span><br><span class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</span><br><span class="line"><span class="section">[supervisorctl]</span> <span class="comment">; Supervisor 客户端配置</span></span><br><span class="line"><span class="attr">serverurl</span>=unix:///tmp/supervisor.sock ; 配置客户端和服务端的通信方式，默认 supervisorctl </span><br><span class="line">                                      <span class="comment">;和 supervisor 通信是通过该套接字通信，也可以配成通过 http 方式通信。</span></span><br><span class="line"><span class="section">[include]</span> <span class="comment">; 在此我将 Supervisor 所管理的服务配置文件都放到了 /etc/supervisor/ 目录，然后通过 include 统一引入</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisor/*.conf</span><br></pre></td></tr></table></figure></p>
<p>接下来在 <code>/etc/supervisor/</code> 放入需要 <code>Supervisor</code> 管理的各服务的配置文件，一般一个服务一个配置文件，当然也可以写到一起，比如逻辑上有关联的一组服务可以放到一个配置文件，这样方便管理，下面以一个实例来介绍下要通过 <code>Supervisor</code> 管理服务，相应的配置文件该如何编写（使用 <code>Supervisor</code> 管理 <code>cesi</code> 服务的配置）：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; cesi.conf</span></span><br><span class="line"><span class="section">[program:cesi-5000]</span> <span class="comment">; program 表示 Supervisor 管理的服务实例，cesi-5000 是自己命名</span></span><br><span class="line">                    <span class="comment">;的服务名称，名字可以随便其，我为了方便管理统一命名为：服务名称-端口</span></span><br><span class="line"><span class="attr">directory</span> = /home/ec2-user/cesi ; 程序的启动目录</span><br><span class="line"><span class="attr">command</span> = python cesi/web.py ; 启动服务的命令</span><br><span class="line"><span class="attr">autostart</span> = <span class="literal">true</span>     ; 在 supervisord 启动的时候也自动启动</span><br><span class="line"><span class="attr">startsecs</span> = <span class="number">5</span>        ; 启动 <span class="number">5</span> 秒后没有异常退出，就当作已经正常启动了</span><br><span class="line"><span class="attr">autorestart</span> = <span class="literal">true</span>   ; 程序异常退出后自动重启</span><br><span class="line"><span class="attr">startretries</span> = <span class="number">3</span>     ; 启动失败自动重试次数，默认是 <span class="number">3</span></span><br><span class="line"><span class="attr">user</span> = ec2-user      ; 用哪个用户启动</span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span>  ; 把 stderr 重定向到 stdout，默认 <span class="literal">false</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">50</span>MB  ; stdout 日志文件大小，默认 <span class="number">50</span>MB</span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">7</span> ; stdout 日志文件备份数</span><br><span class="line"><span class="comment">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span></span><br><span class="line"><span class="attr">stdout_logfile</span> = /home/ec2-user/cesi/stdout.log</span><br></pre></td></tr></table></figure></p>
<p>将上述配置保存为 <code>cesi.conf</code>，放到 <code>/etc/supervisor/</code>。</p>
<p>前面已经对 <code>echo_supervisord_conf</code> 生成的默认配置文件做了微调，接下来启动 <code>Supervisor</code> 服务端（建议用 root 用户启动）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure></p>
<p>如果不指定 <code>-c</code> 参数，会通过如下顺序来搜索配置文件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$PWD</span>/supervisord.conf</span><br><span class="line"><span class="variable">$PWD</span>/etc/supervisord.conf</span><br><span class="line">/etc/supervisord.conf</span><br><span class="line">/etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-Supervisor-客户端-supervisorctl"><a href="#2-2-Supervisor-客户端-supervisorctl" class="headerlink" title="2.2 Supervisor 客户端 supervisorctl"></a>2.2 Supervisor 客户端 <code>supervisorctl</code></h5><p><code>supervisorctl</code> 有两种使用方式：<br>一种是直接执行 <code>supervisorctl</code> ，这样会进入交互式的 <code>Shell</code>， 然后在该交互式 <code>Shell</code> 中输入管理命令，举例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@awsuw supervisor]<span class="comment"># supervisorctl</span></span><br><span class="line">cesi-5000                        RUNNING   pid 6538, uptime 1 day, 1:21:02</span><br><span class="line">zipkinstage-9411                 RUNNING   pid 30919, uptime 1 day, 19:51:43</span><br><span class="line">supervisor&gt; status</span><br><span class="line">cesi-5000                        RUNNING   pid 6538, uptime 1 day, 1:21:09</span><br><span class="line">zipkinstage-9411                 RUNNING   pid 30919, uptime 1 day, 19:51:50</span><br></pre></td></tr></table></figure></p>
<p>另一种是 <code>supervisorctl [action]</code> 的方式，这样不会陷入交互式 <code>Shell</code>，直接会返回命令的执行结果，其中 <code>action</code> 就是管理服务进程的各个命令，举例（查看目前所管理的服务的进程状态）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@awsuw supervisor]<span class="comment"># supervisorctl status</span></span><br><span class="line">cesi-5000                        RUNNING   pid 6538, uptime 1 day, 1:24:53</span><br><span class="line">zipkinstage-9411                 RUNNING   pid 30919, uptime 1 day, 19:55:34</span><br></pre></td></tr></table></figure></p>
<p>其中常用的 <code>action</code> 有如下（更多选项参数见 <a href="http://supervisord.org/running.html#supervisord-command-line-options" target="_blank" rel="noopener">这里</a>）：</p>
<blockquote>
<p><code>supervisorctl status</code> ： 查看所管理的服务状态；<br><code>supervisorctl start &lt;program_name&gt;</code>：启动一个服务；<br><code>supervisorctl restart &lt;program_name&gt;</code>：重启一个服务（注意：重启服务不会重新加载配置文件）；<br><code>supervisorctl stop &lt;program_name&gt;</code>：关闭一个服务；<br><code>supervisorctl update</code>：重新加载配置文件，并重启配置有变动的服务；<br><code>supervisorctl reread</code>：重新加载配置文件，但不会重启配置有变动的服务；<br><code>supervisorctl reload</code>：重启 <code>Supervisor</code> 服务端；<br><code>supervisorctl clear &lt;program_name&gt;</code>：清理一个服务的 <code>stdout log</code>；</p>
</blockquote>
<h3 id="安装配置-CeSi"><a href="#安装配置-CeSi" class="headerlink" title="安装配置 CeSi"></a>安装配置 CeSi</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><p><a href="https://github.com/gamegos/cesi" target="_blank" rel="noopener">CeSi</a> 是 <code>Supervisor</code> 官方推荐的集中化管理 <code>Supervisor</code> 实例的 <code>Web UI</code>，该工具是用 <code>Python</code> 编写，基于 <code>Flask</code>  <code>Web</code> 框架 。</p>
<p><code>Superviosr</code> 自带的 <code>Web UI</code> 不支持跨机器管理<code>Supervisor</code> 进程，功能比较简单，通过 <code>CeSi</code> 可以集中管理各个服务器节点的进程，在 Web 界面就可以轻松管理各个服务的启动、关闭、重启等，很方便使用。</p>
<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h4><p>安装 <code>CeSi</code> 有三个依赖：<code>Python</code>，<code>Flask</code>，<code>sqlite3</code><br>一般的 Linux 发行版都默认安装了 <code>Python</code>，所以 <code>Python</code> 不需要再次安装；<br>从 <code>Python 2.5</code> 开始 <code>sqlite3</code> 已经在标准库内置了，所以也不需要安装 <code>sqlite3</code> 模块了；<br>另外很多 Linux 发行版已经自带 <code>sqlite3</code>，所以无需另外安装；<br>只需要安装 <code>flask web</code> 框架即可；</p>
<p><a href="https://github.com/gamegos/cesi" target="_blank" rel="noopener">CeSi</a> 已经有了新的版本，在 GitHub 仓库的 <code>v2_api</code> 分支下，提供了比之前版本更加美观的界面，以下为 <a href="https://github.com/gamegos/cesi" target="_blank" rel="noopener">CeSi</a> 一键安装配置脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">sudo pip install flask</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/gamegos/cesi.git</span><br><span class="line"><span class="built_in">cd</span> cesi</span><br><span class="line"><span class="comment"># 使用最新版, 最新版的 Web UI 做了很大改动</span></span><br><span class="line">git checkout -b v2_api origin/v2_api</span><br><span class="line">sudo cp cesi.conf.sample /etc/cesi.conf</span><br><span class="line">sudo ln -s /etc/cesi.conf cesi.conf</span><br><span class="line"><span class="comment">#创建用户信息表：</span></span><br><span class="line">sqlite3 userinfo.db &lt; userinfo.sql</span><br><span class="line"><span class="comment">#CeSi log 目录</span></span><br><span class="line">sudo mkdir -p /var/logs/cesi</span><br><span class="line">sudo chmod 777 -R /var/logs</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：<code>CeSi</code> 的配置文件路径必须是 <code>/etc/cesi.conf</code> ，否则启动会报错，简单看下 <code>CeSi</code> 的源码就知道为什么了。在这里我在仓库目录弄了个软连接指向了 <code>/etc/cesi.conf</code>，完全是为了编辑方便弄的。 </p>
<h4 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h4><p><code>CeSi</code> 的配置非常简单，和 <code>Supervisor</code> 的配置文件类似，也是 <code>INI</code> 格式，关于配置文件的各项说明在 <code>cesi.conf.sample</code> 配置样例中已经通过注释的形式给了明确的说明，稍微看下就能明白，以下为我目前使用的配置（为了减小篇幅，去掉了注释）：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[node:node1]</span> <span class="comment">;各 Supervisor 节点的配置</span></span><br><span class="line"><span class="attr">username</span> = ; 如果 Supervisor 节点没有设置账号密码，这里就保持为空，但不能不写</span><br><span class="line"><span class="attr">password</span> =</span><br><span class="line"><span class="attr">host</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">9001</span></span><br><span class="line"><span class="section">[node:node2]</span></span><br><span class="line"><span class="attr">username</span> =</span><br><span class="line"><span class="attr">password</span> =</span><br><span class="line"><span class="attr">host</span> = node2.d.com</span><br><span class="line"><span class="attr">port</span> = <span class="number">9001</span></span><br><span class="line"><span class="section">[node:node3]</span></span><br><span class="line"><span class="attr">username</span> =</span><br><span class="line"><span class="attr">password</span> =</span><br><span class="line"><span class="attr">host</span> = node3.d.com</span><br><span class="line"><span class="attr">port</span> = <span class="number">9001</span></span><br><span class="line"></span><br><span class="line"><span class="section">[cesi]</span> <span class="comment">; CeSi 自身的配置</span></span><br><span class="line"><span class="attr">database</span> = userinfo.db</span><br><span class="line"><span class="attr">activity_log</span> = /var/logs/cesi/activity.log ;log目录没有的话需要提前建好</span><br><span class="line"><span class="attr">host</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">5000</span> ; CeSi 启动端口</span><br><span class="line"><span class="attr">name</span> = CeSI</span><br><span class="line"><span class="attr">theme</span> = superhero</span><br></pre></td></tr></table></figure></p>
<h4 id="4-启动"><a href="#4-启动" class="headerlink" title="4. 启动"></a>4. 启动</h4><p><code>CeSi</code> 的启动非常简单，直接通过 <code>Python</code> 启动即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python cesi/web.py</span><br></pre></td></tr></table></figure></p>
<p>为了方便管理，我把 <code>CeSi</code> 也通过 <code>Supervisor</code> 来管理，以下为对应的 <code>Supervisor</code> 配置：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;cesi.conf</span></span><br><span class="line"><span class="section">[program:cesi-5000]</span></span><br><span class="line"><span class="attr">directory</span> = /home/ec2-user/cesi ; 程序的启动目录</span><br><span class="line"><span class="attr">command</span> = python cesi/web.py</span><br><span class="line"><span class="attr">autostart</span> = <span class="literal">true</span>     ; 在 supervisord 启动的时候也自动启动</span><br><span class="line"><span class="attr">startsecs</span> = <span class="number">5</span>        ; 启动 <span class="number">5</span> 秒后没有异常退出，就当作已经正常启动了</span><br><span class="line"><span class="attr">autorestart</span> = <span class="literal">true</span>   ; 程序异常退出后自动重启</span><br><span class="line"><span class="attr">startretries</span> = <span class="number">3</span>     ; 启动失败自动重试次数，默认是 <span class="number">3</span></span><br><span class="line"><span class="attr">user</span> = ec2-user      ; 用哪个用户启动</span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span>  ; 把 stderr 重定向到 stdout，默认 <span class="literal">false</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">50</span>MB  ; stdout 日志文件大小，默认 <span class="number">50</span>MB</span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">7</span> ; stdout 日志文件备份数</span><br><span class="line"><span class="comment">; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）</span></span><br><span class="line"><span class="attr">stdout_logfile</span> = /home/ec2-user/cesi/stdout.log</span><br></pre></td></tr></table></figure></p>
<p>启动完成后，做个 <code>Nginx</code> 反向代理即可通过浏览器访问，最终效果如下：<br><img src="/images/cesi-ui.png" alt="cesi-ui"></p>
<h3 id="Supervisor-服务设置开机自启动"><a href="#Supervisor-服务设置开机自启动" class="headerlink" title="Supervisor 服务设置开机自启动"></a>Supervisor 服务设置开机自启动</h3><p>以下为在 <code>RedHat7</code>下配置 <code>Supervisor</code> 开机自启动过程，编写 <code>Unit</code> 文件，使用 <code>systemd</code> 管理 <code>Supervisor</code>：</p>
<ol>
<li><p>编写 <code>Unit</code> 文件：<code>supervisord.service</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#supervisord.service</span></span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Supervisor daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/bin/supervisord -c /etc/supervisord.conf</span><br><span class="line">ExecStop=/bin/supervisorctl shutdown</span><br><span class="line">ExecReload=/bin/supervisorctl -c /etc/supervisord.conf reload</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
</li>
<li><p>将上述文件拷贝到 <code>/usr/lib/systemd/system/</code> 目录下</p>
</li>
<li><p>将 <code>supervisor.service</code> 注册到系统中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@awsuw ~]<span class="comment"># systemctl enable supervisord.service</span></span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/supervisord.service to /usr/lib/systemd/system/supervisord.service.</span><br></pre></td></tr></table></figure>
<p> 可以看出注册过程就是在 <code>/etc/systemd/system/multi-user.target.wants/</code> 目录下创建一个软链接指向第二步中的中拷贝到 <code>/usr/lib/systemd/system/</code> 的文件。</p>
</li>
</ol>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="http://supervisord.org/index.html" target="_blank" rel="noopener">http://supervisord.org/index.html</a><br><a href="http://www.bjhee.com/supervisor.html" target="_blank" rel="noopener">http://www.bjhee.com/supervisor.html</a><br><a href="https://www.jianshu.com/p/03619bf7d7f5" target="_blank" rel="noopener">https://www.jianshu.com/p/03619bf7d7f5</a><br><a href="http://liyangliang.me/posts/2015/06/using-supervisor" target="_blank" rel="noopener">http://liyangliang.me/posts/2015/06/using-supervisor</a></p>
]]></content>
      
        <categories>
            
            <category> Supervisor </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Supervisor </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis 慢查询分析]]></title>
      <url>/2018/07/15/Redis-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>和很多关系型数据库（例如：<code>MySQL</code>）一样， Redis 也提供了慢查询日志记录，Redis 会把命令执行时间超过 <code>slowlog-log-slower-than</code> 的都记录在 Reids 内部的一个列表（<code>list</code>）中，该列表的长度最大为 <code>slowlog-max-len</code> 。需要注意的是，慢查询记录的只是命令的<strong>执行时间</strong>，不包括网络传输和排队时间：</p>
<p><img src="/images/redis-cmd-exec.png" alt="Alt text"></p>
<h3 id="慢查询分析配置"><a href="#慢查询分析配置" class="headerlink" title="慢查询分析配置"></a>慢查询分析配置</h3><p>关于 Redis 慢查询的配置有两个，分别是 <code>slowlog-log-slower-than</code> 和 <code>slowlog-max-len</code>。</p>
<ol>
<li><p><code>slowlog-log-slower-than</code>，用来控制慢查询的阈值，所有执行时间超过该值的命令都会被记录下来。该值的单位为微秒，默认值为 <code>10000</code>，如果设置为 <code>0</code>，那么所有的记录都会被记录下来，如果设置为小于 <code>0</code> 的值，那么对于任何命令都不会记录，即关闭了慢查询。可以通过在配置文件中设置，或者用 <code>config set</code> 命令来设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> slowlog-log-slower-than 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>slowlog-max-len</code>，用来设置存储慢查询记录列表的大小，默认值为 <code>128</code>，当该列表满了时，如果有新的记录进来，那么 Redis 会把队最旧的记录清理掉，然后存储新的记录。在生产环境我们可以适当调大，比如调成 <code>1000</code>，这样就可以缓冲更多的记录，方便故障的排查。配置方法和 <code>slowlog-log-slower-than</code> 类似，可以在配置文件中指定，也可以在命令行执行 <code>config set</code> 来设置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> slowlog-max-len 1000</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="查看慢查询日志"><a href="#查看慢查询日志" class="headerlink" title="查看慢查询日志"></a>查看慢查询日志</h3><p>尽管 Redis 把慢查询日志记录到了内部的列表，但我们不能直接操作该列表，Redis 专门提供了一组命令来查询慢查询日志：</p>
<ol>
<li><p>获取慢查询日志：<br><code>slowlog get [n]</code><br>下面操作返回当前 Redis 的所有慢查询记录，可以通过参数 <code>n</code> 指定查看条数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; slowlog get</span><br><span class="line"> 1) 1) (<span class="built_in">integer</span>) 456</span><br><span class="line">    2) (<span class="built_in">integer</span>) 1531632044</span><br><span class="line">    3) (<span class="built_in">integer</span>) 3</span><br><span class="line">    4) 1) <span class="string">"get"</span></span><br><span class="line">       2) <span class="string">"m"</span></span><br><span class="line">    5) <span class="string">"127.0.0.1:50106"</span></span><br><span class="line">    6) <span class="string">""</span></span><br><span class="line"> 2) 1) (<span class="built_in">integer</span>) 455</span><br><span class="line">    2) (<span class="built_in">integer</span>) 1531632037</span><br><span class="line">    3) (<span class="built_in">integer</span>) 14</span><br><span class="line">    4) 1) <span class="string">"keys"</span></span><br><span class="line">       2) <span class="string">"*"</span></span><br><span class="line">    5) <span class="string">"127.0.0.1:50106"</span></span><br><span class="line">    6) <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p> 结果说明：<br><code>1)</code> 慢查询记录 id；<br><code>2)</code> 发起命令的时间戳；<br><code>3)</code> 命令耗时，单位为微秒；<br><code>4)</code> 该条记录的命令及参数；<br><code>5)</code> 客户端网络套接字（ip: port）;<br><code>6)</code> “”</p>
</li>
<li><p>获取当前慢查询日志记录数<br><code>slowlog len</code></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:6379</span>&gt; <span class="selector-tag">slowlog</span> <span class="selector-tag">len</span></span><br><span class="line">(<span class="selector-tag">integer</span>) 458</span><br></pre></td></tr></table></figure>
</li>
<li><p>慢查询日志重置<br><code>slowlog reset</code><br>实际上是对慢查询列表做清理操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; slowlog len</span><br><span class="line">(<span class="built_in">integer</span>) 461</span><br><span class="line">127.0.0.1:6379&gt; slowlog reset</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; slowlog len</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis 数据库管理]]></title>
      <url>/2018/07/14/Redis-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="Redis-数据库管理"><a href="#Redis-数据库管理" class="headerlink" title="Redis 数据库管理"></a>Redis 数据库管理</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>Redis 提供了几个面向数据库的操作，分别是 <code>dbsize</code>, <code>select</code>, <code>flushdb/flushall</code>。<br>其实在一个 Redis 实例内部也是有多个数据库的，与 <code>MySQL</code> 等其他关系型数据库不同的是，Redis 内部的数据库使用数字索引来标识，而不是像 <code>MySQL</code> 那样一个实例中的数据库是通过数据库名称来标识。<br>在 Redis 中数据库默认有 <code>16</code> 个，数据库标识分别是 <code>0</code>, <code>1</code>, …, <code>15</code>，我们默认使用的是 <code>0</code> 号数据库，不同数据库之间是隔离的，可以拥有同名的键。</p>
<p><img src="/images/redis-db.png" alt=""></p>
<h3 id="各数据库管理命令介绍"><a href="#各数据库管理命令介绍" class="headerlink" title="各数据库管理命令介绍"></a>各数据库管理命令介绍</h3><h4 id="1-dbsize-查看当前数据库-key-的个数"><a href="#1-dbsize-查看当前数据库-key-的个数" class="headerlink" title="1. dbsize 查看当前数据库 key 的个数"></a>1. <code>dbsize</code> 查看当前数据库 key 的个数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name tom</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> score 99</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; dbsize</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>
<h4 id="2-select-切换数据"><a href="#2-select-切换数据" class="headerlink" title="2. select 切换数据"></a>2. <code>select</code> 切换数据</h4><p><code>select</code> 命令格式为：<code>select index</code>，<code>index</code> 为数据库的标识。举例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name tom</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> score 99</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; select 8  // 切换到 8 号数据库</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; get name  //可以看出不同 db 是隔离的</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379[8]&gt; <span class="built_in">set</span> name tom</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; get name</span><br><span class="line"><span class="string">"tom"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-flushdb-flushall-清理数据库"><a href="#3-flushdb-flushall-清理数据库" class="headerlink" title="3. flushdb/flushall 清理数据库"></a>3. <code>flushdb/flushall</code> 清理数据库</h4><p><code>flushdb</code> 和 <code>flushall</code> 的区别为：<code>flushdb</code> 清空当前数据库，而 <code>flushall</code> 清空所有数据库。举例如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"score"</span></span><br><span class="line">2) <span class="string">"name"</span></span><br><span class="line">127.0.0.1:6379&gt; select 8</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; keys *</span><br><span class="line">1) <span class="string">"score"</span></span><br><span class="line">2) <span class="string">"name"</span></span><br><span class="line">127.0.0.1:6379[8]&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[8]&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379[8]&gt; select 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">"score"</span></span><br><span class="line">2) <span class="string">"name"</span></span><br><span class="line">127.0.0.1:6379&gt; flushall</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>目前 Redis 对多数据库的支持开始弱化了，因为 Redis 是单线程架构，同一时间只有一个 <code>CPU</code> 为 Redis 服务，多个数据库同时存在不仅不会利用系统的多核优势，反而会由于单实例资源共享问题互相会有影响，导致出现问题时排错非常困难，Redis 实例如果一旦阻塞，那么所有的数据库都会受到影响。所以这是一个很鸡肋的功能，Redis 官方对其支持也在逐步弱化。<br>更合理的方式是一台机器启动多个 Redis 实例，互相隔离，充分利用 <code>CPU</code> 的多核优势。</p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redis 基础]]></title>
      <url>/2018/07/11/Redis-%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><a href="https://redis.io/" target="_blank" rel="noopener">Redis</a> 是一种基于键值对的 No-SQL 数据库，与很多键值对数据库不同的是，Redis 中的值可以由 string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等多种数据结构和算法组成，因此 Redis 可以满足很多应用场景，而且因为 Redis 会将所有数据都存放在内存中，所以它的读写性能非常惊人。另外 Redis 提供了 RDB 和 AOF 两种持久化方式，使得即使发生断电或者机器故障，数据也可以持久化到磁盘上，防止了数据的意外丢失。</p>
<h3 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h3><p>Linux 安装软件一般由两种方式，第一种是通过各个操作系统的软件包管理器进行安装，比如 Ubuntu 使用 apt-get，RedHat 系列使用 yum 安装。但是由于 Redis 的更新速度比较快，而各大 Linux 发行版的相应软件源更新却比较慢，因此直接通过这种方式安装无法获取较新的版本。所以一般推荐第二种方式：源码方式安装。Redis 的源码安装特别简单，没有第三方依赖，直接下载源码编译安装即可。通过以下命令编译安装 Redis 最新稳定版：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 gcc 相关编译工具</span></span><br><span class="line">sudo apt-get install -y build-essential</span><br><span class="line"><span class="comment"># 安装 make 打包工具</span></span><br><span class="line">sudo apt-get -y install make</span><br><span class="line"><span class="comment"># Use latest stable 下载最新稳定版源码</span></span><br><span class="line">wget -q http://download.redis.io/redis-stable.tar.gz</span><br><span class="line">tar zxvf redis-stable.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> redis-stable</span><br><span class="line"><span class="comment"># 编译源码</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<p>安装完成后可以通过如下命令查看 Redis 版本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant@redis:~$ redis-cli -v</span><br><span class="line">redis-cli 4.0.10</span><br></pre></td></tr></table></figure></p>
<h2 id="配置、启动、操作、关闭-Redis"><a href="#配置、启动、操作、关闭-Redis" class="headerlink" title="配置、启动、操作、关闭 Redis"></a>配置、启动、操作、关闭 Redis</h2><p>Redis 安装之后，Redis 源码目录 <code>src</code> 和 <code>/usr/local/bin</code> 目录多了几个以 redis 开头的可执行文件，我们称之为 Redis Shell，这些文件包括 Redis server 和 client 以及其他操作 Redis 的实用工具：</p>
<table>
<thead>
<tr>
<th style="text-align:left">可执行文件</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">redis-server</td>
<td style="text-align:left">Redis 服务端</td>
</tr>
<tr>
<td style="text-align:left">redis-cli</td>
<td style="text-align:left">Redis 命令行客户端</td>
</tr>
<tr>
<td style="text-align:left">redis-benchmark</td>
<td style="text-align:left">Redis 基准测试工具</td>
</tr>
<tr>
<td style="text-align:left">redis-check-rdb</td>
<td style="text-align:left">Redis AOF 持久化文件检测和修复工具</td>
</tr>
<tr>
<td style="text-align:left">redis-check-aof</td>
<td style="text-align:left">Redis RDB 持久化文件检测和修复工具</td>
</tr>
<tr>
<td style="text-align:left">redis-sentinel</td>
<td style="text-align:left">启动 Redis Sentinel</td>
</tr>
</tbody>
</table>
<h4 id="启动-Redis"><a href="#启动-Redis" class="headerlink" title="启动 Redis"></a>启动 Redis</h4><p>有三种方法启动 Redis：默认配置、运行配置、配置文件启动。</p>
<ol>
<li><p>默认配置<br>这种方式启动是直接执行 <code>redis-server</code> 来启动，后面没有任何参数，以默认的配置来启动。因为这种启动方式无法自定义配置，所以这种方式是不会在生产环境中使用。：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">vagrant@redis:~$ redis-server</span><br><span class="line">13622:C 11 Jul 02:27:09.542 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">13622:C 11 Jul 02:27:09.543 <span class="comment"># Redis version=4.0.10, bits=64, commit=00000000, modified=0, pid=13622, just started</span></span><br><span class="line">13622:C 11 Jul 02:27:09.543 <span class="comment"># Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf</span></span><br><span class="line">13622:M 11 Jul 02:27:09.546 <span class="comment"># You requested maxclients of 10000 requiring at least 10032 max file descriptors.</span></span><br><span class="line">13622:M 11 Jul 02:27:09.546 <span class="comment"># Server can't set maximum open files to 10032 because of OS error: Operation not permitted.</span></span><br><span class="line">13622:M 11 Jul 02:27:09.547 <span class="comment"># Current maximum open files is 4096. maxclients has been reduced to 4064 to compensate for low ulimit. If you need higher maxclients increase 'ulimit -n'.</span></span><br><span class="line">                _._</span><br><span class="line">           _.-``__ <span class="string">''</span>-._</span><br><span class="line">      _.-``    `.  `_.  <span class="string">''</span>-._           Redis 4.0.10 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">''</span>-._</span><br><span class="line"> (    <span class="string">'      ,       .-`  | `,    )     Running in standalone mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|'</span>` _.-<span class="string">'|     Port: 6379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-'</span>    |     PID: 13622</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">'    _.-'</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-'</span>_.-<span class="string">'    |           http://redis.io</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span></span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|</span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-'</span>_.-<span class="string">'    |</span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span></span><br><span class="line">      `-._    `-.__.-<span class="string">'    _.-'</span></span><br><span class="line">          `-._        _.-<span class="string">'</span></span><br><span class="line"><span class="string">              `-.__.-'</span></span><br><span class="line"></span><br><span class="line">13622:M 11 Jul 02:27:09.551 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">13622:M 11 Jul 02:27:09.552 <span class="comment"># Server initialized</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行启动<br>这种方式是执行 <code>redis-server</code> 时把配置参数通过命令行指定，没有设置的配置将使用默认配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-server --configKey1 configValue1 --configKey2 configValue2</span></span><br></pre></td></tr></table></figure>
<p> 例如要用 <code>6380</code> 作为端口启动 Redis，那么执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-server --port 6380</span></span><br></pre></td></tr></table></figure>
<p> 虽然这种方式可以自定义配置，但是如果需要修改的配置较多或者希望将配置保存到文件中，不建议使用这种方式。</p>
</li>
<li><p>配置文件启动<br>将配置写到文件里，例如我们将配置写到了 <code>/opt/redis/redis.conf</code> 中，那么只需执行如下命令即可启动 Redis：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis-server /opt/redis/redis.conf</span></span><br></pre></td></tr></table></figure>
<p> Redis 有 60 多种配置，这里给出一些基本的配置：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">配置名</th>
<th style="text-align:left">配置说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">port</td>
<td style="text-align:left">端口</td>
</tr>
<tr>
<td style="text-align:left">logfile</td>
<td style="text-align:left">日志文件</td>
</tr>
<tr>
<td style="text-align:left">dir</td>
<td style="text-align:left">Redis 工作目录（存放持久化文件和日志文件）</td>
</tr>
<tr>
<td style="text-align:left">daemonize</td>
<td style="text-align:left">是否以守护进程的方式启动 Redis</td>
</tr>
</tbody>
</table>
<h4 id="Redis-命令行客户端"><a href="#Redis-命令行客户端" class="headerlink" title="Redis 命令行客户端"></a>Redis 命令行客户端</h4><p>现在我们已经启动了 Redis 服务，下面介绍如何使用 <code>redis-cli</code> 连接、操作 Redis 服务。<code>redis-cli</code> 可以使用两种方式连接 Redis 服务。</p>
<ol>
<li><p>交互方式：通过 <code>redis-cli -h {host} -p {port}</code> 方式连接到 Redis 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vagrant@redis:~$ redis-cli -h localhost -p 6379</span><br><span class="line">localhost:6379&gt; keys *</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令方式：通过 <code>redis-cli -h {host} -p {port} {command}</code> 就可以直接得到返回结果，不需要启动 Redis shell 来交互访问：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant@redis:~$ redis-cli -h localhost -p 6379 get name</span><br><span class="line"><span class="string">"haohao"</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：如果 <code>-h</code> 参数没有指定，那么默认 <code>host</code> 是 <code>127.0.0.1</code> ，如果没有 <code>-p</code> 参数，那么默认 <code>6379</code> 端口，也就是说 <code>-h</code> 和 <code>-p</code> 都没写，就是连接 <code>127.0.0.1:6379</code> 这个实例。</p>
<h4 id="停止-Redis-服务"><a href="#停止-Redis-服务" class="headerlink" title="停止 Redis 服务"></a>停止 Redis 服务</h4><p>Redis 提供了 <code>shutdown</code> 命令来停止 Redis 服务，例如要停掉 <code>127.0.0.1</code> 上 <code>6379</code> 端口上的 Redis 服务，可以执行如下操作：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></table></figure></p>
<p>以这方式关闭 Redis 是一种优雅的方式，在关闭时会先将内存中的数据持久化到磁盘上（在配置文件中 <code>dir</code> 指定的目录中产生），然后关闭。如果直接 <code>kill -9</code> 强制杀掉不会产生持久化文件。<br>shutdown 还有一个参数，代表是否在关闭 Redis 前生产持久化文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown nosave|save</span><br></pre></td></tr></table></figure></p>
<h4 id="通过-Vagrantfile-安装配置-Redis"><a href="#通过-Vagrantfile-安装配置-Redis" class="headerlink" title="通过 Vagrantfile 安装配置 Redis"></a>通过 Vagrantfile 安装配置 Redis</h4><p>在此提供一个<a href="https://github.com/qhh0205/infra-vagrant" target="_blank" rel="noopener">安装 Redis 的 vagrant 工程</a>，通过 <code>vagrant up</code> 一键安装并配置 Redis，使用方式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:qhh0205/infra-vagrant.git</span><br><span class="line"><span class="built_in">cd</span> infra-vagrant/redis</span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure></p>
<h4 id="Redis-重大版本新增功能"><a href="#Redis-重大版本新增功能" class="headerlink" title="Redis 重大版本新增功能"></a>Redis 重大版本新增功能</h4><p><img src="/images/redis-change-log.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> Redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx upstream 失效转移机制研究]]></title>
      <url>/2018/07/08/Nginx-upstream-%E5%A4%B1%E6%95%88%E8%BD%AC%E7%A7%BB%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>经过多次模拟线上的环境测试，Nginx 负载均衡技术默认情况下已经对于 <code>connect refused</code>（状态码表现为 <code>502</code>）和 <code>time out</code>（状态码表现为 <code>504</code>）做了失效转移，使用的是 <code>upstream</code> 模块的 <code>proxy_next_upstream</code> 指令（这个选项默认是启动的）来实现。</p>
<p>对于 <code>http GET</code> 请求，当这个请求转发到上游服务器发生断路，或者读取响应超时则会将同样的请求转发到其他上游服务器来处理，如果所有服务器都超时或者断路，则会返回 <code>502</code> 或者 <code>504</code> 错误。</p>
<p>对于<code>http POST</code> 请求，当这个请求转发到上游服务器发生断路，则会将请求转发到其他上游服务器来处理，但是如果这个请求发生了读取超时，则不会做失效转移，会返回 <code>504</code> 错误，Nginx 之所以这么做应该是为了防止同一个请求发送两次，比如涉及到银行的充值等操作就会发生很严重的 bug。以下是模拟线上的场景测试得出的结论：</p>
<ol>
<li>上游服务器有两台，一台处于 down 状态，另一台处于正常服务状态，那么来自客户端的 <code>GET</code> 和 <code>POST</code> 请求都会通过 Nginx 的失效转移机制路由到正常状态的机器，返回 <code>200</code> 状态码，并不会返回给客户端 <code>502</code> 错误；</li>
<li>上游服务器有两台，两台都 down 了，那么会不管是 <code>GET</code> 还是 <code>POST</code> 请求都会直接返回给客户端 <code>502</code> 错误；</li>
<li>上游服务器有两台，一台机器的 <code>http GET</code> 和 <code>POST</code> 接口都正常 return，另一台相同的接口死循环，模拟超时。<br>这种情况下如果客户端的请求路由到了正常机器，那么直接返回 <code>200</code>。<br>如果请求路由到了死循环的接口，并且是 <code>GET</code> 请求，那么会等待 Nginx 设置的超时时间过后，然后将请求转发到另一台机器的正常接口。<br>如果请求路由到了死循环的接口，并且是 <code>POST</code> 请求，那么等待 nginx 设置的超时时间过后直接返回 <code>504</code>，没有进行失效转移，防止请求的重复发送；</li>
<li>上游服务器有两台，两台机器的 <code>http GET</code> 和 <code>POST</code> 接口都死循环，模拟超时，那么对于  <code>GET</code> 请求会进行请求转发到另一台尝试，对于 <code>POST</code> 请求直接返回 <code>504</code>，不会进行进一步尝试；</li>
</ol>
<h3 id="论证环境及工具"><a href="#论证环境及工具" class="headerlink" title="论证环境及工具"></a>论证环境及工具</h3><ul>
<li>一台前端 Nginx 服务器；</li>
<li>两台上游服务器；</li>
<li>Nginx 配置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span>       <span class="number">443</span>;</span><br><span class="line">  <span class="attribute">server_name</span> ngxfailover.xxx.me;</span><br><span class="line">  <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">ssl_certificate</span> xxx/xxx.crt;</span><br><span class="line">  <span class="attribute">ssl_certificate_key</span> xxx/xxx.key;</span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">     <span class="attribute">proxy_pass</span> http://py_web_upstream;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">upstream</span> py_web_upstream&#123;</span><br><span class="line">      <span class="attribute">server</span> upstream_server1:<span class="number">5000</span>;</span><br><span class="line">      <span class="attribute">server</span> upstream_server2:<span class="number">5000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一台上游服务器正常代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/a/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">failover_get_method</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> name</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;I am Server2, My name is %s &lt;/h1&gt;'</span> % name</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/b/&lt;name&gt;', methods=["POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">failover_post_method</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> name</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;I am Server2, My name is %s &lt;/h1&gt;'</span> % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>, host=<span class="string">'0.0.0.0'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>第二台上游服务器超时代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/a/&lt;name&gt;')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">failover_get_method</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> name</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        time.sleep(<span class="number">256</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;I am Server2, My name is %s &lt;/h1&gt;'</span> % name</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/b/&lt;name&gt;', methods=["POST"])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">failover_post_method</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> name</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        time.sleep(<span class="number">256</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;h1&gt;I am Server2, my name is %s &lt;/h1&gt;'</span> % name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(debug=<span class="keyword">True</span>, host=<span class="string">'0.0.0.0'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="论证过程"><a href="#论证过程" class="headerlink" title="论证过程"></a>论证过程</h3><p>以下为前面 4 种案例的论证过程：</p>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h4><p>上游服务器有两台，一台处于 down 状态，另一台处于正常服务状态。</p>
<p>在这种情况下，通过 <code>curl</code> 多次发送 <code>GET</code> 和 <code>POST</code> 请求，发现不管怎么请求，返回都是正常状态，如果 Nginx 发生了失败尝试操作，那么会在 Nginx access 日志中的 upstream 字段看到有两个服务器的地址。</p>
<p><strong>发送 GET 和 POST 请求：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET https://ngxfailover.xxx.me/a/hello</span><br><span class="line">curl -XPOST https://ngxfailover.xxx.me/b/hello</span><br></pre></td></tr></table></figure>
<p><strong>观察日志：</strong></p>
<p>可以看出所有请求都成功了，红框框圈起来的请求表示发生了失效转移，并且请求成功。<br><img src="/images/ngx_failover_log1.png" alt=""></p>
<h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h4><p>上游服务器有两台，两台服务器都处于 down 状态。</p>
<p>在这种情况下不管是 <code>GET</code> 还是 <code>POST</code> 请求都会直接返回给客户端 <code>502</code> 错误。</p>
<p><strong>发送 GET 和 POST 请求：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET https://ngxfailover.xxx.me/a/hello</span><br><span class="line">curl -XPOST https://ngxfailover.xxx.me/b/hello</span><br></pre></td></tr></table></figure>
<p><strong>观察日志：</strong><br>可以看出所有请求全部返回 <code>502</code> 错误，红框框圈起来的请求表示发生了失效转移，但是还是失败了。<br><img src="/images/ngx_failover_log2.png" alt=""></p>
<h4 id="案例-3"><a href="#案例-3" class="headerlink" title="案例 3"></a>案例 3</h4><p>上游服务器有两台，一台机器的 <code>http GET</code> 和 <code>POST</code> 接口都正常 return，另一台相同的接口死循环，模拟超时。</p>
<p>这种情况下如果客户端的请求路由到了正常机器，那么直接返回 <code>200</code>。</p>
<p>如果请求路由到了死循环的接口，并且是 <code>GET</code> 请求，那么会等待 Nginx 设置的超时时间过后，然后将请求转发到另一台机器的正常接口。</p>
<p>如果请求路由到了死循环的接口，并且是 <code>POST</code> 请求，那么等待 Nginx 设置的超时时间过后直接返回客户端 <code>504</code> 错误，没有进行失效转移，防止请求的重复发送。</p>
<p><strong>发送 GET 请求：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET https://ngxfailover.xxx.me/a/hello</span><br></pre></td></tr></table></figure>
<p><strong>观察日志：</strong></p>
<p>可以看到对于 <code>GET</code> 请求全部成功，红框框圈起来的表示发生了失效转移，第一台超时后会是继续尝试第二台，最终成功。<br><img src="/images/ngx_failover_log3.png" alt=""></p>
<p><strong>发送 POST 请求：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST https://ngxfailover.xxx.me/b/hello</span><br></pre></td></tr></table></figure>
<p><strong>观察日志：</strong></p>
<p>可以看到对于 <code>POST</code> 请求，如果 Nginx 等待上游服务器处理请求超时，并不会发生失效转移，直接返回给客户端 <code>504</code> 错误。<br><img src="/images/ngx_failover_log4.png" alt=""></p>
<h4 id="案例-4"><a href="#案例-4" class="headerlink" title="案例 4"></a>案例 4</h4><p>上游服务器有两台，两台机器的 <code>http GET</code> 和 <code>POST</code> 接口都死循环，模拟超时。</p>
<p>这种情况下对于 <code>GET</code> 请求会将请求转发到另一台尝试，对于 <code>POST</code> 请求直接返回 <code>504</code> 错误，不会进行进一步尝试。</p>
<p><strong>发送 GET 请求：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET https://ngxfailover.xxx.me/a/hello</span><br></pre></td></tr></table></figure>
<p><strong>观察日志：</strong></p>
<p>可以看出对于 <code>GET</code> 请求，Nginx 在等待超时会继续进行尝试，两台都尝试失败后返回了 <code>504</code> 错误。<br><img src="/images/ngx_failover_log5.png" alt=""></p>
<p><strong>发送 POST 请求：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST https://ngxfailover.xxx.me/b/hello</span><br></pre></td></tr></table></figure>
<p><strong>观察日志：</strong></p>
<p>可以看出对于 <code>POST</code> 请求，Nginx 在等待超时会不继续进行尝试其他上游服务器，直接返回 <code>504</code> 错误。<br><img src="/images/ngx_failover_log6.png" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总体来看 Nginx 的失效转移技术已经非常成熟，Nginx 默认情况下对于 <code>connect refused</code>（状态码表现为 <code>502</code>）和 <code>time out</code>（状态码表现为 <code>504</code>）已经做了失效转移，并且 Nginx 根据请求的类型不同，对失效转移的策略也不同。对于服务器后台状态没有改变的请求（比如 <code>GET</code> 请求）会进行失效转移，对于服务后台状态有改变的请求（比如 <code>POST</code> 请求），有失效转移机制，这也符合 Rest API 的冪等性标准。如果要强行加其他状态码的失效转移，比如 <code>500</code>、<code>503</code> 等，需要考量下业务请求是否能容忍请求的重复发送。</p>
]]></content>
      
        <categories>
            
            <category> Nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu 下添加开机启动脚本]]></title>
      <url>/2018/07/08/Ubuntu-%E4%B8%8B%E6%B7%BB%E5%8A%A0%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<h2 id="Ubuntu-下添加开机启动脚本"><a href="#Ubuntu-下添加开机启动脚本" class="headerlink" title="Ubuntu 下添加开机启动脚本"></a>Ubuntu 下添加开机启动脚本</h2><p>本文介绍在 Ubuntu 下添加开机启动脚本的两种方法：</p>
<ol>
<li><p>编辑 <code>/etc/rc.local</code> 文件<br>Ubuntu 会在启动时自动执行 <code>/etc/rc.local</code>  文件中的脚本，默认该文件中有效的脚本代码为空，把需要执行的脚本添加到该文件的 <code>exit 0</code> 之前即可，举例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/sh -e</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rc.local</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This script is executed at the end of each multiuser runlevel.</span></span><br><span class="line"><span class="comment"># Make sure that the script will "exit 0" on success or any other</span></span><br><span class="line"><span class="comment"># value on error.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to enable or disable this script just change the execution</span></span><br><span class="line"><span class="comment"># bits.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default this script does nothing.</span></span><br><span class="line"><span class="built_in">cd</span> /home/ubuntu</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello,world'</span> &gt;&gt; rc.local.log</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>update-rc.d</code> 命令添加开机自启动脚本<br>Ubuntu 服务器在启动时会自动执行 <code>/etc/init.d</code> 目录下的脚本，所以我们可以将需要执行的脚本放到 <code>/etc/init.d</code> 目录下，或者在该目录下创建一个软件链接指向其他位置的脚本路径，然后通过 <code>update-rc.d</code> 将脚本添加到开机自启动。启动脚本必须以 <code>#!/bin/bash</code> 开头。举例如下：<br>新建开机启动脚本 <code>start_when_boot</code>，放置到 <code>/etc/init.d</code> 目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /home/ubuntu</span><br><span class="line">date &gt;&gt; boot.log</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'hello, world'</span> &gt;&gt; boot.log</span><br></pre></td></tr></table></figure>
<p> 执行 <code>update-rc.d start_when_boot defaults</code> 将上述脚本添加为开机启动；<br> 执行 <code>update-rc.d -f start_when_boot remove</code> 将上述开机启动脚本移除；</p>
</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://wangheng.org/ubuntu-to-add-boot-script.html" target="_blank" rel="noopener">https://wangheng.org/ubuntu-to-add-boot-script.html</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 cli53 自动化管理 Aws Route53]]></title>
      <url>/2018/06/10/%E4%BD%BF%E7%94%A8-cli53-%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86-Aws-Route53/</url>
      <content type="html"><![CDATA[<h3 id="cli53-工具"><a href="#cli53-工具" class="headerlink" title="cli53 工具"></a>cli53 工具</h3><p>cli53 是一个开源的命令行管理 Aws Route53 的工具，非常实用，可以通过命令行来进行域名及相关记录的创建、更新、删除、记录的导出备份、记录的导入恢复等。配置域名时无需在 Aws 界面控制台操作，只需用命令操作即可，能在一定程度上提高效率，将工作代码化。<br>工具地址（Go 语言版）：<a href="https://github.com/barnybug/cli53" target="_blank" rel="noopener">https://github.com/barnybug/cli53</a><br>该工具还有个 Python 版本，是同一个作者，但是 Python 版的已不再维护，目前主要支持 Go 语言版的。</p>
<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><p><a href="https://github.com/barnybug/cli53" target="_blank" rel="noopener">https://github.com/barnybug/cli53</a></p>
<p>Mac 下安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cli53</span><br></pre></td></tr></table></figure></p>
<h4 id="2-配置-AWS-访问密钥"><a href="#2-配置-AWS-访问密钥" class="headerlink" title="2. 配置 AWS 访问密钥"></a>2. 配置 AWS 访问密钥</h4><ul>
<li>在控制台新建拥有 Route53 访问权限的 IAM 账号，获取 aws key</li>
</ul>
<p><img src="/images/cli53.png" alt="这里写图片描述"></p>
<ul>
<li>将 aws key 添加到环境变量<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> AWS_ACCESS_KEY_ID=<span class="string">"xxxx"</span></span><br><span class="line"><span class="built_in">export</span> AWS_SECRET_ACCESS_KEY=<span class="string">"xxxxx"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="使用方法总结"><a href="#使用方法总结" class="headerlink" title="使用方法总结"></a>使用方法总结</h4><p>1.创建一个域名托管（指定的域名必须是有效的，否则报错）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 create example.com --comment <span class="string">'my first zone'</span></span><br></pre></td></tr></table></figure></p>
<p>2.列出 Rout53 当前所有域名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 list</span><br></pre></td></tr></table></figure></p>
<p>3.导入 BIND 区域文件（用来做域名迁移）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 import --file zonefile.txt example.com</span><br></pre></td></tr></table></figure></p>
<p>4.导出域名 BIND 区域文件（用来备份，防止误操作导致不可恢复）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导出非完全符合标准的 bind 文件</span></span><br><span class="line">cli53 <span class="built_in">export</span> example.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出完全符合标准的 bind 文件（一般使用该命令备份）</span></span><br><span class="line">cli53 <span class="built_in">export</span> --full example.com</span><br></pre></td></tr></table></figure></p>
<p>5.创建一个 A 记录指向 <code>192.168.0.1</code>，并设置 TTL 为 <code>60s</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 rrcreate example.com <span class="string">'www 60 A 192.168.0.1'</span></span><br></pre></td></tr></table></figure></p>
<p>6.更新上面创建的 A 记录，指向 <code>192.168.0.2</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 rrcreate --replace example.com <span class="string">'www 60 A 192.168.0.2'</span></span><br></pre></td></tr></table></figure></p>
<p>7.删除一个 A 记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 rrdelete example.com www A</span><br></pre></td></tr></table></figure></p>
<p>8.创建一个 MX 记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 rrcreate example.com <span class="string">'@ MX 10 mail1.'</span> <span class="string">'@ MX 20 mail2.'</span></span><br></pre></td></tr></table></figure></p>
<p>9.创建一个轮询的 A 记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 rrcreate example.com <span class="string">'@ A 127.0.0.1'</span> <span class="string">'@ A 127.0.0.2'</span></span><br></pre></td></tr></table></figure></p>
<p>10.创建 CNAME 记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cli53 rrcreate example.com <span class="string">'login CNAME www'</span></span><br><span class="line">cli53 rrcreate example.com <span class="string">'mail CNAME ghs.googlehosted.com.'</span></span><br></pre></td></tr></table></figure></p>
<p>11.创建 ELB 别名记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 rrcreate example.com <span class="string">'www AWS ALIAS A dns-name.elb.amazonaws.com. ABCDEFABCDE false'</span></span><br></pre></td></tr></table></figure></p>
<p>12.删除一个域名（⚠️危险 删除时如果域名有记录则必须指定 <code>--purge</code> 选项）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 delete --purge example.com</span><br></pre></td></tr></table></figure></p>
<p>13.删除一个域名的所有记录（⚠️危险）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cli53 rrpurge example.com</span><br></pre></td></tr></table></figure></p>
<h4 id="域名导入注意事项"><a href="#域名导入注意事项" class="headerlink" title="域名导入注意事项"></a>域名导入注意事项</h4><p>有的域名提供商，比如 GoDaddy 提供域名记录导出功能，但是导出来后的 BIND 域文件并不是符合标准的，<code>CNAME</code><br>或者 <code>MX</code> 记录末尾没有圆点 <code>.</code>，这样在导入 Route53 后会出现问题，需要在导入之前用如下命令处理一下文件<br>（<code>MX</code> 和 <code>CNAME</code> 记录末尾添加圆点）再导入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl -pe <span class="string">'s/((CNAME|MX\s+\d+)\s+[-a-zA-Z0-9._]+)(?!.)$/$1./i'</span> broken.txt &gt; fixed.txt</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Aws </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 根据本地时间获取 UTC 偏移量]]></title>
      <url>/2018/06/09/Python-%E6%A0%B9%E6%8D%AE%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96-UTC-%E5%81%8F%E7%A7%BB%E9%87%8F/</url>
      <content type="html"><![CDATA[<p>在 <a href="https://stackoverflow.com/" target="_blank" rel="noopener">so</a> 上查了一下，可以用如下代码获取本地时间相对于 UTC 时间的偏移量，代码实现思路比较简单，分别获取本地时间和和 UTC 时间，然后本地时间减去 UTC 时间即可得到相对于 UTC 的偏移小时，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/4/6 上午10:28</span></span><br><span class="line"><span class="comment"># @Author  : qhh0205</span></span><br><span class="line"><span class="comment"># @Mail    : qhh0205@gmail.com</span></span><br><span class="line"><span class="comment"># @File    : utc_offset.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">ts = time.time()</span><br><span class="line">utc_offset = int((datetime.fromtimestamp(ts) - datetime.utcfromtimestamp(ts)).total_seconds() / <span class="number">3600</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"UTC%+-d"</span> % utc_offset</span><br></pre></td></tr></table></figure></p>
<p>参考链接（so 讨论）：<br><a href="https://stackoverflow.com/questions/3168096/getting-computers-utc-offset-in-python?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa" target="_blank" rel="noopener">https://stackoverflow.com/questions/3168096/getting-computers-utc-offset-in-python?utm_medium=organic&amp;utm_source=google_rich_qa&amp;utm_campaign=google_rich_qa</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Shadowsocks + Privoxy 搭建 http 代理服务]]></title>
      <url>/2018/05/20/Shadowsocks-Privoxy-%E6%90%AD%E5%BB%BA-http-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>目前很多软件都支持配置 http 代理来加速访问，或者绕过 GFW 来获取需要的资源。比如 docker、git、gcloud、curl 这些软件都支持 http 代理。那么我们该如何轻松地基于 shadowsocks 搭建一个 http 代理，其实很简单，使用 privoxy 代理软件将收到的 http 请求转发给 shadowsocks 客户端即可。</p>
<h3 id="Shadowsocks-软件整体架构"><a href="#Shadowsocks-软件整体架构" class="headerlink" title="Shadowsocks 软件整体架构"></a>Shadowsocks 软件整体架构</h3><p>如下图所示，shadowsocks 由两部分组成：客户端（SS Local），服务端（SS Server）。客户端就是用来做本地 Sock5 代理的，代理本地 PC 的请求和服务端通信，我们一般在手机、平板、PC 上安装的图形化 shadowsokcs 软件就是 SS 客户端软件，当然如果在 Linux 下，也有SS 客户端：<code>sslocal</code>，后面会介绍到如何配合 <code>privoxy</code> 来实现 <code>http</code> 代理服务。服务端就是在 Linux 服务器上安装的 shadowsocks 服务端软件，供客户端连接，我们一般说的搭建 shadowsocks 代理就是在服务器上安装并配置 SS Server。<br><img src="/images/ss-privoxy-http1.png" alt="Alt text"></p>
<h3 id="Shadowsocks-privoxy-搭建-http-代理服务步骤"><a href="#Shadowsocks-privoxy-搭建-http-代理服务步骤" class="headerlink" title="Shadowsocks + privoxy 搭建 http 代理服务步骤"></a>Shadowsocks + privoxy 搭建 http 代理服务步骤</h3><p>整体架构如下图所示，我们需要找一台机器将 SS Server 搭建好，然后在局域网内的任何一台 Linux 服务器安装 SS Local 和 Privoxy，Privoxy 暴露 8118 端口作为 http 代理的端口：<br><img src="/images/ss-privoxy-http2.png" alt="Alt text"></p>
<h4 id="1-安装配置-Shadowsocks-Server-端（ssserver）"><a href="#1-安装配置-Shadowsocks-Server-端（ssserver）" class="headerlink" title="1. 安装配置 Shadowsocks Server 端（ssserver）"></a>1. 安装配置 Shadowsocks Server 端（ssserver）</h4><p>Shadowsocks 是用 Python 编写的，因此可以通过如下命令直接安装（sslocal 和 ssserver 均已安装）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure></p>
<p>接下来编写 Shadowsocks Server 端的配置文件，配置监听端口，加密方式，密码等，新建 <code>/etc/shadowsocks.json</code> 文件，填入如下内容：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>, </span><br><span class="line">    "server_port":1851, # SS Server 端口</span><br><span class="line">    "local_address": "127.0.0.1", #SS Local 端配置，不影响Server端使用</span><br><span class="line">    "local_port":1080,  #SS Local 端配置，不影响Server端使用</span><br><span class="line">    "password":"xxxxx",</span><br><span class="line">    "timeout":300,</span><br><span class="line">    "method":"aes-256-cfb",</span><br><span class="line">    "fast_open": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用配置文件启动 SS Server：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></p>
<h4 id="2-安装配置-Shadowsocks-客户端（sslocal）"><a href="#2-安装配置-Shadowsocks-客户端（sslocal）" class="headerlink" title="2. 安装配置 Shadowsocks 客户端（sslocal）"></a>2. 安装配置 Shadowsocks 客户端（sslocal）</h4><p>第一步已将 SS Server 安装并配置完成，服务端口为 <code>1851</code> ，接下来在需要安装 http 代理的机器上安装配置 shadowsocks 客户端，安装方法和第一步一样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure></p>
<p>编写 SS Local 客户端配置文件，配置远程连接 SS Server 的 IP，端口，密码，加密方式等，新建 <code>/etc/shadowsocks.json</code> 文件，填入如下内容：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "server":"xxx.xxx.xxx.xxx", # SS Server 端服务器公网 IP</span><br><span class="line">    "server_port":1851, # SS Server 端口</span><br><span class="line">    "local_address": "127.0.0.1", # SS Local 本地监听 IP</span><br><span class="line">    "local_port：":1080, # SS Local 本地监听端口</span><br><span class="line">    "password":"xxxxxx",</span><br><span class="line">    "timeout":300,</span><br><span class="line">    "method":"aes-256-cfb",</span><br><span class="line">    "fast_open": false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用配置文件启动 SS Local：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json -d start</span><br></pre></td></tr></table></figure></p>
<h4 id="3-安装并配置-Privoxy"><a href="#3-安装并配置-Privoxy" class="headerlink" title="3. 安装并配置 Privoxy"></a>3. 安装并配置 Privoxy</h4><p>Privoxy 是一款代理软件，我们这里用该代理软件实现 HTTP 到 Socks5 的转换，所有来自 Privoxy 的请求被转发到 SS Local，从而实现了一个 HTTP 代理服务，Privoxy 的安装非常简单，直接 <code>yum</code> 一键搞定：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install privoxy</span><br></pre></td></tr></table></figure></p>
<p>编辑 Privoxy 配置文件 <code>/etc/privoxy/config</code>，搜索关键字 <code>listen-address</code> 找到 <code>listen-address 127.0.0.1:8118</code> 这一句，改成 <code>listen-address  0.0.0.0:8118</code>，表示该代理可以对外访问。<br>接下来在该配置该文件末尾添加 HTTP 请求转发到 SS Local Socks5 的配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5t / <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1080</span> .</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>forward-socks5t</code>: 表示 Privoxy 转发请求到 Socks5 协议；</li>
<li><code>127.0.0.1</code>: 第二步中启动 SS Local 本地绑定 IP；</li>
<li><code>1080</code>: 第二步中启动 SS Local 本地监听端口；</li>
</ul>
<p>启动 Privoxy：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart privoxy</span><br><span class="line">systemctl <span class="built_in">enable</span> privoxy</span><br></pre></td></tr></table></figure></p>
<h4 id="4-测试代理是否可用"><a href="#4-测试代理是否可用" class="headerlink" title="4. 测试代理是否可用"></a>4. 测试代理是否可用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -x privoxy_ip:8118 https://www.google.com</span><br></pre></td></tr></table></figure>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://vc2tea.com/whats-shadowsocks/" target="_blank" rel="noopener">https://vc2tea.com/whats-shadowsocks</a><br><a href="https://docs.lvrui.io/2016/12/12/Linux%E4%B8%AD%E4%BD%BF%E7%94%A8ShadowSocks-Privoxy%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">https://docs.lvrui.io/2016/12/12/Linux%E4%B8%AD%E4%BD%BF%E7%94%A8ShadowSocks-Privoxy%E4%BB%A3%E7%90%86</a></p>
]]></content>
      
        <categories>
            
            <category> Shadowsocks </category>
            
        </categories>
        
        
        <tags>
            
            <tag> http 代理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何 dump jvm 内存及线程栈]]></title>
      <url>/2018/05/19/%E5%A6%82%E4%BD%95-dump-jvm-%E5%86%85%E5%AD%98%E5%8F%8A%E7%BA%BF%E7%A8%8B%E6%A0%88/</url>
      <content type="html"><![CDATA[<p>目前很多企业的后台服务都是 java 服务，在故障出现时能及时 dump jvm 内存和线程栈对于故障的分析及定位是非常重要的。接下来介绍如何进行 dump 操作，并分享一个简单脚本实现服务器线程数超过一定阀值时自动 dump 线程数最高的 java 进程的内存及线程栈。</p>
<h4 id="1-dump-jvm-内存"><a href="#1-dump-jvm-内存" class="headerlink" title="1. dump jvm 内存"></a>1. dump jvm 内存</h4><p>命令格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=dump_file_name pid</span><br></pre></td></tr></table></figure></p>
<p>举例：dump pid 为 <code>4738</code> 的 java 进程的内存到 <code>app_mem_dump.bin</code> 文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=app_mem_dump.bin 4738</span><br></pre></td></tr></table></figure></p>
<h4 id="2-dump-jvm-线程栈"><a href="#2-dump-jvm-线程栈" class="headerlink" title="2. dump jvm 线程栈"></a>2. dump jvm 线程栈</h4><p>命令格式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack pid &gt; dump_file_name</span><br></pre></td></tr></table></figure></p>
<p>举例：dump pid 为 <code>4738</code> 的 java 进程的线程栈到 <code>app_thread_dump.txt</code> 文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 4738 &gt; app_thread_dump.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="脚本分享"><a href="#脚本分享" class="headerlink" title="脚本分享"></a>脚本分享</h3><p>当服务器线程数超过 2500 时自动 dump 线程数最高的 java 进程的内存及线程栈。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 服务器线程数达到 2500 以上时 dump 线程数最多的 java 进程的线程及内存</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line">cur_thread_num=`ps -efL | wc -l`</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$cur_thread_num</span> -le 2500 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">cur_date=`date +<span class="string">"%Y-%m-%d_%H-%M-%S"</span>`</span><br><span class="line"><span class="built_in">cd</span> ./dumpfile</span><br><span class="line"><span class="comment"># 服务器当前线程 dump 到文件:按照线程数由大到小排序显示</span></span><br><span class="line">ps -efL --sort -nlwp &gt; server_thread_dump_<span class="variable">$cur_date</span></span><br><span class="line"><span class="comment"># dump 线程数最多的 jvm 的线程及内存</span></span><br><span class="line">most_thread_num_pid=`cat server_thread_dump_<span class="variable">$cur_date</span> | sed -n <span class="string">'2p'</span> | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">nohup jstack -l <span class="variable">$most_thread_num_pid</span> &gt; java_app_thread_dump_<span class="variable">$&#123;cur_date&#125;</span>_pid_<span class="variable">$&#123;most_thread_num_pid&#125;</span> &amp;</span><br><span class="line">nohup jmap -dump:format=b,file=java_app_mem_dump_<span class="variable">$&#123;cur_date&#125;</span>_pid_<span class="variable">$&#123;most_thread_num_pid&#125;</span> <span class="variable">$most_thread_num_pid</span> &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自定义 Zabbix 监控指标及图表]]></title>
      <url>/2018/05/19/%E8%87%AA%E5%AE%9A%E4%B9%89-Zabbix-%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E5%8F%8A%E5%9B%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p> 有时候 Zabbix 监控系统的模版提供的监控指标并不能满足我们的需求，比如我们要监控服务器的线程数、TCP 连接数等，这些指标在 Zabbix 自带的模板中是没有的，这时候我们就需要自定义监控指标来实现可视化监控。本文以监控服务器的 TCP 连接数为例来说明如何自定义监控指标来实现可视化监控。</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p><strong>总体思路是：</strong><br>修改 Zabbix Agent 端的配置文件，添加监控指标的键值对 –&gt; 重启 Zabbix Agent –&gt; 在 Zabbix Server 端界面化控制台中的模板添加监控指标，指定配置文件中的键 –&gt; 创建指标的可视化展示。<br>以下分步图文列出如何操作：</p>
<h4 id="1-修改-Zabbix-Agent-端配置文件，添加监控指标的键值对"><a href="#1-修改-Zabbix-Agent-端配置文件，添加监控指标的键值对" class="headerlink" title="1. 修改 Zabbix Agent 端配置文件，添加监控指标的键值对"></a>1. 修改 Zabbix Agent 端配置文件，添加监控指标的键值对</h4><p><code>vim</code> 打开 Zabbix Agent 端配置文件 <code>/home/zabbix/zabbix/etc/zabbix_agentd.conf</code> ，末尾添加如下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UnsafeUserParameters=1</span><br><span class="line">UserParameter=tcp.num,netstat -atunp | grep ESTABLISHED | wc -l</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>UnsafeUserParameters</code>: 自定义指标必需要添加该行；</li>
<li><code>UserParameter</code>: 自定义指标的参数；</li>
<li><code>tcp.num</code>: 监控指标的键，在 Zabbix Server 端创建监控指标时会用到，可以随意命名，比如 <code>tcp.count</code>；</li>
<li><code>netstat -atunp | grep ESTABLISHED | wc -l</code>：监控指标的值（注意：该值必须是数值类型，否则报错），获取服务器的 TCP 连接数，键和值之间通过英文逗号分隔；</li>
</ul>
<h4 id="2-重启-Zabbix-Agent-端"><a href="#2-重启-Zabbix-Agent-端" class="headerlink" title="2. 重启 Zabbix Agent 端"></a>2. 重启 Zabbix Agent 端</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/zabbix/zabbix/sbin/zabbix_agentd -c /home/zabbix/zabbix/etc/zabbix_agentd.conf</span><br></pre></td></tr></table></figure>
<h4 id="3-在-Zabbix-Server-端界面化控制台创建监控指标"><a href="#3-在-Zabbix-Server-端界面化控制台创建监控指标" class="headerlink" title="3. 在 Zabbix Server 端界面化控制台创建监控指标"></a>3. 在 Zabbix Server 端界面化控制台创建监控指标</h4><p>为了让所有监控机器都能生效，所以在这里选择 Zabbix Server 自带的系统模板 <code>Template OS Linux</code> 中添加指标：<br><img src="/images/zbx_custom_metrix1.png" alt=""><br><img src="/images/zbx_custom_metrix2.png" alt=""><br><img src="/images/zbx_custom_metrix3.png" alt=""></p>
<h4 id="4-创建指标的可视化展示"><a href="#4-创建指标的可视化展示" class="headerlink" title="4. 创建指标的可视化展示"></a>4. 创建指标的可视化展示</h4><p>在第三步中已经完成了监控指标的创建，即 Zabbix Server 已经开始收集 Agent 端的数据，但是我们还没有配置相应指标的可视化图表展示，无法看到该指标随时间的推移的变化趋势，接下来我们创建一个梯度图来可视化展示该指标的变化:</p>
<p><img src="/images/zbx_custom_metrix4.png" alt=""><br><img src="/images/zbx_custom_metrix5.png" alt=""><br><img src="/images/zbx_custom_metrix6.png" alt=""><br><img src="/images/zbx_custom_metrix7.png" alt=""></p>
<p>到这里该指标的可视化图表已创建完成，可以跳转到控制台首页查看相应 Zabbix Agent 的图表：<br><img src="/images/zbx_custom_metrix8.png" alt=""></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>由于 <code>netstat</code> 命令在非 root 用户下使用会有警告信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zabbix@awsuw7-189 ~]$ netstat -atunp | grep ESTABLISHED | wc -l</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">329</span><br></pre></td></tr></table></figure></p>
<p>这样 Zabbix Agent 配置文件中使用 <code>netstat -atunp | grep ESTABLISHED | wc -l</code> 获取到的 <code>value</code> 会是上面所有的输出（即字符串类型），而不是 <code>wc -l</code> 得到的数值类型，从而导致配置自定义监控指标后会报错：<br><img src="/images/zbx_custom_metrix9.png" alt=""></p>
<p>解决方法其实比较简单，切换到 root 用户给 <code>netstat</code> 命令添加 <code>s</code> 权限即可解决：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@awsuw7-189 ~]<span class="comment"># chmod u+s /bin/netstat</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Zabbix </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Zabbix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vagrant Shell 配置器的使用]]></title>
      <url>/2018/05/06/Vagrant-Shell-%E9%85%8D%E7%BD%AE%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="Vagrant-Shell-配置器的使用"><a href="#Vagrant-Shell-配置器的使用" class="headerlink" title="Vagrant Shell 配置器的使用"></a>Vagrant Shell 配置器的使用</h2><blockquote>
<p><strong>摘要：</strong> 本文翻译自 <a href="https://www.vagrantup.com/docs/" target="_blank" rel="noopener">Vagrant</a> 官方文档 <a href="https://www.vagrantup.com/docs/provisioning/file.html#destination" target="_blank" rel="noopener">Shell Provisioner</a> 部分，主要介绍了 Vagrant Shell 配置器的使用，如何使用内联脚本代码和外部脚本文件来配置虚拟机。</p>
</blockquote>
<p><strong>Provisioner name:</strong> “shell”</p>
<p>Vagrant Shell 配置器允许你向虚拟机上传脚本并执行。</p>
<p>对于想要快速启动和运行 Vagrant 的新手来说，Shell 配置器非常理想，并为不熟悉 <code>Chef</code> 或 <code>Puppet</code> 等配置管理系统的用户提供了选择。</p>
<p>对于类 POSIX 机器，shell 配置器使用 SSH 执行脚本。对于 Windows 机器，使用 WinRM 来执行脚本，shell 配置器通过 WinRM 执行 PowerShell 和 Batch （<strong>译者注：批处理</strong>） 脚本。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>shell 配置器有很多选项，其中 <code>inline</code> 或者 <code>path</code> 选项是必须的：</p>
<ul>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#inline" target="_blank" rel="noopener">inline</a> (string) - 指定在远程机器执行的 shell 内联命令。更多信息见下面 <a href="https://www.vagrantup.com/docs/provisioning/shell.html#inline-scripts" target="_blank" rel="noopener">inline scripts</a> 章节。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#path" target="_blank" rel="noopener">path</a> (string) - 要上传并执行的 shell 脚本路径。该脚本可以是一个相对于 Vagrantfile 工程的文件或者是一个远程脚本（比如 <a href="https://gist.github.com/" target="_blank" rel="noopener">gist</a>）。</li>
</ul>
<p>剩下的这些选项是可选的：</p>
<ul>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#args" target="_blank" rel="noopener">args</a> (string or array) - 当以单一字符串执行脚本时，传递给脚本的参数。这些参数必须写得好像它们直接在命令行上键入一样，所以在需要时一定要避免字符、引号等。你也可以使用数组来传递参数。在这种情况下，Vagrant 将会为你处理引用。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#env" target="_blank" rel="noopener">env</a> (string) - 传递给脚本作为环境变量的键值对。Vagrant 会处理环境变量值的引用，但是键保持不变。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#binary" target="_blank" rel="noopener">binary</a> (boolean) - Vagrant 会自动用 Unix 换行符来代替 Windows 换行符。如果设置为 false，不会替换。默认值是 “false”。如果 shell 配置器通过 WinRM 来交互，那么默认值是 “true”。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#privileged" target="_blank" rel="noopener">privileged</a> (boolean) - 指定是否以超级用户执行脚本。默认是 “true”。Windows guest 虚拟机使用计划任务作为真正的管理员运行，而不受WinRM限</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#upload_path" target="_blank" rel="noopener">upload_path</a> (string) - 上传脚本的远程路径。脚本将会通过 SCP 上传到 SSH 用户，因此该路径对于 SSH 用户必须是可写的。默认路径是 <code>/tmp/vagrant-shell</code>。在 Windows 下，这个默认路径是 <code>C:\tmp\vagrant-shell</code>。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#keep_color" target="_blank" rel="noopener">keep_color</a> (boolean) -  Vagrant 根据终端输出是否是 stdout 或 stderr 自动地以绿色或者红色输出。如果设置为 true，Vagrant 不会输出颜色，而使用脚本的原生色彩输出。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#name" target="_blank" rel="noopener">name</a> (string) - 该值将显示在终端输出中，以便在许多 shell 配置器存在时让用户识别更容易。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#powershell_args" target="_blank" rel="noopener">powershell_args</a> (string) - 传递给 <code>PowerShell</code> 的额外参数，如果你在 Windows 使用 PowerShell。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#powershell_elevated_interactive" target="_blank" rel="noopener">powershell_elevated_interactive</a> (boolean) - 在 Windows 交互式运行脚本。默认是 “false”。也必须享有特权。一定要启用 Windows 的自动登录，因为用户必须登录才能使用交互模式。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#md5" target="_blank" rel="noopener">md5</a> (string) - 用于验证远程下载的 shell 文件的 MD5 值。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#sha1" target="_blank" rel="noopener">sha1</a> (string) - 用于验证远程下载的 shell 文件的 SHA1 值。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/shell.html#sensitive" target="_blank" rel="noopener">sensitive</a> (boolean) - 将 <code>env</code> 选项中的 Hash 值标记为敏感数据，并将其从输出中隐藏起来。默认值是 “false”。</li>
</ul>
<h3 id="内联脚本"><a href="#内联脚本" class="headerlink" title="内联脚本"></a>内联脚本</h3><p>也许最简单的入门方式是使用内联脚本。内联脚本是直接在 Vagrantfile 文件中给定的脚本代码。例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span>,</span><br><span class="line">    <span class="symbol">inline:</span> <span class="string">"echo Hello, World"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>当配置器运行时，会在虚拟机中运行 <code>echo Hello, World</code>。</p>
<p>结合少量 Ruby 代码，很容易将 shell 脚本直接嵌入到 Vagrantfile 文件。举例如下：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$script = <span class="string">&lt;&lt;-SCRIPT</span></span><br><span class="line"><span class="string">echo I am provisioning...</span></span><br><span class="line"><span class="string">date &gt; /etc/vagrant_provisioned_at</span></span><br><span class="line"><span class="string">SCRIPT</span></span><br><span class="line"></span><br><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span>, <span class="symbol">inline:</span> $script</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>我知道如果你对 Ruby 不熟悉，那么上面的配置可能会看起来非常高级，但是不用害怕，它做的很简单：将 shell 脚本被赋 <code>$shell</code> 变量。这个全局变量包含一个字符串，然后作为内联脚本传递给 Vagrant 配置文件。</p>
<p>当然，如果在 Vagrantfile 中还有除了基本变量赋值之外的其他 Ruby 代码使你感到不舒服，那么您可以使用一个实际的脚本文件，在下一节中将对此进行说明。</p>
<p>对于 Windows 虚拟机，内联脚本必须是是 PowerShell。Batch（<strong>译者注：批处理</strong>） 脚本不能作为内联脚本。</p>
<h3 id="外部脚本"><a href="#外部脚本" class="headerlink" title="外部脚本"></a>外部脚本</h3><p>shell 配置器还可以指定本地主机上的脚本的路径。Vagrant 会将该脚本上传到虚拟机并执行。例如：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span>, <span class="symbol">path:</span> <span class="string">"script.sh"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>上面的路径是相对于中 Vagrantfile 的路径。也可以使用绝对路径，以及 <code>~</code> （家目录）和 <code>..</code>  等快捷方式。</p>
<p>如果你使用远程脚本作为配置器，你也可以将远程脚本的 URL 作为 <code>path</code> 的参数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span>, <span class="symbol">path:</span> <span class="string">"https://example.com/provisioner.sh"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>如果你在 Windows 上运行 Batch（<strong>译者注：批处理</strong>） 或者 PowerShell 脚本，请确保外部路径具有适当的扩展名（”.bat” 或者 “.ps1”），由于 Windows 使用扩展名来决定所执行文件的类型。如果没有扩展名，那么脚本可能无法使用。</p>
<p>如果运行一个已经在虚拟机存在的脚本文件，你可以使用内联脚本来调用该远程虚拟机脚本：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span>,</span><br><span class="line">    <span class="symbol">inline:</span> <span class="string">"/bin/sh /path/to/the/script/already/on/the/guest.sh"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<h3 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h3><p>您可以像任何普通的shell脚本一样参数化脚本。这些参数可以指定给 shell 配置器。应该将它们指定为字符串，因为它们将作为命令行的输入，因此确保正确地转义任何字符：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span> <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">    s.inline = <span class="string">"echo $1"</span></span><br><span class="line">    s.args   = <span class="string">"'hello, world!'"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>如果您不想担心引用，则还可以将参数指定为数组：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.vm.provision <span class="string">"shell"</span> <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">    s.inline = <span class="string">"echo $1"</span></span><br><span class="line">    s.args   = [<span class="string">"hello, world!"</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Vagrant </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vagrant </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vagrant 文件配置器的使用]]></title>
      <url>/2018/05/06/Vagrant-%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<blockquote>
<p><strong>摘要：</strong> 本文翻译自 <a href="https://www.vagrantup.com/docs/" target="_blank" rel="noopener">Vagrant</a> 官方文档 <a href="https://www.vagrantup.com/docs/provisioning/file.html#destination" target="_blank" rel="noopener">File Provisioner</a> 部分，主要介绍了文件配置器的使用，如何使用文件配置器将本地文件上拷贝到 Vagrant 所管理的虚拟机上面。</p>
</blockquote>
<p><strong>Provisioner name:</strong> “file”</p>
<p>Vagrant 文件配置器可以将本地主机的文件或者目录上传到虚拟机。</p>
<p>文件配置器可以轻松地将本地 <code>~/.gitconfig</code> 复制到虚拟机的 <code>vagrant</code> 用户家目录，这样的话就不需要在每次配置一个新的虚拟机时运行 <code>git config --global</code> 。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  <span class="comment"># ... other configuration</span></span><br><span class="line"></span><br><span class="line">  config.vm.provision <span class="string">"file"</span>, <span class="symbol">source:</span> <span class="string">"~/.gitconfig"</span>, <span class="symbol">destination:</span> <span class="string">".gitconfig"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>如果你想给虚拟机上传一个目录，可以使用下面的文件配置器来完成。复制时，本地文件夹会被复制到虚拟机的 <code>newfolder</code> 文件夹。注意，如果想在虚拟机保持和本机同样的文件夹名称，请确保目的路径名称和本地路径名称一致。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  <span class="comment"># ... other configuration</span></span><br><span class="line"></span><br><span class="line">  config.vm.provision <span class="string">"file"</span>, <span class="symbol">source:</span> <span class="string">"~/path/to/host/folder"</span>, <span class="symbol">destination:</span> <span class="string">"$HOME/remote/newfolder"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>首先将 <code>~/path/to/host/folder</code> 拷贝到虚拟机:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">folder</span><br><span class="line">    ├── script.sh</span><br><span class="line">    ├── otherfolder</span><br><span class="line">    │   └── hello.sh</span><br><span class="line">    ├── goodbye.sh</span><br><span class="line">    ├── hello.sh</span><br><span class="line">    └── woot.sh</span><br><span class="line"></span><br><span class="line">    1 directory, 5 files</span><br></pre></td></tr></table></figure></p>
<p>然后将 <code>~/path/to/host/folder</code> 拷贝到虚拟机的 <code>$HOME/remote/newfolder</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">newfolder</span><br><span class="line">    ├── script.sh</span><br><span class="line">    ├── otherfolder</span><br><span class="line">    │   └── hello.sh</span><br><span class="line">    ├── goodbye.sh</span><br><span class="line">    ├── hello.sh</span><br><span class="line">    └── woot.sh</span><br><span class="line"></span><br><span class="line">    1 directory, 5 files</span><br></pre></td></tr></table></figure></p>
<p>注意，文件上传不像文件目录同步，上传的文件或者文件夹不是保持同步的。还是以上面的例子来说，如果你更改了本地的 <code>~/.gitconfig</code>，那么虚拟机上的同样的文件并不会更改。</p>
<p>文件配置器的文件上传是通过 <code>SSH 或 PowerShell</code> 用户来上传。通常情况下用户的权限是有限的，如果你想将文件上传到需要更高权限的位置，我们推荐将它们上传到临时位置，然后使用 <a href="https://www.vagrantup.com/docs/provisioning/shell.html" target="_blank" rel="noopener">shell 配置器</a>将它们移动到目标的位置。</p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>文件配置器只有两个选项，并且是必须的：</p>
<ul>
<li><a href="https://www.vagrantup.com/docs/provisioning/file.html#source" target="_blank" rel="noopener">source</a>(string) - 要上传的本地文件或者文件夹。</li>
<li><a href="https://www.vagrantup.com/docs/provisioning/file.html#destination" target="_blank" rel="noopener">destination</a>(string) - 远程虚拟机路径。文件或者文件夹通过 <code>SCP</code> 来上传，因此该目的路径需要对 <code>SSH</code> 用户可写。<code>SSH</code> 用户可以通过 <code>ssh-config</code> 来查看，默认是 <code>vagrant</code>。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>尽管文件配置器支持尾部斜杠或 “globing”，但这会导致在本地和虚拟机之间复制文件时产生一些令人困惑的结果。例如，如下源路径没有尾部斜杠，而目的路径有尾部斜杠：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision <span class="string">"file"</span>, <span class="symbol">source:</span> <span class="string">"~/pathfolder"</span>, <span class="symbol">destination:</span> <span class="string">"/remote/newlocation/"</span></span><br></pre></td></tr></table></figure></p>
<p>这意味着 <code>vagrant</code> 会将 <code>~/pathfolder</code> 上传到远程目录 <code>/remote/newlocation</code> 底下，结果看起来会像下面这样：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">newlocation</span><br><span class="line">    ├── pathfolder</span><br><span class="line">    │   └── file.sh</span><br><span class="line"></span><br><span class="line">    1 directory, 2 files</span><br></pre></td></tr></table></figure></p>
<p>同样的行为也可以通过如下配置来实现：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision <span class="string">"file"</span>, <span class="symbol">source:</span> <span class="string">"~/pathfolder"</span>, <span class="symbol">destination:</span> <span class="string">"/remote/newlocation/pathfolder"</span></span><br></pre></td></tr></table></figure></p>
<p>另一个例子是使用 <code>.</code> 号，拷贝本地机器目录里面的文件，不包括上一层目录：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision <span class="string">"file"</span>, <span class="symbol">source:</span> <span class="string">"~/otherfolder/."</span>, <span class="symbol">destination:</span> <span class="string">"/remote/otherlocation"</span></span><br></pre></td></tr></table></figure></p>
<p>以上配置将 <code>~/otherfolder</code> 目录下的所有文件拷贝到新的路径 <code>/remote/otherlocation</code>。这个也可以通过指定一个和源文件夹不同的远程文件夹来实现：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provision <span class="string">"file"</span>, <span class="symbol">source:</span> <span class="string">"/otherfolder"</span>, <span class="symbol">destination:</span> <span class="string">"/remote/otherlocation"</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Vagrant </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vagrant </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[用 Plumbum 开发 Python 命令行工具]]></title>
      <url>/2018/04/30/%E7%94%A8-Plumbum-%E5%BC%80%E5%8F%91-Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<blockquote>
<p> <strong>摘要</strong>：本文翻译自 Python <a href="https://plumbum.readthedocs.io/en/latest/" target="_blank" rel="noopener">Plumbum</a> 开源库的官方文档 <a href="https://plumbum.readthedocs.io/en/latest/cli.html" target="_blank" rel="noopener">Plumbum CLI</a> 部分，主要介绍如何使用 <a href="https://plumbum.readthedocs.io/en/latest/cli.html" target="_blank" rel="noopener">Plumbum CLI</a> 工具包来开发 Python 命令行应用程序，这是一个非常 Pythonic、容易使用、功能强大的工具包，非常值得广大 Python 程序员掌握并使用。</p>
</blockquote>
<p><strong>译文：</strong></p>
<p>轻松执行程序的另一方面是轻松编写 CLI 程序。Python 脚本一般使用 <code>optparse</code> 或者最新的 <code>argparse</code> 及其衍生品来开发命令行工具，但是所有这些表现力有限，而且非常不直观（甚至不够 Pythonic）。Plumbum 的 CLI 工具包提供了一个程序化的方法来构建命令行应用程序，不需要创建一个解析器对象，然后填充一系列“选项”，该 CLI 工具包使用内省机制将这些原语转义成 Pythonic 结构。</p>
<p>总体来看，Plumbum CLI 应用程序是一个继承自 <code>plumbum.cli.Application</code> 的类。这些类定义了一个 <code>main()</code> 方法，并且可选地公开出方法和属性来作为命令行的选项。这些选项可能需要参数，而任何剩余的位置参数会根据 <code>main</code> 函数的声明来将其赋予 <code>main</code> 方法。一个简单的 CLI 应用程序看起来像如下这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> plumbum <span class="keyword">import</span> cli</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    verbose = cli.Flag([<span class="string">"v"</span>, <span class="string">"verbose"</span>], help = <span class="string">"If given, I will be very talkative"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        print(<span class="string">"I will now read &#123;0&#125;"</span>.format(filename))</span><br><span class="line">        <span class="keyword">if</span> self.verbose:</span><br><span class="line">            print(<span class="string">"Yadda "</span> * <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    MyApp.run()</span><br></pre></td></tr></table></figure></p>
<p>你可以运行该程序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ python example.py foo</span><br><span class="line">I will now <span class="built_in">read</span> foo</span><br><span class="line"></span><br><span class="line">$ python example.py --<span class="built_in">help</span></span><br><span class="line">example.py v1.0</span><br><span class="line"></span><br><span class="line">Usage: example.py [SWITCHES] filename</span><br><span class="line">Meta-switches:</span><br><span class="line">    -h, --<span class="built_in">help</span>                 Prints this <span class="built_in">help</span> message and quits</span><br><span class="line">    --version                  Prints the program<span class="string">'s version and quits</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Switches:</span></span><br><span class="line"><span class="string">    -v, --verbose              If given, I will be very talkative</span></span><br></pre></td></tr></table></figure></p>
<p>到现在为止，你只看到了非常基本的使用。我们现在开始探索该库。</p>
<p><em>新版本 1.6.1：</em> 你可以直接运行应用程序 <code>MyApp()</code>，不需要参数，也不需要调用 <code>.main()</code>。</p>
<h3 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h3><p><strong>Application</strong>  类是你的应用程序的“容器”，该“容器”由一个你需要实现的<code>main()</code>方法和任何数量公开选项函数和属性。你的应用程序的入口是类方法 <code>run</code>，该方法实例化你的类、解析参数、调用所有的选项函数，然后使用给的位置参数来调用<code>main()</code>函数。为了从命令行运行你的应用程序，你所要做的是：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    MyApp.run()</span><br></pre></td></tr></table></figure></p>
<p>除了 <code>run()</code> 和 <code>main()</code>，<code>Application</code> 类还公开了两个内置的选项函数：<code>help()</code> 和 <code>version()</code>，分别用于显示帮助和程序的版本。默认情况下，<code>--hep</code> 和 <code>-h</code> 会调用 <code>help()</code>，<code>--version</code> 和 <code>-v</code> 会调用 <code>version()</code>，这些函数被调用后会显示相应的信息然后退出（没有处理任何其他选项）。</p>
<p>你可以通过定义类属性来自定义 <code>help()</code> 和 <code>version()</code> 显示的信息，比如 <code>PROGNAME</code>, <code>VERSION</code> 和 <code>DESCRIPTION</code>。举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    PROGNAME = <span class="string">"Foobar"</span></span><br><span class="line">    VERSION = <span class="string">"7.3"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p><em>新版本 1.6</em></p>
<p>该库也支持终端字符颜色控制。你可以直接将 <code>PROGNAME</code>, <code>VERSION</code> 和 <code>DESCRIPTION</code> 变为带颜色的字符串。如果你给 <code>PROGNAME</code> 设置了颜色，你会得到自定义的程序名字和颜色。使用方法字符串的颜色可以通过设置 <code>COLOR_USAGE</code> 来生效，不同选项组的颜色可以通过设置 <code>COLOR_GROUPS</code> 字典来生效。</p>
<p>举例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    PROGNAME = colors.green</span><br><span class="line">    VERSION = colors.blue | <span class="string">"1.0.2"</span></span><br><span class="line">    COLOR_GROUPS = &#123;<span class="string">"Meta-switches"</span> : colors.bold &amp; colors.yellow&#125;</span><br><span class="line">    opts =  cli.Flag(<span class="string">"--ops"</span>, help=colors.magenta | <span class="string">"This is help"</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SimpleColorCLI.py 1.0.2</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">    SimpleColorCLI.py [SWITCHES]</span><br><span class="line"></span><br><span class="line">Meta-switches</span><br><span class="line">    -h, --<span class="built_in">help</span>         Prints this <span class="built_in">help</span> message and quits</span><br><span class="line">    --<span class="built_in">help</span>-all         Print <span class="built_in">help</span> messages of all subcommands and quit</span><br><span class="line">    -v, --version      Prints the program<span class="string">'s version and quits</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Switches</span></span><br><span class="line"><span class="string">    --ops              This is help</span></span><br></pre></td></tr></table></figure>
<h3 id="选项函数"><a href="#选项函数" class="headerlink" title="选项函数"></a>选项函数</h3><p><code>switch</code> 装饰器是该 CLI 开发工具包的“灵魂”，它会公开你的 CLI 应用程序的方法来作为 CLI 命令行选项，这些方法运行通过命令行来调用。我们测试下如下应用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    _allow_root = <span class="keyword">False</span>       <span class="comment"># provide a default</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch("--log-to-file", str)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_to_file</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        <span class="string">"""Sets the file into which logs will be emitted"""</span></span><br><span class="line">        logger.addHandler(FileHandle(filename))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch(["-r", "--root"])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allow_as_root</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""If given, allow running as root"""</span></span><br><span class="line">        self._allow_root = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> os.geteuid() == <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> self._allow_root:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"cannot run as root"</span>)</span><br></pre></td></tr></table></figure></p>
<p>当程序运行时，选项函数通过相应的参数被调用。比如，<code>$ ./myapp.py --log-to-file=/tmp/log</code> 将被转化成调用 <code>app.log_to_file(&quot;/tmp/log&quot;)</code>。在选项函数被执行后，程序的控制权会被传递到 <code>main</code> 方法。</p>
<blockquote>
<p><strong>注意</strong><br>方法的文档字符串和参数名字会被用来渲染帮助信息，尽量保持你的代码 <a href="https://www.wikiwand.com/en/Don&#39;t_repeat_yourself" target="_blank" rel="noopener"><strong>DRY</strong></a>。</p>
<p><strong>autoswitch</strong> 可以从函数名字中推断出选项的名称，举例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@cli.autoswitch(str)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_to_file</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这会将选项函数和 <code>--log-to-file</code> 绑定。</p>
</blockquote>
<h3 id="选项参数"><a href="#选项参数" class="headerlink" title="选项参数"></a>选项参数</h3><p>如上面例子所示，选项函数可能没有参数（不包括 <code>self</code>）或者有一个参数。如果选项函数接受一个参数，必须指明该参数的<em>类型</em>。如果你不需要特殊的验证，只需传递 <code>str</code>，否则，您可能会传递任何类型（或实际上可调用的任何类型），该类型将接收一个字符串并将其转换为有意义的对象。如果转换是不可行的，那么会抛出 <code>TypeError</code> 或者 <code>ValueError</code> 异常。</p>
<p>举例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    _port = <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch(["-p"], int)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_port</span><span class="params">(self, port)</span>:</span></span><br><span class="line">        self._port = port</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self._port)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./example.py -p 17</span><br><span class="line">17</span><br><span class="line">$ ./example.py -p foo</span><br><span class="line">Argument of -p expected to be &lt;<span class="built_in">type</span> <span class="string">'int'</span>&gt;, not <span class="string">'foo'</span>:</span><br><span class="line">    ValueError(<span class="string">"invalid literal for int() with base 10: 'foo'"</span>,)</span><br></pre></td></tr></table></figure>
<p>工具包包含两个额外的”类型”（或者是是验证器）：<code>Range</code> 和 <code>Set</code>。<code>Range</code> 指定一个最小值和最大值，限定一个整数在该范围内（闭区间）。<code>Set</code> 指定一组允许的值，并且期望参数匹配这些值中的一个。示例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    _port = <span class="number">8080</span></span><br><span class="line">    _mode = <span class="string">"TCP"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch("-p", cli.Range(1024,65535))</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_port</span><span class="params">(self, port)</span>:</span></span><br><span class="line">        self._port = port</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch("-m", cli.Set("TCP", "UDP", case_sensitive = False))</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">server_mode</span><span class="params">(self, mode)</span>:</span></span><br><span class="line">        self._mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self._port, self._mode)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./example.py -p 17</span><br><span class="line">Argument of -p expected to be [1024..65535], not <span class="string">'17'</span>:</span><br><span class="line">    ValueError(<span class="string">'Not in range [1024..65535]'</span>,)</span><br><span class="line">$ ./example.py -m foo</span><br><span class="line">Argument of -m expected to be Set(<span class="string">'udp'</span>, <span class="string">'tcp'</span>), not <span class="string">'foo'</span>:</span><br><span class="line">    ValueError(<span class="string">"Expected one of ['UDP', 'TCP']"</span>,)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>工具包中还有其他有用的验证器：<em>ExistingFile</em>（确保给定的参数是一个存在的文件），<em>ExistingDirectory</em>（确保给定的参数是一个存在的目录），<em>NonexistentPath</em>（确保给定的参数是一个不存在的路径）。所有这些将参数转换为<a href="https://plumbum.readthedocs.io/en/latest/paths.html#guide-paths" target="_blank" rel="noopener">本地路径</a>。</p>
</blockquote>
<h3 id="可重复的选项"><a href="#可重复的选项" class="headerlink" title="可重复的选项"></a>可重复的选项</h3><p>很多时候，你需要在同一个命令行中多次指定某个选项。比如，在 <code>gcc</code> 中，你可能使用 <code>-I</code> 参数来引入多个目录。默认情况下，选项只能指定一次，除非你给 <code>switch</code> 装饰器传递 <code>list = True</code> 参数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    _dirs = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch("-I", str, list = True)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">include_dirs</span><span class="params">(self, dirs)</span>:</span></span><br><span class="line">        self._dirs = dirs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self._dirs)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./example.py -I/foo/bar -I/usr/include</span><br><span class="line">[<span class="string">'/foo/bar'</span>, <span class="string">'/usr/include'</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>选项函数只被调用一次，它的参数将会变成一个列表。</p>
</blockquote>
<h3 id="强制的选项"><a href="#强制的选项" class="headerlink" title="强制的选项"></a>强制的选项</h3><p>如果某个选项是必须的，你可以给 <code>switch</code> 装饰器传递 <code>mandatory = True</code> 来实现。这样的话，如果用户不指定该选项，那么程序是无法运行的。</p>
<h3 id="选项依赖"><a href="#选项依赖" class="headerlink" title="选项依赖"></a>选项依赖</h3><p>很多时候，一个选项的出现依赖另一个选项，比如，如果不给定 <code>-y</code> 选项，那么 <code>-x</code> 选项是无法给定的。这种限制可以通过给 <code>switch</code> 装饰器传递 <code>requires</code> 参数来实现，该参数是一个当前选项所依赖的选项名称列表。如果不指定某个选项所依赖的其他选项，那么用户是无法运行程序的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line"><span class="meta">    @cli.switch("--log-to-file", str)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_to_file</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        logger.addHandler(logging.FileHandler(filename))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch("--verbose", requires = ["--log-to-file"])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verbose</span><span class="params">(self)</span>:</span></span><br><span class="line">        logger.setLevel(logging.DEBUG)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./example --verbose</span><br><span class="line">Given --verbose, the following are missing [<span class="string">'log-to-file'</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>警告</strong><br>选项函数的调用顺序和命令行指定的选项的顺序是一致的。目前不支持在程序运行时计算选项函数调用的拓扑顺序，但是将来会改进。</p>
</blockquote>
<h3 id="选项互斥"><a href="#选项互斥" class="headerlink" title="选项互斥"></a>选项互斥</h3><p>有些选项依赖其他选项，但是有些选项是和其他选项互斥的。比如，<code>--verbose</code> 和 <code>--terse</code> 同时存在是不合理的。为此，你可以给 <code>switch</code> 装饰器指定 <code>excludes</code> 列表来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line"><span class="meta">    @cli.switch("--log-to-file", str)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log_to_file</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        logger.addHandler(logging.FileHandler(filename))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch("--verbose", requires = ["--log-to-file"], excludes = ["--terse"])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verbose</span><span class="params">(self)</span>:</span></span><br><span class="line">        logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch("--terse", requires = ["--log-to-file"], excludes = ["--verbose"])</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">terse</span><span class="params">(self)</span>:</span></span><br><span class="line">        logger.setLevel(logging.WARNING)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./example --<span class="built_in">log</span>-to-file=log.txt --verbose --terse</span><br><span class="line">Given --verbose, the following are invalid [<span class="string">'--terse'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="选项分组"><a href="#选项分组" class="headerlink" title="选项分组"></a>选项分组</h3><p>如果你希望在帮助信息中将某些选项组合在一起，你可以给 <code>switch</code> 装饰器指定 <code>group = &quot;Group Name&quot;</code>, <code>Group Name</code> 可以是任意字符串。当显示帮助信息的时候，所有属于同一个组的选项会被聚合在一起。注意，分组不影响选项的处理，但是可以增强帮助信息的可读性。</p>
<h3 id="选项属性"><a href="#选项属性" class="headerlink" title="选项属性"></a>选项属性</h3><p>很多时候只需要将选项的参数存储到类的属性中，或者当某个属性给定后设置一个标志。为此，工具包提供了 <code>SwitchAttr</code>，这是一个<a href="https://docs.python.org/3/howto/descriptor.html" target="_blank" rel="noopener">数据描述符</a>，用来存储参数。 该工具包还提供了两个额外的 <code>SwitchAttr</code>:<code>Flag</code>（如果选项给定后，会给其赋予默认值）和 <code>CountOf</code> （某个选项出现的次数）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    log_file = cli.SwitchAttr(<span class="string">"--log-file"</span>, str, default = <span class="keyword">None</span>)</span><br><span class="line">    enable_logging = cli.Flag(<span class="string">"--no-log"</span>, default = <span class="keyword">True</span>)</span><br><span class="line">    verbosity_level = cli.CountOf(<span class="string">"-v"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.log_file, self.enable_logging, self.verbosity_level)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./example.py -v --<span class="built_in">log</span>-file=log.txt -v --no-log -vvv</span><br><span class="line">log.txt False 5</span><br></pre></td></tr></table></figure>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p><em>新版本 1.6</em></p>
<p>你可以使用 <code>envname</code> 参数将环境变量作为 <code>SwitchAttr</code> 的输入。举例如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    log_file = cli.SwitchAttr(<span class="string">"--log-file"</span>, str, envname=<span class="string">"MY_LOG_FILE"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.log_file)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ MY_LOG_FILE=this.log ./example.py</span><br><span class="line">this.log</span><br></pre></td></tr></table></figure>
<p>在命令行给定变量值会覆盖相同环境变量的值。</p>
<h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><p>一旦当所有命令行参数被处理后 ，<code>main()</code> 方法会获取程序的控制，并且可以有任意数量的位置参数，比如，在 <code>cp -r /foo /bar</code> 中,  <code>/foo</code> 和 <code>/bar</code> 是位置参数。程序接受位置参数的数量依赖于 <code>main()</code> 函数的声明：如果 <code>main</code> 方法有 5 个参数，2 个是有默认值的，那么用户最少需要提供 3 个位置参数并且总数量不能多于 5 个。如果 <code>main</code> 方法的声明中使用的是可变参数（<code>*args</code>），那么位置参数的个数是没有限制的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self, src, dst, mode = <span class="string">"normal"</span>)</span>:</span></span><br><span class="line">        print(src, dst, mode)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./example.py /foo /bar</span><br><span class="line">/foo /bar normal</span><br><span class="line">$ ./example.py /foo /bar spam</span><br><span class="line">/foo /bar spam</span><br><span class="line">$ ./example.py /foo</span><br><span class="line">Expected at least 2 positional arguments, got [<span class="string">'/foo'</span>]</span><br><span class="line">$ ./example.py /foo /bar spam bacon</span><br><span class="line">Expected at most 3 positional arguments, got [<span class="string">'/foo'</span>, <span class="string">'/bar'</span>, <span class="string">'spam'</span>, <span class="string">'bacon'</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong><br>该方法的声明也用于生成帮助信息，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage:  [SWITCHES] src dst [mode=<span class="string">'normal'</span>]</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>使用可变参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self, src, dst, *eggs)</span>:</span></span><br><span class="line">        print(src, dst, eggs)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./example.py a b c d</span><br><span class="line">a b (<span class="string">'c'</span>, <span class="string">'d'</span>)</span><br><span class="line">$ ./example.py --<span class="built_in">help</span></span><br><span class="line">Usage:  [SWITCHES] src dst eggs...</span><br><span class="line">Meta-switches:</span><br><span class="line">    -h, --<span class="built_in">help</span>                 Prints this <span class="built_in">help</span> message and quits</span><br><span class="line">    -v, --version              Prints the program<span class="string">'s version and quits</span></span><br></pre></td></tr></table></figure>
<h3 id="位置验证"><a href="#位置验证" class="headerlink" title="位置验证"></a>位置验证</h3><p><em>新版本 1.6</em></p>
<p>你可以使用 <code>cli.positional</code> 装饰器提供的验证器来验证位置参数。只需在装饰器中传递与 <code>main</code> 函数中的相匹配的验证器即可。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line"><span class="meta">    @cli.positional(cli.ExistingFile, cli.NonexistentPath)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self, infile, *outfiles)</span>:</span></span><br><span class="line">        <span class="string">"infile is a path, outfiles are a list of paths, proper errors are given"</span></span><br></pre></td></tr></table></figure></p>
<p>如果你的程序只在 Python 3 中运行，你可以使用注解来指定验证器，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self, infile : cli.ExistingFile, *outfiles : cli.NonexistentPath)</span>:</span></span><br><span class="line">    <span class="string">"Identical to above MyApp"</span></span><br></pre></td></tr></table></figure></p>
<p>如果 <code>positional</code> 装饰器存在，那么注解会被忽略。</p>
<h3 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h3><p><em>新版本 1.1</em></p>
<p>随着 CLI 应用程序的扩展，功能变的越来越多，一个通常的做法是将其逻辑分成多个子应用（或者子命令）。一个典型的例子是版本控制系统，比如 <a href="https://git-scm.com/" target="_blank" rel="noopener"><strong>git</strong></a>，<code>git</code> 是根命令，在这之下的子命令比如 <code>commit</code> 或者 <code>push</code> 是嵌套的。<code>git</code> 甚至支持命令别名，这运行用户自己创建一些子命令。Plumbum 写类似这样的程序是很轻松的。</p>
<p>在我们开始了解代码之前，先强调两件事情：</p>
<ul>
<li>在 Plumbum中，每个子命令都是一个完整的 <code>cli.Application</code> 应用，你可以单独执行它，或者从所谓的根命令中分离出来。当应用程序单独执行是，它的父属性是 <code>None</code>，当以子命令运行时，它的父属性指向父应用程序。同样，当父应用使用子命令执行时，它的内嵌命令被设置成内嵌应用。</li>
<li>每个子命令只负责它自己的选项参数（直到下一个子命令）。这允许应用在内嵌应用调用之前来处理它自己的选项和位置参数。例如 <code>git --foo=bar spam push origin --tags</code>：根应用 <code>git</code> 负责选项 <code>--foo</code> 和位置选项 <code>spam</code> ，内嵌应用 <code>push</code> 负责在它之后的参数。从理论上讲，你可以将多个子应用程序嵌套到另一个应用程序中，但在实践中，通常嵌套层级只有一层。</li>
</ul>
<p>这是一个模仿版本控制系统的例子 <code>geet</code>。我们有一个根应用 <code>Geet</code> ，它有两个子命令 <code>GeetCommit</code> 和 <code>GeetPush</code>：这两个子命令通过 <code>subcommand</code> 装饰器来将其附加到根应用。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Geet</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    <span class="string">"""The l33t version control"""</span></span><br><span class="line">    VERSION = <span class="string">"1.7.2"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            print(<span class="string">"Unknown command &#123;0!r&#125;"</span>.format(args[<span class="number">0</span>]))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>   <span class="comment"># error exit code</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.nested_command:           <span class="comment"># will be ``None`` if no sub-command follows</span></span><br><span class="line">            print(<span class="string">"No command given"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>   <span class="comment"># error exit code</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Geet.subcommand("commit")                    # attach 'geet commit'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeetCommit</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    <span class="string">"""creates a new commit in the current branch"""</span></span><br><span class="line"></span><br><span class="line">    auto_add = cli.Flag(<span class="string">"-a"</span>, help = <span class="string">"automatically add changed files"</span>)</span><br><span class="line">    message = cli.SwitchAttr(<span class="string">"-m"</span>, str, mandatory = <span class="keyword">True</span>, help = <span class="string">"sets the commit message"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"doing the commit..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Geet.subcommand("push")                      # attach 'geet push'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeetPush</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    <span class="string">"""pushes the current local branch to the remote one"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self, remote, branch = None)</span>:</span></span><br><span class="line">        print(<span class="string">"doing the push..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    Geet.run()</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>由于 <code>GeetCommit</code> 也是一个 <code>cli.Application</code>，因此你可以直接调用 <code>GeetCommit.run()</code> （这在应用的上下文是合理的）</li>
<li>你也可以不用装饰器而使用 <code>subcommand</code> 方法来附加子命令：<code>Geet.subcommand(&quot;push&quot;, GeetPush)</code></li>
</ul>
</blockquote>
<p>以下是运行该应用程序的示例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ python geet.py --<span class="built_in">help</span></span><br><span class="line">geet v1.7.2</span><br><span class="line">The l33t version control</span><br><span class="line"></span><br><span class="line">Usage: geet.py [SWITCHES] [SUBCOMMAND [SWITCHES]] args...</span><br><span class="line">Meta-switches:</span><br><span class="line">    -h, --<span class="built_in">help</span>                 Prints this <span class="built_in">help</span> message and quits</span><br><span class="line">    -v, --version              Prints the program<span class="string">'s version and quits</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Subcommands:</span></span><br><span class="line"><span class="string">    commit                     creates a new commit in the current branch; see</span></span><br><span class="line"><span class="string">                               '</span>geet commit --<span class="built_in">help</span><span class="string">' for more info</span></span><br><span class="line"><span class="string">    push                       pushes the current local branch to the remote</span></span><br><span class="line"><span class="string">                               one; see '</span>geet push --<span class="built_in">help</span><span class="string">' for more info</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$ python geet.py commit --help</span></span><br><span class="line"><span class="string">geet commit v1.7.2</span></span><br><span class="line"><span class="string">creates a new commit in the current branch</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage: geet commit [SWITCHES]</span></span><br><span class="line"><span class="string">Meta-switches:</span></span><br><span class="line"><span class="string">    -h, --help                 Prints this help message and quits</span></span><br><span class="line"><span class="string">    -v, --version              Prints the program'</span>s version and quits</span><br><span class="line"></span><br><span class="line">Switches:</span><br><span class="line">    -a                         automatically add changed files</span><br><span class="line">    -m VALUE:str               sets the commit message; required</span><br><span class="line"></span><br><span class="line">$ python geet.py commit -m <span class="string">"foo"</span></span><br><span class="line">doing the commit...</span><br></pre></td></tr></table></figure></p>
<h3 id="配置解析器"><a href="#配置解析器" class="headerlink" title="配置解析器"></a>配置解析器</h3><p>应用程序的另一个常见的功能是配置文件解析器，解析后台 INI 配置文件：<code>Config</code> （或者 <code>ConfigINI</code>）。使用示例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> plumbum <span class="keyword">import</span> cli</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> cli.Config(<span class="string">'~/.myapp_rc'</span>) <span class="keyword">as</span> conf:</span><br><span class="line">    one = conf.get(<span class="string">'one'</span>, <span class="string">'1'</span>)</span><br><span class="line">    two = conf.get(<span class="string">'two'</span>, <span class="string">'2'</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果配置文件不存在，那么将会以当前的 <code>key</code> 和默认的 <code>value</code> 来创建一个配置文件，在调用 <code>.get</code> 方法时会得到默认值，当上下文管理器存在时，文件会被创建。如果配置文件存在，那么该文件将会被读取并且没有任何改变。你也可以使用 <code>[]</code> 语法来强制设置一个值或者当变量不存在时获取到一个 <code>ValueError</code>。如果你想避免上下文管理器，你也可以使用 <code>.read</code> 和 <code>.write</code>。</p>
<p>ini 解析器默认使用 <code>[DEFAULT]</code> 段，就像 Python 的 ConfigParser。如果你想使用一个不同的段，只需要在 key 中通过 <code>.</code> 将段和标题分隔开。比如 <code>conf[&#39;section.item&#39;]</code> 会将 <code>item</code> 放置在 <code>[section]</code> 下。所有存储在 <code>ConfigINI</code> 中的条目会被转化成 <code>str</code>，<code>str</code> 是经常返回的。</p>
<h3 id="终端实用程序"><a href="#终端实用程序" class="headerlink" title="终端实用程序"></a>终端实用程序</h3><p>在 <code>plumbum.cli.terminal</code> 中有多个终端实用程序，用来帮助制作终端应用程序。</p>
<p><code>get_terminal_size(default=(80,25))</code> 允许跨平台访问终端屏幕大小，返回值是一个元组 <code>(width, height)</code>。还有几个方法可以用来询问用户输入，比如 <code>readline</code>, <code>ask</code>, <code>choose</code> 和 <code>prompt</code> 都是可用的。</p>
<p><code>Progress(iterator)</code> 可以使你快速地从迭代器来创建一个进度条。简单地打包一个 slow 迭代器并迭代就会生成一个不错的基于用户屏幕宽度的文本进度条，同时会显示剩余时间。如果你想给 fast 迭代器创建一个进度条，并且在循环中包含代码，那么请使用 <code>Progress.wrap</code> 或者 <code>Progress.range</code>。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> Progress.range(<span class="number">10</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>如果在终端中有其他输出，但是仍然需要一个进度条，请传递 <code>has_output=True</code> 参数来禁止进度条清除掉历史输出。</p>
<p>在 <code>plumbum.cli.image</code> 中提供了一个命令行绘图器（<code>Image</code>）。它可以绘制一个类似 PIL 的图像：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image().show_pil(im)</span><br></pre></td></tr></table></figure></p>
<p>Image 构造函数接受一个可选的 size 参数（如果是 None，那么默认是当前终端大小）和一个字符比例，该比例来自当前字符的高度和宽度的度量，默认值是 2.45。如果设置为 None，ratio 将会被忽略，图像不再被限制成比例缩放。要直接绘制一个图像，<code>show</code> 需要一个文件名和一对参数。<code>show_pil</code> 和 <code>show_pil_double</code> 方法直接接受一个 PIL-like 对象。为了从命令行绘制图像，该模块可以直接被运行：<code>python -m plumbum.cli.image myimage.png</code>。</p>
<p>要获取帮助列表和更多的信息请参见 <a href="https://plumbum.readthedocs.io/en/latest/api/cli.html#api-cli" target="_blank" rel="noopener"><strong>api docs</strong></a>。</p>
<h3 id="请参阅"><a href="#请参阅" class="headerlink" title="请参阅"></a>请参阅</h3><ul>
<li><a href="https://github.com/tomerfiliba/plumbum/blob/master/examples/filecopy.py" target="_blank" rel="noopener"><strong>filecopy.py</strong></a> 示例</li>
<li><a href="https://github.com/tomerfiliba/plumbum/blob/master/examples/geet.py" target="_blank" rel="noopener"><strong>geet.py</strong></a> - 一个可运行的使用子命令的示例</li>
<li><a href="http://rpyc.readthedocs.io/en/latest/" target="_blank" rel="noopener"><strong>RPyC</strong></a> 已经将基于 bash 的编译脚本换成了 Plumbum CLI。这是多么<a href="https://github.com/tomerfiliba/rpyc/blob/c457a28d689df7605838334a437c6b35f9a94618/build.py" target="_blank" rel="noopener"><strong>简短和具有可读性</strong></a></li>
<li>一篇<a href="http://tomerfiliba.com/blog/Plumbum/" target="_blank" rel="noopener"><strong>博客</strong></a>，讲述 CLI 模块的理论</li>
</ul>
]]></content>
      
        <categories>
            
            <category> 翻译 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Plumbum </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vagrant 入门指南]]></title>
      <url>/2018/04/22/Vagrant-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<h3 id="Vagrant-简介"><a href="#Vagrant-简介" class="headerlink" title="Vagrant 简介"></a>Vagrant 简介</h3><p>Vagrant 是一个用来构建和管理虚拟机环境的工具。Vagrant 有着易于使用的工作流，并且专注于自动化，降低了开发者搭建环境的时间，提高了生产力。解决了“在我的机器上可以工作”的问题。</p>
<p>Vagrant 是为了方便的实现虚拟化环境而设计的，使用 Ruby 开发，基于 VirtualBox 等虚拟机管理软件的接口，提供了一个可配置、轻量级的便携式虚拟开发环境。使用 Vagrant 可以很方便的就建立起来一个虚拟环境，而且可以模拟多台虚拟机，这样我们平时还可以在开发机模拟分布式系统。</p>
<p>团队新员工加入，常常会遇到花一天甚至更多时间来从头搭建完整的开发环境，而有了Vagrant，只需要直接将已经打包好的 package（里面包括开发工具，代码库，配置好的服务器等）拿过来就可以工作了，这对于提升工作效率非常有帮助。</p>
<h3 id="为什么选择-Vagrant"><a href="#为什么选择-Vagrant" class="headerlink" title="为什么选择 Vagrant"></a>为什么选择 Vagrant</h3><p>Vagrant 提供了一个易于配置，可重复使用，兼容的环境，通过一个单一的工作流程来控制，帮助你和团队最大化生产力和灵活性。<br>为了实现 Vagrant 的魔力，Vagrant 站在了巨人的肩膀上。虚拟机的配置基于 VirtualBox，VMware，AWS 或者其他提供商。然后一些配置工具，比如 shell 脚本，Chef 或者 Puppet 可以自动化地在虚拟机安装并配置软件。</p>
<h4 id="对于开发者人员"><a href="#对于开发者人员" class="headerlink" title="对于开发者人员"></a>对于开发者人员</h4><p>如果你是一个开发者，Vagrant 将在一个一次性的、一致的环境中隔离依赖项及其配置，而不会影响你习惯使用的任何工具(编辑器、浏览器、调试器等)。一旦你或者其他人创建了一个 Vagrantfile，你只需要执行 <code>vagrant up</code> 所有的东西就自动安装和配置了。你团队中的其他成员使用同一个配置文件来创建开发环境，因此不管你工作在 Linux，MacOS X 还是 Windows， 所有团队的成员都可以在统一的环境环境中运行代码，这样就可以避免“在我的机器上可以工作”的问题。</p>
<h4 id="对于运维人员"><a href="#对于运维人员" class="headerlink" title="对于运维人员"></a>对于运维人员</h4><p>如果你是一个运维工程师或者 DevOps 工程师，Vagrant 给予你一个一次性的环境来开发和测试基础架构管理脚本。你可以使用本地虚拟机（比如 VirtualBox 或者 VMware）马上测试一些东西，比如 shell 脚本，Chef cookbooks，Puppet 模块等。然后，你可以用同样的配置在远程云上，比如 AWS 或者 RackSpace，来测试这些脚本。抛弃之前自定义脚本来回收 EC2 实例吧，停止使用 SSH 在各种机器之间跳来跳去，请开始使用 Vagrant 来给你的工作带来更多便利。</p>
<h3 id="Vagrant-和-Terraform-的区别"><a href="#Vagrant-和-Terraform-的区别" class="headerlink" title="Vagrant 和 Terraform 的区别"></a>Vagrant 和 Terraform 的区别</h3><p>Vagrant 和 Terraform 都出自同一个公司 <a href="https://www.hashicorp.com/" target="_blank" rel="noopener">HashiCorp</a>，该公司主要做一些开源软件，相关的产品还有 <a href="https://www.packer.io/" target="_blank" rel="noopener">Packer</a>，<a href="https://www.consul.io/" target="_blank" rel="noopener">Consul</a>，<a href="https://www.vaultproject.io/" target="_blank" rel="noopener">Vault</a>，<a href="https://www.nomadproject.io/" target="_blank" rel="noopener">Nomad</a> 等。</p>
<p>Terraform 的主要用途是管理云提供商的远程资源，比如 AWS。Terraform 可以管理横跨多个云提供商巨量的基础设施。而 Vagrant 主要用来管理仅使用少量虚拟机的本地开发环境。</p>
<p>Vagrant 用于开发环境，Terraform 普遍用于基础设施管理。</p>
<hr>
<h3 id="VirtualBox-安装"><a href="#VirtualBox-安装" class="headerlink" title="VirtualBox 安装"></a>VirtualBox 安装</h3><p>VirtualBox 是 Oracle 开源的虚拟化系统，和 VMware 是同类产品，支持多个平台，可以到官方网站：<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Downloads</a> 下载适合你平台的 VirtualBox 最新版本并安装。</p>
<blockquote>
<p><strong>提示：</strong>对于 Mac 用户，如果系统为 OSX 10.13.3(mac OS High Sierra) 或者更高版本，安装过程可能会失败，报错提示<code>安装失败，安装器遇到了一个错误导致安装失败...</code>，原因是新版本 Mac 系统的安全机制阻止外部内核扩展安装，导致安装失败。两种解决方法：</p>
<ol>
<li>进入系统偏好设置&gt;安全性与隐私&gt;通用，然后手动允许；</li>
<li>在终端敲命令禁用此安全特性：<code>sudo spctl --master-disable</code>；</li>
</ol>
</blockquote>
<h3 id="Vagrant-安装"><a href="#Vagrant-安装" class="headerlink" title="Vagrant 安装"></a>Vagrant 安装</h3><p>到官方网站下载相应系统平台的安装包：<a href="http://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">http://www.vagrantup.com/downloads.html</a><br>直接根据向导进行操作即可完成安装，安装完后就可以在终端输入 <code>vagrant</code> 命令了。</p>
<blockquote>
<p><strong>提示：</strong>尽量下载最新的程序，因为VirtualBox经常升级，升级后有些接口会变化，老的Vagrant 可能无法使用。</p>
</blockquote>
<h3 id="Vagrant-启动第一台虚拟机"><a href="#Vagrant-启动第一台虚拟机" class="headerlink" title="Vagrant 启动第一台虚拟机"></a>Vagrant 启动第一台虚拟机</h3><p>到此准备工作（VirtualBox 和 Vagrant 安装）基本上做完了，接下来就可以通过 Vagrant 来启动一台虚拟机了。</p>
<p>在启动虚拟机之前先简单介绍下 <code>Vagrant box</code>：<code>box</code> 是一个打包好的操作系统，是一个后缀名为 <code>.box</code> 的文件，其实是一个压缩包，里面包含了 Vagrant 的配置信息和 VirtualBox 的虚拟机镜像文件。<code>vagrant up</code> 启动虚拟机是基于 <code>box</code> 文件的，因此在启动虚拟机前必须得把 <code>box</code> 文件准备好。或者也可以在启动的时候指定远程 <code>box</code> 地址，在这里我把 <code>box</code> 文件下载下来，然后启动时指定该文件。</p>
<p>我使用网上分享的 <code>ubuntu-server-16.04</code> 这个 <code>box</code>，由于<a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">vagrant 官方 box</a> 下载速度特别慢，所以在此提供一下该 <code>box</code> 的百度网盘下载地址，加速下载：<a href="https://pan.baidu.com/s/1wJCeWEyxKQLVPi1IH1IlYg" target="_blank" rel="noopener">https://pan.baidu.com/s/1wJCeWEyxKQLVPi1IH1IlYg</a></p>
<ol>
<li><p>新建一个目录作为 <code>Vagrant</code> 的工程目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$haohao</span> <span class="built_in">cd</span> /Users/haohao</span><br><span class="line"><span class="variable">$haohao</span> mkdir vagrant</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加前面下载的 <code>box</code><br>添加 <code>box</code> 命令格式：<code>vagrant box add &lt;本地 box 名称&gt; &lt;box 文件&gt;</code></p>
<ul>
<li>本地 <code>box</code> 名称：自定义名称，该名称是本地 <code>vagrant</code> 管理时使用的名称；</li>
<li><code>box</code> 文件：前面下载的 <code>vagrant box</code> 文件或者远程 <code>box</code> url 地址；<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$haohao</span> vagrant box add ubuntu-server-16.04 ubuntu-server-16.04-amd64-vagrant.box</span><br><span class="line">==&gt; box: Box file was not detected as metadata. Adding it directly...</span><br><span class="line">==&gt; box: Adding box <span class="string">'ubuntu-server-16.04'</span> (v0) <span class="keyword">for</span> provider:</span><br><span class="line">    box: Unpacking necessary files from: file:///Users/haohao/vagrant/ubuntu-server-16.04-amd64-vagrant.box</span><br><span class="line">==&gt; box: Successfully added box <span class="string">'ubuntu-server-16.04'</span> (v0) <span class="keyword">for</span> <span class="string">'virtualbox'</span>!</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>查看 <code>box</code> 是否添加成功<br>查看当前 <code>vagrant</code> 中有哪些 <code>box</code>：<code>vagrant box list</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$haohao</span> vagrant box list</span><br><span class="line">ubuntu-server-16.04 (virtualbox, 0)</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化上面添加的 <code>box</code><br>初始化命令格式：<code>vagrant init &lt;本地 box 名称&gt;</code><br>本地 <code>box</code> 名称：第 2 步中添加的 <code>box</code> 名称<br>这里初始化前面添加的 <code>box</code>，初始化后会在当前目录生产一个 <code>Vagrantfile</code> 文件，里面包含了虚拟机的各种配置，关于具体每个配置项是什么意思，后面会介绍。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$haohao</span> vagrant init <span class="string">'ubuntu-server-16.04'</span></span><br><span class="line">A `Vagrantfile` has been placed <span class="keyword">in</span> this directory. You are now</span><br><span class="line">ready to `vagrant up` your first virtual environment! Please <span class="built_in">read</span></span><br><span class="line">the comments <span class="keyword">in</span> the Vagrantfile as well as documentation on</span><br><span class="line">`vagrantup.com` <span class="keyword">for</span> more information on using Vagrant.</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动虚拟机<br>虚拟机启动命令：<code>vagrant up</code><br>启动虚拟机时会自动将当前目录（即 Vagrantfile 文件所在目录），和虚拟机的 <code>/vagrant</code> 目录共享。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$haohao</span> vagrant up</span><br><span class="line">Bringing machine <span class="string">'default'</span> up with <span class="string">'virtualbox'</span> provider...</span><br><span class="line">==&gt; default: Importing base box <span class="string">'ubuntu-server-16.04'</span>...</span><br><span class="line">==&gt; default: Matching MAC address <span class="keyword">for</span> NAT networking...</span><br><span class="line">==&gt; default: Setting the name of the VM: vagrant_default_1524288099752_62326</span><br><span class="line">==&gt; default: Clearing any previously <span class="built_in">set</span> network interfaces...</span><br><span class="line">.....</span><br><span class="line">==&gt; default: Mounting shared folders...</span><br><span class="line">    default: /vagrant =&gt; /Users/haohao/vagrant</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接虚拟机<br>命令格式：<code>vagrant ssh</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$haohao</span> vagrant ssh</span><br><span class="line">Welcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-98-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/advantage</span><br><span class="line"></span><br><span class="line">  Get cloud support with Ubuntu Advantage Cloud Guest:</span><br><span class="line">    http://www.ubuntu.com/business/services/cloud</span><br><span class="line"></span><br><span class="line">0 packages can be updated.</span><br><span class="line">0 updates are security updates.</span><br><span class="line"></span><br><span class="line">Last login: Sat Apr 21 05:28:37 2018 from 10.0.2.2</span><br><span class="line">ubuntu@ubuntu-xenial:~$</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看 Vagrant 共享目录<br>进入虚拟机后执行 <code>df -h</code> 可以看到 Vagrant 默认把宿主机 <code>Vagrantfile</code> 所在的目录和虚拟机的 <code>/vagrant</code> 目录共享，可以通过 <code>ls /vagrant/</code> 查看该目录内容，内容和宿主机对应目录一致。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu-xenial:~$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            490M     0  490M   0% /dev</span><br><span class="line">tmpfs           100M  3.1M   97M   4% /run</span><br><span class="line">/dev/sda1       9.7G  857M  8.8G   9% /</span><br><span class="line">tmpfs           497M     0  497M   0% /dev/shm</span><br><span class="line">tmpfs           5.0M     0  5.0M   0% /run/lock</span><br><span class="line">tmpfs           497M     0  497M   0% /sys/fs/cgroup</span><br><span class="line">vagrant         234G   49G  185G  21% /vagrant</span><br><span class="line">tmpfs           100M     0  100M   0% /run/user/1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># ls 查看该共享目录内容和宿主机内容一致</span></span><br><span class="line">ubuntu@ubuntu-xenial:~$ ls /vagrant/</span><br><span class="line">ubuntu-xenial-16.04-cloudimg-console.log  Vagrantfile</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Vagrant-配置文件浅析"><a href="#Vagrant-配置文件浅析" class="headerlink" title="Vagrant 配置文件浅析"></a>Vagrant 配置文件浅析</h3><p>前面我们执行 <code>vagrant init &lt;本地 box 名称&gt;</code> 会在当前目录生成 <code>Vagrantfile</code> 文件，这个文件是非常重要的，一般给别人共享自己的环境时都是提供一个 <code>Vagrantfile</code> 和一个 <code>box</code> 文件，这样就可以很轻松地将环境共享给别人，别人能得到一模一样的统一的环境，这就是使用 <code>Vagrant</code> 的好处。</p>
<p><code>Vagrantfile</code> 主要包括三个方面的配置，虚拟机的配置、SSH配置、Vagrant 的一些基础配置。Vagrant 是使用 Ruby 开发的，所以它的配置语法也是 Ruby 的，对于没有学过 Ruby 的朋友也没关系，根据例子模仿下就会了。</p>
<p>修改完配置后需要执行 <code>vagrant reload</code> 重启 VM 使其配置生效。</p>
<p>以下简单介绍下常用配置的配置项：</p>
<ol>
<li><p><code>box</code> 名称设置<br><code>config.vm.box = &quot;base&quot;</code><br> 上面这配置展示了 Vagrant 要去启用那个box作为系统，也就是前面我们输入 <code>vagrant init &lt;本地 box 名称&gt;</code>时所指定的 <code>box</code>，如果沒有输入 <code>box</code> 名称的话，那么默认就是 <code>base</code>。</p>
</li>
<li><p>VM 相关配置<br>VirtualBox 提供了 VBoxManage 这个命令行工具，可以让我们设定 VM，用<code>modifyvm</code>这个命令让我们可以设定 VM 的名称和内存大小等等，这里说的名称指的是在 VirtualBox 中显示的名称，我们也可以在 Vagrantfile 中进行设定，举例如下：</p>
<blockquote>
<p>调用 VBoxManage 的 <code>modifyvm</code> 的命令，设置 VM 的名称为 <code>ubuntu</code>，内存为 1024 MB。你可以类似的通过定制其它 VM 属性来定制你自己的 VM。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> |v|</span><br><span class="line">  v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--name"</span>, <span class="string">"ubuntu"</span>, <span class="string">"--memory"</span>, <span class="string">"1024"</span>]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>网络设置<br> Vagrant 有两种方式来进行网络连接，一种是 host-only (主机模式)，这种模式下所有的虚拟系统是可以互相通信的，但虚拟系统和真实的网络是被隔离开的，虚拟机和宿主机是可以互相通信的，相当于两台机器通过双绞线互联。另一种是Bridge(桥接模式)，该模式下的 VM  就像是局域网中的一台独立的主机，可以和局域网中的任何一台机器通信，这种情况下需要手动给 VM 配 IP 地址，子网掩码等。我们一般选择 host-only 模式，配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network :private_network, ip: <span class="string">"11.11.11.11"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>hostname 设置<br> <code>hostname</code> 的设置非常简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.hostname = <span class="string">"kubernetes"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>目录共享<br> 我们前面介绍过<code>/vagrant</code>目录默认就是当前的开发目录，这是在虚拟机开启的时候默认挂载同步的。我们还可以通过配置来设置额外的同步目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个参数是主机的目录，第二个参数是虚拟机挂载的目录</span></span><br><span class="line">config.vm.synced_folder  <span class="string">"/Users/haohao/data"</span>, <span class="string">"/vagrant_data"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>端口转发<br>对宿主机器上 8080 端口的访问请求 forward 到虚拟机的 80 端口的服务上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network :forwarded_port, guest: 80, host: 8080</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Vagrant-常用命令清单"><a href="#Vagrant-常用命令清单" class="headerlink" title="Vagrant 常用命令清单"></a>Vagrant 常用命令清单</h3><ul>
<li><code>vagrant box add</code> 添加box</li>
<li><code>vagrant init</code> 初始化 box</li>
<li><code>vagrant up</code> 启动虚拟机</li>
<li><code>vagrant ssh</code> 登录虚拟机</li>
<li><code>vagrant box list</code> 列出 Vagrant 当前 <code>box</code> 列表</li>
<li><code>vagrant box remove</code> 删除相应的 <code>box</code></li>
<li><code>vagrant destroy</code> 停止当前正在运行的虚拟机并销毁所有创建的资源</li>
<li><code>vagrant halt</code> 关机</li>
<li><code>vagrant package</code> 把当前的运行的虚拟机环境进行打包为 <code>box</code> 文件</li>
<li><code>vagrant plugin</code> 安装卸载插件</li>
<li><code>vagrant reload</code> 重新启动虚拟机，重新载入配置文件</li>
<li><code>vagrant resume</code> 恢复被挂起的状态</li>
<li><code>vagrant ssh-config</code> 输出用于 ssh 连接的一些信息</li>
<li><code>vagrant status</code>  获取当前虚拟机的状态</li>
<li><code>vagrant suspend</code> 挂起当前的虚拟机</li>
<li><code>vagrant up</code> 重启虚拟机</li>
</ul>
<h3 id="Vagrant-启动虚拟机集群"><a href="#Vagrant-启动虚拟机集群" class="headerlink" title="Vagrant 启动虚拟机集群"></a>Vagrant 启动虚拟机集群</h3><p>前面我们都是通过一个 <code>Vagrantfile</code> 配置启动单台机器，如果我们要启动一个集群，那么可以把需要的节点在一个 <code>Vagrantfile</code> 写好，然后直接就可以通过 <code>vagrant up</code> 同时启动多个 VM 组成一个集群。以下示例配置一个 web 节点和一个 db 节点，两个节点在同一个网段，并且使用同一个 <code>box</code> 启动：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">"2"</span>) <span class="keyword">do</span> |config|</span><br><span class="line">  config.vm.define :web <span class="keyword">do</span> |web|</span><br><span class="line">    web.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> |v|</span><br><span class="line">          v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--name"</span>, <span class="string">"web"</span>, <span class="string">"--memory"</span>, <span class="string">"512"</span>]</span><br><span class="line">    end</span><br><span class="line">    web.vm.box = <span class="string">"ubuntu-server-16.04"</span></span><br><span class="line">    web.vm.hostname = <span class="string">"web"</span></span><br><span class="line">    web.vm.network :private_network, ip: <span class="string">"11.11.1.1"</span></span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  config.vm.define :db <span class="keyword">do</span> |db|</span><br><span class="line">    db.vm.provider <span class="string">"virtualbox"</span> <span class="keyword">do</span> |v|</span><br><span class="line">          v.customize [<span class="string">"modifyvm"</span>, :id, <span class="string">"--name"</span>, <span class="string">"db"</span>, <span class="string">"--memory"</span>, <span class="string">"512"</span>]</span><br><span class="line">    end</span><br><span class="line">    db.vm.box = <span class="string">"ubuntu-server-16.04"</span></span><br><span class="line">    db.vm.hostname = <span class="string">"db"</span></span><br><span class="line">    db.vm.network :private_network, ip: <span class="string">"11.11.1.2"</span></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<h3 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h3><p><a href="https://www.vagrantup.com/intro/index.html" target="_blank" rel="noopener">https://www.vagrantup.com/intro/index.html</a><br><a href="https://blog.csdn.net/rickiyeat/article/details/55097687" target="_blank" rel="noopener">https://blog.csdn.net/rickiyeat/article/details/55097687</a><br><a href="https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/01.0.md" target="_blank" rel="noopener">https://github.com/astaxie/go-best-practice/blob/master/ebook/zh/01.0.md</a></p>
]]></content>
      
        <categories>
            
            <category> Vagrant </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Vagrant </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Google Kubernetes Engine(GKE) 使用初探]]></title>
      <url>/2018/04/14/Google-Kubernetes-Engine-GKE-%E4%BD%BF%E7%94%A8%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Google 的 k8s 在 2017 年已经从容器编排领域的竞争中取得主导地位，从 Docker 之前的一度排挤到最终完全拥抱 k8s，显然 k8s 已经成了目前业界的标准。但是到目前为止能提供 k8s 完全托管服务的云服务商少之又少，即便是目前在云提供商有统治力的 AWS 也没有完全提供 k8s 托管服务，仅仅提供有限的定制服务，在这一方面并不成熟。然而 Google 的 k8s 托管服务，即 GKE，却将 k8s 托管服务做到了极致（至少目前看来），不仅提供了全套的 k8s 托管服务，更引人注目的是 Google 已然将 Autoscaler 和 k8s 集成，实现了 k8s 节点的自动伸缩机制，能根据 pod 的需求自动化添加或删除节点，当现有节点无法承载新的服务时会自动添加节点来满足需求，当现有节点足够空闲时会启用调节机制自动化收缩节点，从某种意义上来说这几乎做到了无服务器的理念。然而这也许只是冰山一角，更多强大的功能还需要进一步探索，本文只是一个入门指南，主要指导能快速开始上手基于 Google Cloud Platform 的 GKE 服务（k8s 托管服务）。</p>
<h3 id="GKE-入门指南"><a href="#GKE-入门指南" class="headerlink" title="GKE 入门指南"></a>GKE 入门指南</h3><p>接下来我们一步步指引如何使用 GKE 来部署服务，前提是对 k8s 有所了解，能简单使用 kubectl 命令。</p>
<ol>
<li>安装并配置 Google Cloud SDK<br>Google Cloud SDK 是 访问 GCP(Google Cloud Platform) 平台各种资源的命令行工具集，类似 aws 的 aws 命令行工具。<br>安装和配置就不多说了，点击下面链接选择相应操作系统版本的 tar 包下载，然后解压，在 PATH 环境变量中添加 <code>google-cloud-sdk/bin</code> 即可：<br><a href="https://cloud.google.com/sdk/?hl=zh-cn" target="_blank" rel="noopener">https://cloud.google.com/sdk/?hl=zh-cn</a></li>
<li>初始化 Google Cloud SDK<br>初始化 Google Cloud SDK 是将 <code>gcloud</code>  命令和 Google 账号绑定起来并设置一些其他的默认值，比如区域，代理，账号，项目（Google 账号中新建的项目）之类的。在执行 <code>gcloud init</code> 初始化之前得先给 <code>gcloud</code> 配置 HTTP 代理（GFW 你懂得），具体配置见我之前<a href="https://blog.csdn.net/qianghaohao/article/details/79942485" target="_blank" rel="noopener">这篇文章</a>。然后执行 <code>gcloud init</code> 完成初始化，直接根据向导来即可。</li>
<li>到 Google Cloud Platform 控制台建一个 k8s 集群，记住名称<br><img src="/images/gke1.png" alt=""></li>
<li>安装 gcloud kubectl 组件<br><code>gcloud components install kubectl</code></li>
<li>获取群集的身份验证凭据<br>创建群集后，您需要获取身份验证凭据以与群集进行交互。要为集群进行身份验证，请运行以下命令：<br><code>gcloud container clusters get-credentials &lt;上一步创建的集群名称&gt;</code></li>
<li>接下来部署一个简单的 <code>hello-server</code> 服务到 GKE<br><code>kubectl run hello-server --image gcr.io/google-samples/hello-app:1.0 --port 8080</code></li>
</ol>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://cloud.google.com/kubernetes-engine/docs/quickstart" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/docs/quickstart</a><br><a href="https://cloud.google.com/sdk/docs/quickstart-macos?hl=zh-cn" target="_blank" rel="noopener">https://cloud.google.com/sdk/docs/quickstart-macos?hl=zh-cn</a></p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="gloud-常用命令"><a href="#gloud-常用命令" class="headerlink" title="gloud 常用命令"></a>gloud 常用命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcloud auth login --no-launch-browser <span class="comment"># gcloud 登录认证</span></span><br><span class="line">gcloud config <span class="built_in">set</span> compute/zone [COMPUTE_ZONE] <span class="comment"># 设置默认区域</span></span><br><span class="line">gcloud components list <span class="comment"># 列出可安装组件</span></span><br><span class="line">gcloud components install [组件名称] <span class="comment"># 安装组件</span></span><br><span class="line">gcloud components update  <span class="comment"># 更新所有已安装组件</span></span><br><span class="line">gcloud components remove [组件名称] <span class="comment"># 卸载已安装组件</span></span><br></pre></td></tr></table></figure>
<h4 id="设置-gcloud-http-代理"><a href="#设置-gcloud-http-代理" class="headerlink" title="设置 gcloud http 代理"></a>设置 gcloud http 代理</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcloud config <span class="built_in">set</span> proxy/<span class="built_in">type</span> http</span><br><span class="line">gcloud config <span class="built_in">set</span> proxy/address 127.0.0.1</span><br><span class="line">gcloud config <span class="built_in">set</span> proxy/port 1087</span><br></pre></td></tr></table></figure>
<h4 id="设置集群-docker-私服认证："><a href="#设置集群-docker-私服认证：" class="headerlink" title="设置集群 docker 私服认证："></a>设置集群 docker 私服认证：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret docker-registry regcred --docker-server=&lt;your-registry-server&gt; --docker-username=&lt;your-name&gt; --docker-password=&lt;your-pword&gt; --docker-email=&lt;your-email&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：设置 docker 私服后，要在 GKE 部署 k8s 服务，必须得在 k8s 资源文件（yaml 格式）中的 container<br>同一级指定 imagePullSecrets 键，要不然仍然无法拉取配置的私服的镜像，示例文件如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">private-reg</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">private-reg-container</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">&lt;your-private-image&gt;</span></span><br><span class="line"><span class="attr">  imagePullSecrets:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">regcred</span></span><br></pre></td></tr></table></figure></p>
<h4 id="查看集群-docker-私服配置："><a href="#查看集群-docker-私服配置：" class="headerlink" title="查看集群 docker 私服配置："></a>查看集群 docker 私服配置：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get secret regcred --output=yaml      <span class="comment">#base64 格式 显示</span></span><br><span class="line">kubectl get secret regcred --output=<span class="string">"jsonpath=&#123;.data.\.dockerconfigjson&#125;"</span> | base64 -d <span class="comment"># base64 解密后内容</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Google Cloud Platform </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GKE </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[配置 gcloud 使用 Shadowsocks HTTP 代理]]></title>
      <url>/2018/04/14/%E9%85%8D%E7%BD%AE-gcloud-%E4%BD%BF%E7%94%A8-Shadowsocks-HTTP-%E4%BB%A3%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="配置-gcloud-使用-Shadowsocks-HTTP-代理"><a href="#配置-gcloud-使用-Shadowsocks-HTTP-代理" class="headerlink" title="配置 gcloud 使用 Shadowsocks HTTP 代理"></a>配置 gcloud 使用 Shadowsocks HTTP 代理</h2><h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>最近在使用 <a href="https://cloud.google.com/sdk/?hl=zh-cn" target="_blank" rel="noopener">gcloud</a> 访问 <a href="https://cloud.google.com/?hl=zh-cn" target="_blank" rel="noopener">gcp(Google Cloud Platform)</a> 的资源，但是由于 GFW 的原因必须得配个 HTTP 代理才能访问。虽然之前装个 Shadowsock-X 可以突破 GFW 用浏览器访问 Google，但是 Shadowsock-X 默认只开启 SOCKS 代理，并没有提供 HTTP 代理。为了让 shadowsocks 开启 HTTP 代理，必须得想一些办法了，要不然没法工作了。。。</p>
<h3 id="2-解决问题"><a href="#2-解决问题" class="headerlink" title="2. 解决问题"></a>2. 解决问题</h3><p>经过一番 google，取而代之的是使用 <a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">Shadowsocks-NG</a> 客户端，其实就是 <a href="https://github.com/shadowsocks/shadowsocks/wiki/Ports-and-Clients#os-x" target="_blank" rel="noopener">Shadowsocks-X</a> 的升级版，有了更多丰富的功能，最主要的是该客户端启动后默认就开启了 HTTP 代理，可以直接供 gcloud 等命令行工具使用。具体配置 gcloud 使用 Shadowsocks-NG http 代理的方法如下：</p>
<ol>
<li>点击如下链接下载并安装 Shadowsocks-NG：<br><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/ShadowsocksX-NG/releases</a></li>
<li><p>启动 Shadowsocks-NG，填入 shadowsocks 服务端 ip，端口，加密方式等信息<br>注意：不能勾选<code>启用 OTA（被启用）</code>复选框<br><img src="/images/ss-1.png" alt=""></p>
</li>
<li><p>获取 HTTP 代理的 IP 和端口<br>点击<code>偏好设置</code>查看 HTTP 代理 IP 及端口：<br><img src="/images/ss-2.png" alt=""><br><img src="/images/ss-3.png" alt=""></p>
</li>
<li><p>设置 gcloud HTTP 代理<br>使用如下命令设置上一步获取的 Shadowsocks-NG HTTP 代理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcloud config <span class="built_in">set</span> proxy/<span class="built_in">type</span> http</span><br><span class="line">gcloud config <span class="built_in">set</span> proxy/address 127.0.0.1</span><br><span class="line">gcloud config <span class="built_in">set</span> proxy/port 1087</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就可以畅通无阻地访问 google 云平台资源了</p>
</li>
</ol>
<h3 id="3-相关链接"><a href="#3-相关链接" class="headerlink" title="3. 相关链接"></a>3. 相关链接</h3><p><a href="https://www.stefanwienert.de/blog/2018/01/21/shadowsocks-quick-guide-for-restricted-internet-environments/" target="_blank" rel="noopener">https://www.stefanwienert.de/blog/2018/01/21/shadowsocks-quick-guide-for-restricted-internet-environments/</a></p>
]]></content>
      
        <categories>
            
            <category> Google Cloud Platform </category>
            
        </categories>
        
        
        <tags>
            
            <tag> gcp </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo-next-主题配置gitalk评论-爬坑记]]></title>
      <url>/2018/03/25/hexo-next-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AEgitalk%E8%AF%84%E8%AE%BA-%E7%88%AC%E5%9D%91%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>本文主要记录了我在配置 <a href="https://hexo.io/zh-cn/index.html" target="_blank" rel="noopener">Hexo</a> 博客 <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk</a> 评论功能时踩过的坑到最终爬出坑的过程，本教程献给打算给 Hexo 博客配置 gitalk 评论的小白朋友们（当然我也是 QAQ），避免再次踩同样的坑。本教程比较特殊，网上很多关于 gitalk 的教程，我就懒的再写一遍了，所以就将我在配置过程中提的 <a href="https://github.com/gitalk/gitalk/issues/115#event-1539518527" target="_blank" rel="noopener">issue #115</a> 直接导出成 pdf 并嵌入文章，跟着该 <a href="https://github.com/gitalk/gitalk/issues/115#event-1539518527" target="_blank" rel="noopener">issue #115</a> 做一遍即可完成 Hexo Next 主题 gitalk 评论功能的配置，教程如下：</p>
<p><iframe src="/pdf/hexo-next-主题配置gitalk评论-爬坑记.pdf" style="width:100%; height:800px"></iframe></p>
<h4 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h4><p>感谢 Github 社区广大极客们的帮助，特别感谢 <a href="https://github.com/iochen" target="_blank" rel="noopener">@iochen</a> 这位大哥的帮助！</p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 评论 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python 两大环境管理神器：pyenv 和 virtualenv]]></title>
      <url>/2018/03/24/Python-%E4%B8%A4%E5%A4%A7%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8%EF%BC%9Apyenv-%E5%92%8C-virtualenv/</url>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><hr>
<p><a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">pyenv</a> 是一个开源的 Python 版本管理工具，可以轻松地给系统安装任意 Python 版本，想玩哪个版本，瞬间就可以切换。有了 <code>pyenv</code>，我们不需要再为系统多版本 Python 共存问题而发愁，也不用为手动编译安装其他 Python 版本而浪费时间，只需要执行一条简单的命令就可以切换并使用任何其他版本，该工具真正地做到了开箱即用，简单实用。</p>
<p><a href="https://github.com/pypa/virtualenv" target="_blank" rel="noopener">virtualenv</a> 是一个用来创建完全隔离的 Python 虚拟环境的工具，可以为每个项目工程创建一套独立的 Python 环境，从而可以解决不同工程对 Python 包，或者版本的依赖问题。假如有 A 和 B 两个工程，A 工程代码要跑起来需要 <code>requests 1.18.4</code>，而 B 工程跑起来需要 <code>requests 2.18.4</code>，这样在一个系统中就无法满足两个工程同时运行问题了。最好的解决办法是用 <code>virtualenv</code> 给每个工程创建一个完全隔离的 Python 虚拟环境，给每个虚拟环境安装相应版本的包，让程序使用对应的虚拟环境运行即可。这样既不影响系统 Python 环境，也能保证任何版本的 Python 程序可以在同一系统中运行。</p>
<p><strong>最佳实践：</strong>使用 <code>pyenv</code> 安装任何版本的 Python，然后用 <code>virtualenv</code> 创建虚拟环境时指定需要的 Python 版本路径，这样就可以创建任何版本的虚拟环境，这样的实践真是极好的！</p>
<h4 id="pyenv-的安装及使用"><a href="#pyenv-的安装及使用" class="headerlink" title="pyenv 的安装及使用"></a>pyenv 的安装及使用</h4><hr>
<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><ul>
<li><p>将 <code>pyenv</code> 安装到 <code>~/.pyenv</code> 目录（当然你可以安装到任意其他路径）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yyuu/pyenv.git ~/.pyenv</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量（我的 Shell 是 zsh，如果是 bash，请添加到 <code>~/.bashrc</code>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'export PYENV_ROOT="$HOME/.pyenv"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH="$PYENV_ROOT/bin:$PATH"'</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加 <code>pyenv</code> 初始化（我的 Shell 是 zsh，如果是 bash，请添加到 <code>~/.bashrc</code>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'eval "$(pyenv init -)"'</span> &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure>
</li>
<li><p>使当前 Shell 配置生效，完成安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="variable">$SHELL</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h4><ul>
<li><p>查看有哪些 Python 版本可以安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装某个 Python 版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install -v 3.6.4</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前 Python 版本情况（<code>*</code> 表示系统当前的 Python 版本，<code>system</code>表示系统初始版本）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pyenv versions</span><br><span class="line">  system</span><br><span class="line">  2.6.7</span><br><span class="line">* 3.6.4 (<span class="built_in">set</span> by /Users/haohao/.pyenv/version)</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换 Python 版本（切换之后查看当前版本）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pyenv global 3.6.4</span><br><span class="line">$ pyenv versions</span><br><span class="line">  system</span><br><span class="line">* 3.6.4 (<span class="built_in">set</span> by /Users/haohao/.pyenv/version)</span><br><span class="line">$ python -V</span><br><span class="line">Python 3.6.4</span><br></pre></td></tr></table></figure>
</li>
<li><p>卸载某个 Python 版本</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pyenv</span> <span class="selector-tag">uninstall</span> 3<span class="selector-class">.6</span><span class="selector-class">.4</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="virtualenv-的安装及使用"><a href="#virtualenv-的安装及使用" class="headerlink" title="virtualenv 的安装及使用"></a>virtualenv 的安装及使用</h4><hr>
<h4 id="1-安装-1"><a href="#1-安装-1" class="headerlink" title="1. 安装"></a>1. 安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install virtualenv</span><br></pre></td></tr></table></figure>
<h4 id="2-使用-1"><a href="#2-使用-1" class="headerlink" title="2. 使用"></a>2. 使用</h4><p>下面我们使用 <code>virtualenv</code> 创建一个完全隔离的 Python 虚拟环境：</p>
<ol>
<li><p>新建一个目录（一般用来用作工程路径）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myproject</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入目录创建一个完全独立干净的虚拟环境<br>如果 <code>virtualenv</code> 后面不加任何参数，那么默认创建的虚拟环境的 Python 版本是系统当前版本，如果要创建其他版本，可以使用 <code>-p</code> 参数指定其他版本的 <code>python</code> 可执行文件路径。可执行文件可以在上一步安装的 <code>pyenv</code> 的 <code>~/.pyenv/versions</code> 路径找到，该路径是 <code>pyenv</code> 管理的所有 Python 版本路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用系统当前的 Python 版本创建虚拟环境</span></span><br><span class="line">$ virtualenv venv</span><br><span class="line">New python executable <span class="keyword">in</span> /Users/haohao/PycharmProjects/myproject/venv/bin/python</span><br><span class="line"><span class="comment"># 创建虚拟环境时指定 Python 版本</span></span><br><span class="line">$ virtualenv -p ~/.pyenv/versions/2.6.7/bin/python venv</span><br><span class="line">Running virtualenv with interpreter /Users/haohao/.pyenv/versions/2.6.7/bin/python</span><br><span class="line">New python executable <span class="keyword">in</span> /Users/haohao/PycharmProjects/myproject/venv/bin/python</span><br><span class="line">Installing setuptools&lt;37, pip, wheel&lt;0.30...done.</span><br></pre></td></tr></table></figure>
</li>
<li><p>激活创建的虚拟环境并使用<br>可以看出当前虚拟环境版本已经是 Python 2.6.7 了，而且所在路径确实是在上一步创建的虚拟环境路径。接下来使用 <code>pip</code> 安装的任何包都会安装在虚拟环境目录里面，不会安装在系统标准目录，从而保证当前环境是绝对干净的，对于系统是完全隔离的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">source</span> venv/bin/activate</span><br><span class="line">$ <span class="built_in">which</span> python</span><br><span class="line">/Users/haohao/PycharmProjects/myproject/venv/bin/python</span><br><span class="line">$ python -V</span><br><span class="line">Python 2.6.7</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出虚拟环境，回到系统版本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ deactivate</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Aws Ec2 实例外挂 EBS 卷详细步骤]]></title>
      <url>/2018/03/19/Aws-Ec2-%E5%AE%9E%E4%BE%8B%E5%A4%96%E6%8C%82-EBS-%E5%8D%B7%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</url>
      <content type="html"><![CDATA[<ol>
<li>附加新建的卷到 ec2 实例（这一步在 aws 控制台进行）；</li>
<li>对附加的卷分区（在这里分一个区）：<br><code>fdisk 设备名</code> （ex:  <code>/dev/xvdb</code>）<br>m<br>n<br>p<br>w</li>
<li>给分区初始化文件系统（在这里写入 ext4 文件系统）：<br><code>mkfs.ext4 分区标识</code>（ex: <code>/dev/xvdb1</code>）<br>举例：<code>mkfs.ext4 /dev/xvdb1</code></li>
<li>执行 <code>mount</code> 命令挂载分区到指定目录：<br><code>mount 分区标识</code>（ex: <code>/dev/xvdb1</code>） <code>挂载目录</code><br>举例：<code>mount /dev/xvdb1 /data</code></li>
<li>设置开机自动挂载：<br><code>vim /etc/fstab</code> # 文件追加如下一行内容<br><code>分区标识（ex:/dev/xvdb1）挂载目录 文件系统类型 defaults 1 2</code><br>举例：<code>/dev/xvdb1 /data  ext4    defaults    1  2</code></li>
</ol>
]]></content>
      
        <categories>
            
            <category> AWS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python Plumbum 简介（翻译）]]></title>
      <url>/2018/03/19/Python-Plumbum-%E7%AE%80%E4%BB%8B%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<blockquote>
<p>说明：本文翻译自 <a href="https://plumbum.readthedocs.io/en/latest/" target="_blank" rel="noopener">Plumbum 官网主页</a>，对少量不太重要的内容进行了缩减。</p>
</blockquote>
<h4 id="Plumbum：Shell-组合器"><a href="#Plumbum：Shell-组合器" class="headerlink" title="Plumbum：Shell 组合器"></a>Plumbum：Shell 组合器</h4><hr>
<blockquote>
<p>你是否曾希望将 shell 脚本紧凑地融入到<strong>真正</strong>的编程语言里面？向 <em>Plumbum Shell Combinators</em> 问好。Plumbum （lead 的拉丁语，以前用来制作管道）是一个小型但功能丰富的 Python 类 shell 脚本程序库。该库的理念是 “<strong>永远不要再写 shell 脚本</strong>”，因此它试图合理地模仿 shell 语法（shell 组合器），同时保持 <strong>Python 特性和跨平台</strong>。</p>
<p>除了<a href="https://plumbum.readthedocs.io/en/latest/local_commands.html#guide-local-commands" target="_blank" rel="noopener">类似 shell 的语法</a>和<a href="https://plumbum.readthedocs.io/en/latest/utils.html#guide-utils" target="_blank" rel="noopener">便捷的快捷方式</a>之外，该库还提供本地和<a href="https://plumbum.readthedocs.io/en/latest/remote.html#guide-remote-commands" target="_blank" rel="noopener">远程</a>命令执行（通过 SSH）、本地和远程文件系统<a href="https://plumbum.readthedocs.io/en/latest/paths.html#guide-paths" target="_blank" rel="noopener">路径</a>、简单的工作目录和环境<a href="https://plumbum.readthedocs.io/en/latest/local_machine.html#guide-local-machine" target="_blank" rel="noopener">操作</a>、快捷访问 ANSI 颜色，以及<a href="https://plumbum.readthedocs.io/en/latest/cli.html#guide-cli" target="_blank" rel="noopener">编程命令行接口（CLI）</a>应用程序工具包。现在让我们看一些代码！</p>
</blockquote>
<h4 id="新闻"><a href="#新闻" class="headerlink" title="新闻"></a>新闻</h4><hr>
<p><em>略。。。</em></p>
<h4 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h4><hr>
<h5 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> plumbum <span class="keyword">import</span> local</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls = local[<span class="string">"ls"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls</span><br><span class="line">LocalCommand(&lt;LocalPath /bin/ls&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ls()</span><br><span class="line"><span class="string">u'build.py\ndist\ndocs\nLICENSE\nplumbum\nREADME.rst\nsetup.py\ntests\ntodo.txt\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>notepad = local[<span class="string">"c:\\windows\\notepad.exe"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>notepad()                                   <span class="comment"># Notepad window pops up</span></span><br><span class="line"><span class="string">u''</span>                                             <span class="comment"># Notepad window is closed by user, command returns</span></span><br></pre></td></tr></table></figure>
<p>不需要为每个你想使用的命令写 <code>xxx = local[&quot;xxx&quot;]</code>，你可以<a href="https://plumbum.readthedocs.io/en/latest/local_commands.html#import-hack" target="_blank" rel="noopener">导入命令行</a>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> plumbum.cmd <span class="keyword">import</span> grep, wc, cat, head</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grep</span><br><span class="line">LocalCommand(&lt;LocalPath /bin/grep&gt;)</span><br></pre></td></tr></table></figure></p>
<p>见<a href="https://plumbum.readthedocs.io/en/latest/local_commands.html#guide-local-commands" target="_blank" rel="noopener">本地命令行</a> 。</p>
<h5 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain = ls[<span class="string">"-a"</span>] | grep[<span class="string">"-v"</span>, <span class="string">"\\.py"</span>] | wc[<span class="string">"-l"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> chain</span><br><span class="line">/bin/ls -a | /bin/grep -v <span class="string">'\.py'</span> | /usr/bin/wc -l</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chain()</span><br><span class="line"><span class="string">u'13\n'</span></span><br></pre></td></tr></table></figure>
<p>见<a href="https://plumbum.readthedocs.io/en/latest/local_commands.html#guide-local-commands-pipelining" target="_blank" rel="noopener">管道</a>。</p>
<h5 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>((cat &lt; <span class="string">"setup.py"</span>) | head[<span class="string">"-n"</span>, <span class="number">4</span>])()</span><br><span class="line"><span class="string">u'#!/usr/bin/env python\nimport os\n\ntry:\n'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(ls[<span class="string">"-a"</span>] &gt; <span class="string">"file.list"</span>)()</span><br><span class="line"><span class="string">u''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(cat[<span class="string">"file.list"</span>] | wc[<span class="string">"-l"</span>])()</span><br><span class="line"><span class="string">u'17\n'</span></span><br></pre></td></tr></table></figure>
<p>见<a href="https://plumbum.readthedocs.io/en/latest/local_commands.html#guide-local-commands-redir" target="_blank" rel="noopener">输入/输出重定向</a>。</p>
<h5 id="工作目录操作"><a href="#工作目录操作" class="headerlink" title="工作目录操作"></a>工作目录操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>local.cwd</span><br><span class="line">&lt;Workdir /home/tomer/workspace/plumbum&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> local.cwd(local.cwd / <span class="string">"docs"</span>):</span><br><span class="line"><span class="meta">... </span>    chain()</span><br><span class="line">...</span><br><span class="line"><span class="string">u'15\n'</span></span><br></pre></td></tr></table></figure>
<p>见<a href="https://plumbum.readthedocs.io/en/latest/paths.html#guide-paths" target="_blank" rel="noopener">路径</a>和<a href="https://plumbum.readthedocs.io/en/latest/local_machine.html#guide-local-machine" target="_blank" rel="noopener">本地对象</a> 。</p>
<h5 id="前台后和后台执行"><a href="#前台后和后台执行" class="headerlink" title="前台后和后台执行"></a>前台后和后台执行</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> plumbum <span class="keyword">import</span> FG, BG</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(ls[<span class="string">"-a"</span>] | grep[<span class="string">"\\.py"</span>]) &amp; FG         <span class="comment"># The output is printed to stdout directly</span></span><br><span class="line">build.py</span><br><span class="line">.pydevproject</span><br><span class="line">setup.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(ls[<span class="string">"-a"</span>] | grep[<span class="string">"\\.py"</span>]) &amp; BG         <span class="comment"># The process runs "in the background"</span></span><br><span class="line">&lt;Future [<span class="string">'/bin/grep'</span>, <span class="string">'\\.py'</span>] (running)&gt;</span><br></pre></td></tr></table></figure>
<p>见<a href="https://plumbum.readthedocs.io/en/latest/local_commands.html#guide-local-commands-bgfg" target="_blank" rel="noopener">前台和后台</a>。</p>
<h5 id="命令行嵌套"><a href="#命令行嵌套" class="headerlink" title="命令行嵌套"></a>命令行嵌套</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> plumbum.cmd <span class="keyword">import</span> sudo</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sudo[ifconfig[<span class="string">"-a"</span>]]</span><br><span class="line">/usr/bin/sudo /sbin/ifconfig -a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(sudo[ifconfig[<span class="string">"-a"</span>]] | grep[<span class="string">"-i"</span>, <span class="string">"loop"</span>]) &amp; FG</span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:<span class="number">16436</span>  Metric:<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>见<a href="https://plumbum.readthedocs.io/en/latest/local_commands.html#guide-local-commands-nesting" target="_blank" rel="noopener">命令行嵌套</a>。</p>
<h5 id="远程命令（通过-SSH）"><a href="#远程命令（通过-SSH）" class="headerlink" title="远程命令（通过 SSH）"></a>远程命令（通过 SSH）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> plumbum <span class="keyword">import</span> SshMachine</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>remote = SshMachine(<span class="string">"somehost"</span>, user = <span class="string">"john"</span>, keyfile = <span class="string">"/path/to/idrsa"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r_ls = remote[<span class="string">"ls"</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> remote.cwd(<span class="string">"/lib"</span>):</span><br><span class="line"><span class="meta">... </span>    (r_ls | grep[<span class="string">"0.so.0"</span>])()</span><br><span class="line">...</span><br><span class="line"><span class="string">u'libusb-1.0.so.0\nlibusb-1.0.so.0.0.0\n'</span></span><br></pre></td></tr></table></figure>
<p>见<a href="https://plumbum.readthedocs.io/en/latest/remote.html#guide-remote" target="_blank" rel="noopener">远程</a>。</p>
<h5 id="CLI-应用程序"><a href="#CLI-应用程序" class="headerlink" title="CLI 应用程序"></a>CLI 应用程序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> plumbum <span class="keyword">import</span> cli</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompiler</span><span class="params">(cli.Application)</span>:</span></span><br><span class="line">    verbose = cli.Flag([<span class="string">"-v"</span>, <span class="string">"--verbose"</span>], help = <span class="string">"Enable verbose mode"</span>)</span><br><span class="line">    include_dirs = cli.SwitchAttr(<span class="string">"-I"</span>, list = <span class="keyword">True</span>, help = <span class="string">"Specify include directories"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cli.switch("-loglevel", int)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_log_level</span><span class="params">(self, level)</span>:</span></span><br><span class="line">        <span class="string">"""Sets the log-level of the logger"""</span></span><br><span class="line">        logging.root.setLevel(level)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(self, *srcfiles)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Verbose:"</span>, self.verbose</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Include dirs:"</span>, self.include_dirs</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Compiling:"</span>, srcfiles</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    MyCompiler.run()</span><br></pre></td></tr></table></figure>
<p>输出样例<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python simple_cli.py -v -I foo/bar -Ispam/eggs x.cpp y.cpp z.cpp</span><br><span class="line">Verbose: <span class="keyword">True</span></span><br><span class="line">Include dirs: [<span class="string">'foo/bar'</span>, <span class="string">'spam/eggs'</span>]</span><br><span class="line">Compiling: (<span class="string">'x.cpp'</span>, <span class="string">'y.cpp'</span>, <span class="string">'z.cpp'</span>)</span><br></pre></td></tr></table></figure></p>
<p>见<a href="https://plumbum.readthedocs.io/en/latest/cli.html#guide-cli" target="_blank" rel="noopener">命令行应用程序</a>。</p>
<h5 id="颜色和风格"><a href="#颜色和风格" class="headerlink" title="颜色和风格"></a>颜色和风格</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> plumbum <span class="keyword">import</span> colors</span><br><span class="line"><span class="keyword">with</span> colors.red:</span><br><span class="line">    print(<span class="string">"This library provides safe, flexible color access."</span>)</span><br><span class="line">    print(colors.bold | <span class="string">"(and styles in general)"</span>, <span class="string">"are easy!"</span>)</span><br><span class="line">print(<span class="string">"The simple 16 colors or"</span>,</span><br><span class="line">      colors.orchid &amp; colors.underline | <span class="string">'256 named colors,'</span>,</span><br><span class="line">      colors.rgb(<span class="number">18</span>, <span class="number">146</span>, <span class="number">64</span>) | <span class="string">"or full rgb colors"</span> ,</span><br><span class="line">      <span class="string">'can be used.'</span>)</span><br><span class="line">print(<span class="string">"Unsafe "</span> + colors.bg.dark_khaki + <span class="string">"color access"</span> + colors.bg.reset + <span class="string">" is available too."</span>)</span><br></pre></td></tr></table></figure>
<p>输出样例<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This library provides safe color access.</span><br><span class="line">Color (<span class="keyword">and</span> styles <span class="keyword">in</span> general) are easy!</span><br><span class="line">The<span class="built_in"> simple </span>16 colors, 256 named colors, <span class="keyword">or</span> full hex colors can be used.</span><br><span class="line">Unsafe color access is available too.</span><br></pre></td></tr></table></figure></p>
<p>见<a href="https://plumbum.readthedocs.io/en/latest/colors.html#guide-colors" target="_blank" rel="noopener">颜色</a>。</p>
<h4 id="开发和安装"><a href="#开发和安装" class="headerlink" title="开发和安装"></a>开发和安装</h4><hr>
<p>该库在 <a href="https://github.com/tomerfiliba/plumbum" target="_blank" rel="noopener">Github</a> 上开发，非常乐意接受来自用户的<a href="https://help.github.com/send-pull-requests/" target="_blank" rel="noopener">补丁</a>。请使用 GitHub 的内置 <a href="https://github.com/tomerfiliba/plumbum/issues" target="_blank" rel="noopener">issue 跟踪器</a>报告您遇到的任何问题或提出功能上的需求。该库在 <a href="https://github.com/tomerfiliba/plumbum/blob/master/LICENSE" target="_blank" rel="noopener">IMIT 许可</a>下发布。</p>
<h5 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h5><p>Plumbum 支持 <strong>Python 2.6-3.6</strong> 和 <strong>PyPy</strong>，并且通过 <a href="https://travis-ci.org/tomerfiliba/plumbum" target="_blank" rel="noopener"><strong>Travis CI</strong></a> 和 <a href="https://ci.appveyor.com/project/HenrySchreiner/plumbum/branch/master" target="_blank" rel="noopener"><strong>Appveyor</strong></a> 持续地在 <strong>Linux</strong>，<strong>Mac</strong> 和 <strong>Windows</strong> 机器上测试。Plumbum 在任何类 Unix 的机器都应该可以正常工作，除了 Windows，你也许需要安装一个合适的 <a href="https://www.wikiwand.com/en/Coreutils" target="_blank" rel="noopener"><strong>coreutils</strong></a> 环境并把其加入到你的<code>PATH</code>环境变量中。我推荐 <a href="http://mingw.org/" target="_blank" rel="noopener"><strong>mingw</strong></a>（与 <a href="http://msysgit.github.io/" target="_blank" rel="noopener"><strong>Windows Git</strong></a> 捆绑在一起），但是 <a href="http://www.cygwin.com/" target="_blank" rel="noopener"><strong>cygwin</strong></a> 应该也可以。如果你仅仅是使用 Plumbum 代替 Popen 来运行 Windows 程序，那么就不需要 Unix 工具了。<br>注意远程命令的执行，需要一个 <strong>openSHH 兼容的</strong>客户端（同样与 <em>Windows Git</em> 捆绑在一起）和一个 bash 兼容的 shell，也需要在主机上有一个 coreutils 环境。</p>
<h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p>你可以在 <a href="https://pypi.python.org/pypi/plumbum#downloads" target="_blank" rel="noopener"><strong>Python Package Index</strong></a> （多种格式）下载该库，或者直接运行 <code>pip install plumbum</code>。如果你使用 Anaconda，你可以使用 <code>conda install -c conda-forge plumbum</code> 从 <code>conda-forge</code> 通道获取。</p>
<h4 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h4><hr>
<p>用户指南涵盖了 Plumbum 大部分功能，拥有大量的代码片段，你可以不用花多少时间即可开始使用。该指南逐渐介绍概念和”语法”，因此推荐你按照顺序阅读。一个<a href="https://plumbum.readthedocs.io/en/latest/quickref.html#guide-quickref" target="_blank" rel="noopener"><strong>有效的快速参考指南</strong></a>。<br><em>略。。。</em></p>
<h4 id="API-参考"><a href="#API-参考" class="headerlink" title="API 参考"></a>API 参考</h4><hr>
<p>API 参考（在库中通过 <em>docstrings</em> 生成的）涵盖了所有暴露的 API。注意，一些“高级的”功能和一些函数参数在用户指南中没有，因此在这种情况下你也许需要参考下 API 文档。<br><em>略。。。</em></p>
<h4 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h4><hr>
<p>Plumburn 最初的目的是让本地和远程程序轻松地执行，假设没有比老的 ssh 更时髦的东西了。在此基础上，设计了一个文件系统抽象层，以便能够无缝地处理本地和远程文件。<br>我有这个想法一段时间了，直到我必须要个给我当前工作的项目写一个构建脚本，我决定使用 shell 脚本，现在是实现它的时候了。Plumbum 诞生自 <code>Path</code> 类的片段和我为 <a href="http://rpyc.readthedocs.io/en/latest/" target="_blank" rel="noopener"><strong>RPyC</strong></a> 写的 <code>SshContext</code> 和 <code>SshTunnel</code> 类。<code>Path</code> 类是我为前面说的构建系统写的。当我将两者与 <em>shell 组合器</em>（因为 shell 脚本在这里确实有优势）组合在一起时，奇迹就发生了，便产生了Plumbun。</p>
<h4 id="赞扬"><a href="#赞扬" class="headerlink" title="赞扬"></a>赞扬</h4><hr>
<p>该项目受到了 <a href="https://github.com/amoffat" target="_blank" rel="noopener"><strong>Andrew Moffat</strong></a> 的 <strong>PBS</strong>（现在被称作 <a href="http://amoffat.github.io/sh/" target="_blank" rel="noopener"><strong>sh</strong></a>）启发，并且借用了他的一些思想（即像函数一样看待程序，导入命令行的技巧）。然而我感觉在 PBS 中有太多的魔力在继续，当我编写类 shell 程序时，语法不是我想要的。关于这个问题我联系了 Andrew，但是他想让 PBS 保持这种状态。除此之外，两个库走不同的方向，Plumbum 试图提供一种更合理的方法。<br>Plumbum 也向 <a href="https://github.com/vmalloc/" target="_blank" rel="noopener"><strong>Rotem Yaari</strong></a> 致敬，他为特定的目的建议了一个代号为 <code>pyplatform</code> 的库，但是从未实现过。</p>
]]></content>
      
        <categories>
            
            <category> 翻译 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shadowsocks 使用]]></title>
      <url>/2018/03/18/shadowsocks-%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/shadowsocks/shadowsocks/blob/master/README.md" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks/blob/master/README.md</a></p>
<h3 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h3><ul>
<li>前台启动<br><code>sudo ssserver -p 443 -k password -m aes-256-cfb</code></li>
<li>后台启动<br><code>sudo ssserver -p 443 -k password -m aes-256-cfb -d start</code></li>
<li>停止<br><code>sudo ssserver -d stop</code></li>
<li>查看日志<br><code>sudo less /var/log/shadowsocks.log</code></li>
</ul>
<h3 id="使用配置文件启动（墙裂推荐该方式）"><a href="#使用配置文件启动（墙裂推荐该方式）" class="headerlink" title="使用配置文件启动（墙裂推荐该方式）"></a>使用配置文件启动（墙裂推荐该方式）</h3><ul>
<li><p>前台启动：<br><code>sudo ssserver -c /etc/shadowsocks.json</code></p>
</li>
<li><p>后台启动：<br><code>sudo ssserver -c /etc/shadowsocks.json -d start</code></p>
</li>
<li>停止服务：<br><code>sudo ssserver -c /etc/shadowsocks.json -d stop</code></li>
</ul>
<p><a href="https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File" target="_blank" rel="noopener">shadowsocks.json 配置文件格式</a></p>
<p>配置文件示例（单服务器多账号配置）:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>:<span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port："</span>:<span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"port_password"</span>:&#123;</span><br><span class="line">      <span class="attr">"1851"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">      <span class="attr">"1852"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">      <span class="attr">"1853"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">      <span class="attr">"1854"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">      <span class="attr">"1855"</span>:<span class="string">"xxxx"</span>,</span><br><span class="line">      <span class="attr">"1856"</span>:<span class="string">"xxxx"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"timeout"</span>:<span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>:<span class="string">"aes-256-cfb"</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="故障排查"><a href="#故障排查" class="headerlink" title="故障排查"></a>故障排查</h3><p>如果 shadowsocks.json 配置文件中 server 字段配成公网IP，而不是 <code>0.0.0.0</code>，会报如下错误：</p>
<p><code>socket.error: [Errno 99] Cannot assign requested address</code></p>
]]></content>
      
        <categories>
            
            <category> vpn </category>
            
        </categories>
        
        
        <tags>
            
            <tag> shadowsocks </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的 Mac 终端配置（Mac OSX + iTerm2 + Zsh + Oh-My-Zsh）]]></title>
      <url>/2018/03/18/%E6%88%91%E7%9A%84-Mac-%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%EF%BC%88Mac-OSX-iTerm2-Zsh-Oh-My-Zsh%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><strong>相关工具介绍</strong></p>
<ol>
<li><strong>iTerm2</strong>：Mac 下 Terminal 终端的替代品，拥有更多强大的功能，想了解更多请戳 <a href="https://www.iterm2.com/" target="_blank" rel="noopener">iTerm2 官网</a>；</li>
<li><strong>zsh</strong>：Linux 的一种 shell 外壳，和 bash 属于同类产品；</li>
<li><strong>Oh-My-Zsh</strong>：用来管理 zsh 的配置，同时还有很多社区贡献的主题配置以及好用的插件可供使用，了解更多请戳 <a href="http://ohmyz.sh/" target="_blank" rel="noopener">Oh-My-Zsh 官网</a> ；</li>
</ol>
<p><strong>配置方案总览</strong></p>
<ol>
<li><a href="https://www.iterm2.com/" target="_blank" rel="noopener">iTerm2</a> 终端工具；</li>
<li>iTerm2 <a href="https://github.com/mbadolato/iTerm2-Color-Schemes/blob/master/schemes/Solarized%20Dark%20Higher%20Contrast.itermcolors" target="_blank" rel="noopener">Solarized Dark Higher Contrast 配色方案</a>；</li>
<li><a href="https://github.com/supermarin/powerline-fonts" target="_blank" rel="noopener">Monaco for Powerline 字体</a>；</li>
<li>zsh （Mac 系统自带，无需安装）；</li>
<li><a href="http://ohmyz.sh/" target="_blank" rel="noopener">Oh-My-Zsh</a>；</li>
<li><a href="https://github.com/bhilburn/powerlevel9k" target="_blank" rel="noopener">Oh-My-Zsh powerlevel9k 主题</a>；</li>
</ol>
<p><strong>最终效果：</strong><br><img src="https://gist.githubusercontent.com/qhh0205/5570934d25a627dd9e9629a8ceeb415c/raw/8f5b3e5ece35629f04fcf66fbc94338e730c3bcd/z-mac-terminal-config-sample1.png" alt="z-mac-terminal-config-sample1"><br><img src="https://gist.githubusercontent.com/qhh0205/5570934d25a627dd9e9629a8ceeb415c/raw/8f5b3e5ece35629f04fcf66fbc94338e730c3bcd/z-mac-terminal-config-sample2.png" alt="z-mac-terminal-config-sample2"><br><img src="https://gist.githubusercontent.com/qhh0205/5570934d25a627dd9e9629a8ceeb415c/raw/8f5b3e5ece35629f04fcf66fbc94338e730c3bcd/z-mac-terminal-config-sample3.png" alt="z-mac-terminal-config-sample3"></p>
<h4 id="具体配置步骤"><a href="#具体配置步骤" class="headerlink" title="具体配置步骤"></a>具体配置步骤</h4><h5 id="1-安装-iTerm2-终端工具："><a href="#1-安装-iTerm2-终端工具：" class="headerlink" title="1. 安装 iTerm2 终端工具："></a>1. 安装 iTerm2 终端工具：</h5><p>打开 <a href="https://www.iterm2.com/" target="_blank" rel="noopener">iTerm2 官网</a> 直接点击 Download 下载并安装即可。</p>
<h5 id="2-安装-iTerm2-Solarized-Dark-Higher-Contrast-配色方案："><a href="#2-安装-iTerm2-Solarized-Dark-Higher-Contrast-配色方案：" class="headerlink" title="2. 安装 iTerm2 Solarized Dark Higher Contrast 配色方案："></a>2. 安装 iTerm2 <a href="https://github.com/mbadolato/iTerm2-Color-Schemes/blob/master/schemes/Solarized%20Dark%20Higher%20Contrast.itermcolors" target="_blank" rel="noopener">Solarized Dark Higher Contrast 配色方案</a>：</h5><p>将该配色方案文件（Solarized Dark Higher Contrast.itermcolors）复制出来，保存到本地，文件命名为 SolarizedDarkHigherContrast.itermcolors ，然后双击即可安装。安装完后打开 iTerm2 终端，依次选择菜单栏：<strong>iTerm2 –&gt; Preferences –&gt; Profiles –&gt; Colors –&gt; Colors Presets –&gt;  SolarizedDarkHigherContrast</strong>，至此 iTerm2 Solarized Dark Higher Contrast 配色方案已成功安装。</p>
<h5 id="3-安装-Monaco-for-Powerline-字体："><a href="#3-安装-Monaco-for-Powerline-字体：" class="headerlink" title="3. 安装  Monaco for Powerline 字体："></a>3. 安装  <a href="https://github.com/supermarin/powerline-fonts" target="_blank" rel="noopener">Monaco for Powerline 字体</a>：</h5><p>将该仓库克隆到本地，然后进入工程目录的 Monaco 目录，双击后缀名为 .otf 的字体文件即可完成该字体的安装。安装该字体的原因主要是为了和 Oh-My-Zsh 的 powerlevel9k 主题相兼容，如果不安装该字体，那么后面安装 powerlevel9kn 主题后会出现乱码。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该仓库中包含好几种优化后的字体</span></span><br><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/supermarin/powerline-fonts.git</span><br></pre></td></tr></table></figure></p>
<h5 id="4-安装配置-zsh："><a href="#4-安装配置-zsh：" class="headerlink" title="4. 安装配置 zsh："></a>4. 安装配置 zsh：</h5><p>zsh 一般 Mac 已经自带了，无需额外安装。可以用 cat /etc/shells 查看 zsh 是否安装，如果列出了 /bin/zsh 则表明 zsh 已经安装了。<br>接下来修改 iTerm2 终端的默认 Shell，可以用 echo $SHELL 查看当前 Shell 是什么，如果不是 /bin/zsh 则用如下命令修改 iTerm2 的默认 Shell 为 zsh：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s <span class="regexp">/bin/</span>zsh</span><br></pre></td></tr></table></figure></p>
<h5 id="5-安装-Oh-My-Zsh："><a href="#5-安装-Oh-My-Zsh：" class="headerlink" title="5. 安装  Oh-My-Zsh："></a>5. 安装  <a href="http://ohmyz.sh/" target="_blank" rel="noopener">Oh-My-Zsh</a>：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure>
<h5 id="6-安装配置-Oh-My-Zsh-powerlevel9k-主题："><a href="#6-安装配置-Oh-My-Zsh-powerlevel9k-主题：" class="headerlink" title="6. 安装配置 Oh-My-Zsh powerlevel9k 主题："></a>6. 安装配置 <a href="https://github.com/bhilburn/powerlevel9k" target="_blank" rel="noopener">Oh-My-Zsh powerlevel9k 主题</a>：</h5><ul>
<li><p>克隆该仓库到 oh-my-zsh 用户自定义主题目录</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/bhilburn/</span>powerlevel9k.git ~<span class="regexp">/.oh-my-zsh/</span>custom<span class="regexp">/themes/</span>powerlevel9k</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 ~/.zshrc 配置文件，配置该主题</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ZSH_THEME</span>=<span class="string">"powerlevel9k/powerlevel9k"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改命令提示符<br>默认的命令提示符为 <em>user@userdemackbookPro</em>，这样的提示符配合 powerlevel9k 主题太过冗长，因此我选择将该冗长的提示符去掉，在 ~/.zshrc 配置文件后面追加如下内容：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：DEFAULT_USER 的值必须要是系统用户名才能生效</span></span><br><span class="line"><span class="attr">DEFAULT_USER</span>=<span class="string">"user"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>简单定制下 powerlevel9k 主题<br>powerlevel9k 主题的好处就是可以做很多自定义，只需要简单修改 ~/.zshrc 配置即可生效。更多关于该主题的定制请看 <a href="https://github.com/bhilburn/powerlevel9k#customizing-prompt-segments" target="_blank" rel="noopener">customizing-prompt-segments</a>；<br>默认的 powerlevel9k 主题最右侧显示的元素为：<em>每条命令的执行状态，历史命令条数，当前时间</em>，这样也比较冗余，我在这里将 <em>历史命令条数</em> 这一元素去掉，这样看起来比较简洁。这需要修改 ~/.zshrc 配置文件，在后面追加如下内容，定制该主题的显示元素：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 oh-my-zsh powerlevel9k 主题左边元素显示</span></span><br><span class="line"><span class="attr">POWERLEVEL9K_LEFT_PROMPT_ELEMENTS</span>=(context dir rbenv vcs)</span><br><span class="line"><span class="comment"># 设置 oh-my-zsh powerlevel9k 主题右边元素显示</span></span><br><span class="line"><span class="attr">POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS</span>=(status root_indicator background_jobs time)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="7-配置-zsh-命令语法高亮"><a href="#7-配置-zsh-命令语法高亮" class="headerlink" title="7. 配置 zsh 命令语法高亮"></a>7. 配置 zsh 命令语法高亮</h5><p><a href="https://github.com/zsh-users/zsh-syntax-highlighting" target="_blank" rel="noopener">zsh-syntax-highlighting</a> 插件可以使你终端输入的命令有语法高亮效果，安装方法如下（oh-my-zsh 插件管理的方式安装）：<br>1.Clone this repository in oh-my-zsh’s plugins directory:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/zsh-users/</span>zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span><span class="regexp">/plugins/</span>zsh-syntax-highlighting</span><br></pre></td></tr></table></figure></p>
<p>2.Activate the plugin in ~/.zshrc:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：zsh-syntax-highlighting 必须放在最后面（官方推荐）</span></span><br><span class="line"><span class="attr">plugins</span>=( [plugins...] zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure></p>
<p>3.Source ~/.zshrc to take changes into account:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></p>
<h5 id="8-安装一些比较实用的-oh-my-zsh-插件"><a href="#8-安装一些比较实用的-oh-my-zsh-插件" class="headerlink" title="8. 安装一些比较实用的 oh-my-zsh 插件"></a>8. 安装一些比较实用的 oh-my-zsh 插件</h5><p>关于 oh-my-zsh 插件的管理是很简单的，有两个插件目录：</p>
<ul>
<li><strong>/Users/user/.oh-my-zsh/plugins</strong>: oh-my-zsh 官方插件目录，该目录已经预装了很多实用的插件，只不过没激活而已；</li>
<li><strong>/Users/user/.oh-my-zsh/custom/plugins</strong>: oh-my-zsh 第三方插件目录；</li>
</ul>
<p>需要安装哪个插件，只需要把插件下载到上面任何一个目录即可，然后在 ~/.zshrc 配置文件中的 plugins 变量中添加对应插件的名称即可，以下是我挑选的几个比较好用的插件（都是官方自带的，无需另外下载），~/.zshrc 配置文件如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add wisely, as too many plugins slow down shell startup.</span></span><br><span class="line">plugins=(</span><br><span class="line">   git</span><br><span class="line">   extract</span><br><span class="line">   z</span><br><span class="line">   zsh-syntax-highlighting</span><br><span class="line"> )</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>git</strong>：oh-my-zsh 默认开启的，没什么好说的；</li>
<li><strong>extract</strong>：通用的解压缩插件，可以解压缩任何后缀的压缩文件，使用方法很简单：<em>x 文件名</em>；</li>
<li><strong>z</strong>：很智能的目录跳转插件，能记录之前 cd 过哪些目录，然后模糊匹配跳转，不需要输入全路径即可跳转，使用方法：<em>z dir_pattern</em></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Mac </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 终端 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Markdown 页面内跳转]]></title>
      <url>/2018/03/18/Markdown-%E9%A1%B5%E9%9D%A2%E5%86%85%E8%B7%B3%E8%BD%AC/</url>
      <content type="html"><![CDATA[<h4 id="Markdonwn-页面内跳转"><a href="#Markdonwn-页面内跳转" class="headerlink" title="Markdonwn 页面内跳转"></a>Markdonwn 页面内跳转</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>有时候在 Markdown 中需要点击某个链接，然后跳转到当前页面内的其他地方，而不是跳转到一个URL链接，这个在 Markdown 是可以实现的。</p>
<h5 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h5><p>1.使用 html 标签定义一个锚（id），将需要跳转的内容使用该标签包起来:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># id 可以随便定义，只要同一页面内保证唯一即可</span></span><br><span class="line">&lt;span <span class="built_in">id</span>=<span class="string">"1"</span>&gt;</span><br><span class="line">要跳转的内容（在这里可以写任意内容，MD 格式的也可以）</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></p>
<p>2.后在页面内超链接到指定锚（id）上：<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接文本</span>](<span class="link">#1</span>)</span><br></pre></td></tr></table></figure></p>
<p>举例：<br><a href="#1">~/.ssh/config GitHub Host配置</a><br>点击上面链接即可跳转到该页面中链接的代码块。<br><span id="1"><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github</span><br><span class="line">      HostName github.com</span><br><span class="line">     <span class="built_in"> User </span>git</span><br><span class="line">      IdentityFile ~/.ssh/my_github_key</span><br></pre></td></tr></table></figure></span></p>
<p></p>
]]></content>
      
        <categories>
            
            <category> Markdown </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHub多账号密钥配置]]></title>
      <url>/2018/02/19/GitHub%E5%A4%9A%E8%B4%A6%E5%8F%B7%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h4 id="GitHub多账号密钥配置"><a href="#GitHub多账号密钥配置" class="headerlink" title="GitHub多账号密钥配置"></a>GitHub多账号密钥配置</h4><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>之前在自己的GitHub账号配置过本地电脑的ssh key，然后用同样的ssh key给另外一个GitHub账号配置密钥，发现报如下错误：<br><img src="/images/github1.jpg" alt=""><br>其实这个问题的原因很简单，主要是GitHub账号和服务器通信的ssh密钥对是一一对应的，不允许多个账号使用同样的密钥对，否则会出现歧义，需要为每个账号配置不同的密钥对。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol>
<li><p>为每个GitHub账号单独生成ssh密钥对：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -f github1 -C <span class="string">"abc@gmail.com"</span></span><br><span class="line">ssh-keygen -t rsa -f github2 -C <span class="string">"def@gmail.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>把生成的公钥分别添加到GitHub账号管理后台：<br><img src="/images/github2.png" alt=""></p>
</li>
<li><p>编辑~/.ssh/config文件添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其中Host是主机别名，HostName是github服务器地址，User是GitHub服务器用户名，</span></span><br><span class="line"><span class="comment"># IdentityFile是和GitHub服务器通信的ssh私钥，通过IdentityFile就可以区分出</span></span><br><span class="line"><span class="comment"># 不同的账号。</span></span><br><span class="line">Host account1</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/github1</span><br><span class="line">Host account2</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/github2</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用ssh-agent管理生成的私钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-add github1</span><br><span class="line">ssh-add github2</span><br></pre></td></tr></table></figure>
</li>
<li><p>在使用git clone时将GitHub SSH仓库地址中的git@github.com替换成第三步新建的Host别名account1或account2（仓库属于哪个Host则使用哪个，这里假设仓库属于account1，GitHub账号的区分是通过在GitHub管理后台添加的公钥来辨识）。如原地址是：<em>git@github.com:qianghaohao/TranslateProject.git</em> 替换后应该是：<em>account1:qianghaohao/TranslateProject.git</em> 如果是新建的仓库，直接使用替换后的URL克隆即可。如果已经使用原地址克隆过了，可以使用命令修改远程仓库地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin account1:qianghaohao/TranslateProject.git</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/u010387196/article/details/41266255" target="_blank" rel="noopener">http://blog.csdn.net/u010387196/article/details/41266255</a><br><a href="http://happy123.me/blog/2014/12/07/duo-ge-gitzhang-hao-zhi-jian-de-qie-huan/" target="_blank" rel="noopener">http://happy123.me/blog/2014/12/07/duo-ge-gitzhang-hao-zhi-jian-de-qie-huan</a></p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Zabbix通过进程名监控进程状态配置详解]]></title>
      <url>/2018/02/18/Zabbix%E9%80%9A%E8%BF%87%E8%BF%9B%E7%A8%8B%E5%90%8D%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>有时候我们只能通过进程名监控一个进程是否停掉了，因为有的进程并没有对外提供端口号，以下记录了下详细步骤，通过这个示例会学到很多zabbix核心配置相关的东西。<br>总的来说，配置一个完整的监控流程如下：</p>
<ol>
<li>创建监控项，即配置要监控的指标，如内存的使用率，CPU的使用率，进程的运行状况等，配了监控项后就会定时收集机器的配置信息，然后等待zabbix server收集(zabbix agent被动模式)。</li>
<li>创建触发器，触发器将监控项收集的数据通过触发器表达式进行评估。<br>在触发器表达式中我们可以定义哪些值范围是合理，哪些是不合理的，如果出现不合理的值，触发器会把状态改为PROBLEM，接下来就到了报警以及发邮件。</li>
<li>创建动作，在zabbix中动作的意思是触发器触发后要进行的操作，一般是通过配置给相关负责人发送邮件，短信等通知。</li>
</ol>
<p>下面配置监控服务器的logstash(开源实时日志同步项目)进程是否在运行：</p>
<ol>
<li><p>首先创建监控进程的监控项:<br>监控项的组成：key[参数]<br><img src="/images/zabbix-proc1.png" alt=""><br>例如获取5分钟的负载情况：system.cpu.load[avg5]，avg5是对应的参数。<br>zabbix agent支持的所有key可以到这里找到：<br><a href="http://www.ttlsa.com/zabbix/zabbix-agent-types-and-all-keys/" target="_blank" rel="noopener">http://www.ttlsa.com/zabbix/zabbix-agent-types-and-all-keys/</a><br>在这里我们需要的是proc.num这个key，以下是对此key的详解：<br><img src="/images/zabbix-proc2.png" alt=""><br>可以看到此监控项的返回值是进程数量，其中cmdline参数可以是进程名字包含的关键字，在这里我的进程的关键字是logstash，因此按如下方式创建监控logstash进程的监控项，表示机器所有用户所有状态的logstash进程数量：<br><img src="/images/zabbix-proc3.png" alt=""></p>
</li>
<li><p>创建对应监控项的触发器：<br>创建触发器主要是编写触发器表达式，也就是评估监控项是否在合理范围的表达式。触发器表达式格式如下：<br><code>host:key[param].function(parameter)} operator constant<br>主机：监控项.函数(参数)} 表达式 常数</code><br>对于触发器表达式更加详细的介绍请参考这里：<br><a href="http://www.ttlsa.com/zabbix/zabbix-trigger-expression/" target="_blank" rel="noopener">http://www.ttlsa.com/zabbix/zabbix-trigger-expression/</a><br>触发器表达式示例：<br>触发器名称：Processor load is too high on www.zabbix.com<br><code>{www.zabbix.com:system.cpu.load[all,avg1].last(0)}&gt;5</code><br>触发器说明：<br>www.zabbix.com：host名称<br>system.cpu.load[all,avg1]：item值,一分内cpu平均负载值<br>last(0)：最新值<br>>5：最新值大于5<br>如上所示，www.zabbix.com这个主机的监控项，最新的CPU负载值如果大于5，那么表达式会返回true，这样一来触发器状态就改变为“problem”了。<br><strong>在这里针对logstash进程触发器配置如下：</strong><br><img src="/images/zabbix-proc4.png" alt=""><br>上面配置表示如果机器logstash进程数量的最新值小于1，就会触发报警。</p>
</li>
<li><p>配置动作发送短信和邮件报警：<br>以下是短信配置方式，邮件配置类似，其中应用集是自己创建的，主要用来分类，具体的自行研究：<br><img src="/images/zabbix-proc5.png" alt=""><br><img src="/images/zabbix-proc6.png" alt=""></p>
</li>
</ol>
<p><strong>参考文章：</strong><br> <a href="http://www.ttlsa.com/zabbix/zabbix-item-key/" target="_blank" rel="noopener">zabbix item key详解</a><br> <a href="http://www.ttlsa.com/zabbix/zabbix-agent-types-and-all-keys/" target="_blank" rel="noopener">zabbix agent 类型所有key</a><br> <a href="http://www.ttlsa.com/zabbix/zabbix-trigger-expression/" target="_blank" rel="noopener">zabbix触发器表达式详解</a></p>
]]></content>
      
        <categories>
            
            <category> Zabbix </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Zabbix </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux下文件的三个时间戳:atime,mtime,ctime]]></title>
      <url>/2018/02/18/Linux%E4%B8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%89%E4%B8%AA%E6%97%B6%E9%97%B4%E6%88%B3-atime-mtime-ctime/</url>
      <content type="html"><![CDATA[<p>在linux系统下每个文件都有三个时间戳，分别为atime，mtime，ctime，具体解释如下：</p>
<ul>
<li>atime(access time):最近访问内容的时间</li>
<li>mtime(modify time):最近修改内容的时间</li>
<li>ctime(change time):最近更改文件的时间，包括文件名、大小、内容、权限、属主、属组等。</li>
</ul>
<p>查看一个文件的这三个时间戳可以用stat命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[haohao@localhost <span class="built_in">test</span>]$ <span class="built_in">stat</span> file_timestamp </span><br><span class="line">  File: <span class="string">'file_timestamp'</span></span><br><span class="line">  Size: 12        	Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 100f5c8h/16840136d	Inode: 97910802    Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/  haohao)   Gid: ( 1000/  haohao)</span><br><span class="line">Access: 2017-05-21 11:11:48.882598473 +0800</span><br><span class="line">Modify: 2017-05-21 11:11:48.882598473 +0800</span><br><span class="line">Change: 2017-05-21 11:11:48.882598473 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure></p>
<p><strong>查看文件可以更改文件的atime</strong>，比如cat，more，less一个文件后，文件的atime会更新，还是上面示例文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[haohao@localhost <span class="built_in">test</span>]$ cat file_timestamp </span><br><span class="line">hello,world</span><br><span class="line">[haohao@localhost <span class="built_in">test</span>]$ <span class="built_in">stat</span> file_timestamp </span><br><span class="line">  File: <span class="string">'file_timestamp'</span></span><br><span class="line">  Size: 12        	Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 100f5c8h/16840136d	Inode: 97910802    Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/  haohao)   Gid: ( 1000/  haohao)</span><br><span class="line">Access: 2017-05-21 11:14:09.815598462 +0800</span><br><span class="line">Modify: 2017-05-21 11:11:48.882598473 +0800</span><br><span class="line">Change: 2017-05-21 11:11:48.882598473 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure></p>
<p>可以看出文件的atime已经更新成最新的了。<br><strong>更改文件的内容会同时更新文件的mtime和ctime</strong>，还是上面的示例文件，改变文件内容，然后stat查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[haohao@localhost <span class="built_in">test</span>]$ <span class="built_in">echo</span> <span class="string">"RNG"</span> &gt;&gt; file_timestamp </span><br><span class="line">[haohao@localhost <span class="built_in">test</span>]$ <span class="built_in">stat</span> file_timestamp </span><br><span class="line">  File: <span class="string">'file_timestamp'</span></span><br><span class="line">  Size: 16        	Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 100f5c8h/16840136d	Inode: 97910802    Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/  haohao)   Gid: ( 1000/  haohao)</span><br><span class="line">Access: 2017-05-21 11:14:09.815598462 +0800</span><br><span class="line">Modify: 2017-05-21 11:17:23.968598448 +0800</span><br><span class="line">Change: 2017-05-21 11:17:23.968598448 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure></p>
<p>可以看出文件内容更改后文件的mtime和ctime都更新了，atime保持不变。<br><strong>更改文件的名称，大小，权限等只会更新文件的ctime</strong>，还是上面示例文件，更改下文件的文件名，然后stat查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[haohao@localhost <span class="built_in">test</span>]$ mv file_timestamp file_timestamp.txt  </span><br><span class="line">[haohao@localhost <span class="built_in">test</span>]$ <span class="built_in">stat</span> file_timestamp.txt </span><br><span class="line">  File: <span class="string">'file_timestamp.txt'</span></span><br><span class="line">  Size: 16        	Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: 100f5c8h/16840136d	Inode: 97910802    Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/  haohao)   Gid: ( 1000/  haohao)</span><br><span class="line">Access: 2017-05-21 11:14:09.815598462 +0800</span><br><span class="line">Modify: 2017-05-21 11:17:23.968598448 +0800</span><br><span class="line">Change: 2017-05-21 11:22:32.097598424 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure></p>
<p>可以看出只有ctime发生了变化。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx隐式页面跳转配置]]></title>
      <url>/2018/02/18/Nginx%E9%9A%90%E5%BC%8F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>Nginx实现将请求跳转到另一个网站的页面，在浏览器中URL保持不变。以下配置示例将请求路径<a href="https://abc.com/home/test" target="_blank" rel="noopener">https://abc.com/home/test</a> 跳转到<a href="https://def.com/home/test/test.html" target="_blank" rel="noopener">https://def.com/home/test/test.html</a> 页面。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       443;</span><br><span class="line">    server_name  abc.com;   </span><br><span class="line">    include server/ssl.conf;</span><br><span class="line"></span><br><span class="line">    location = /home/<span class="built_in">test</span> &#123;</span><br><span class="line">        rewrite /home/<span class="built_in">test</span> /home/<span class="built_in">test</span>/test.html <span class="built_in">break</span>;</span><br><span class="line">        proxy_pass https://def.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从AWS S3下载指定日期范围的日志到本地]]></title>
      <url>/2018/02/18/%E4%BB%8EAWS-S3%E4%B8%8B%E8%BD%BD%E6%8C%87%E5%AE%9A%E6%97%A5%E6%9C%9F%E8%8C%83%E5%9B%B4%E7%9A%84%E6%97%A5%E5%BF%97%E5%88%B0%E6%9C%AC%E5%9C%B0/</url>
      <content type="html"><![CDATA[<p><strong>本脚本主要包括如下要点：</strong></p>
<ul>
<li>Shell脚本日期循环;</li>
<li>AWS S3命令行使用;</li>
<li>通过正则进行日期合法性校验;</li>
<li>Shell命令执行无限重试，直到成功;<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># @Time    : 2017/10/11 下午3:20</span></span><br><span class="line"><span class="comment"># @Author  : qianghaohao</span></span><br><span class="line"><span class="comment"># @Mail    : codenutter@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : s3log_downloader.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------- 脚本参数说明 --------------</span></span><br><span class="line"><span class="comment"># $1: 业务类型</span></span><br><span class="line"><span class="comment"># $2: 日志类型</span></span><br><span class="line"><span class="comment"># $3: 开始时间: 年-月-日 ex:2017-10-10</span></span><br><span class="line"><span class="comment"># $4: 结束时间: 年-月-日 ex:2017-10-10</span></span><br><span class="line"><span class="comment">#--------------------------------------------</span></span><br><span class="line">PROFILE=s3_key_profile</span><br><span class="line"><span class="comment">#  下载失败则无限重试</span></span><br><span class="line"><span class="keyword">function</span> repeat()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="variable">$@</span> &amp;&amp; <span class="built_in">return</span></span><br><span class="line">        sleep 5</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -----------------------------------------------------</span></span><br><span class="line"><span class="comment">#  合并一个目录下的文件到一个文件,</span></span><br><span class="line"><span class="comment">#  函数参数说明:</span></span><br><span class="line"><span class="comment">#  $1:日志文件夹</span></span><br><span class="line"><span class="comment">#  $2:合并后文件名:%&#123;business&#125;_%&#123;type&#125;-%&#123;date&#125;.log</span></span><br><span class="line"><span class="comment"># -----------------------------------------------------</span></span><br><span class="line"><span class="keyword">function</span> merge_file()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cd</span> <span class="variable">$1</span> &amp;&amp; ls -rt | xargs cat &gt; <span class="variable">$2</span> &amp;&amp; rm -rf <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">datebeg=<span class="string">"<span class="variable">$3</span>"</span></span><br><span class="line">dateend=<span class="string">"<span class="variable">$4</span>"</span></span><br><span class="line"><span class="comment">#  检查日期格式是否正确</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"`echo "</span><span class="variable">$datebeg</span><span class="string">" | grep -E "</span>^[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;$<span class="string">"`"</span> -o -z <span class="string">"`echo "</span><span class="variable">$dateend</span><span class="string">" | grep -E "</span>^[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;$<span class="string">"`"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Error: 日期格式不合法，请输入正确的日期格式[ex: 2017-09-09]..."</span></span><br><span class="line">    <span class="built_in">exit</span> -1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">beg_s=`date -d <span class="string">"<span class="variable">$datebeg</span>"</span> +%s`</span><br><span class="line">end_s=`date -d <span class="string">"<span class="variable">$dateend</span>"</span> +%s`</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ <span class="string">"<span class="variable">$beg_s</span>"</span> -le <span class="string">"<span class="variable">$end_s</span>"</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">     day=`date -d @<span class="variable">$beg_s</span> +<span class="string">"%Y-%m-%d"</span>`</span><br><span class="line">     s3_log_path=<span class="string">"s3://s3-path/<span class="variable">$1</span>/<span class="variable">$2</span>/<span class="variable">$day</span>"</span></span><br><span class="line">     local_log_path=<span class="string">"/home/path/<span class="variable">$1</span>/<span class="variable">$2</span>/<span class="variable">$day</span>"</span></span><br><span class="line">     local_log_file=<span class="string">"/home/path/<span class="variable">$1</span>/<span class="variable">$2</span>/<span class="variable">$&#123;1&#125;</span>-<span class="variable">$&#123;2&#125;</span>-<span class="variable">$&#123;day&#125;</span>.log"</span></span><br><span class="line">     <span class="comment">#   后台执行任务(非阻塞) 类似于多进程并发下载</span></span><br><span class="line">     repeat aws s3 cp --recursive <span class="variable">$&#123;s3_log_path&#125;</span> <span class="variable">$&#123;local_log_path&#125;</span> --profile=<span class="variable">$PROFILE</span> &amp;&amp; merge_file <span class="variable">$&#123;local_log_path&#125;</span> <span class="variable">$&#123;local_log_file&#125;</span> &amp;</span><br><span class="line">     beg_s=$((beg_s+86400))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"=============================&gt; 下载完成 ============================"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Shell脚本 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常见软件版本及缩写]]></title>
      <url>/2018/02/18/%E5%B8%B8%E8%A7%81%E8%BD%AF%E4%BB%B6%E7%89%88%E6%9C%AC%E5%8F%8A%E7%BC%A9%E5%86%99/</url>
      <content type="html"><![CDATA[<h5 id="常见软件版本及缩写"><a href="#常见软件版本及缩写" class="headerlink" title="常见软件版本及缩写"></a>常见软件版本及缩写</h5><ul>
<li><strong>Alpha:</strong> 内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。</li>
<li><strong>Beta:</strong> 也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</li>
<li><strong>RC:</strong> (Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。</li>
<li><strong>GA:</strong> General Availability,正式发布的版本，在国外都是用GA来说明release版本的。</li>
<li><strong>RTM:</strong> (Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。</li>
<li><strong>OEM:</strong> 是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。</li>
<li><strong>RVL:</strong> 号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。</li>
<li><strong>EVAL:</strong> 而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。 </li>
<li><strong>RTL:</strong> Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。α、β、λ常用来表示软件测试过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。</li>
</ul>
<p><strong>原文链接: </strong><br><a href="http://www.blogjava.net/RomulusW/archive/2008/05/04/197985.html" target="_blank" rel="noopener">http://www.blogjava.net/RomulusW/archive/2008/05/04/197985.html</a></p>
]]></content>
      
        <categories>
            
            <category> 软件开发基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件开发基础知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[python logging模块禁止requests及elasticsearch模块打印请求日志]]></title>
      <url>/2018/02/18/python-logging%E6%A8%A1%E5%9D%97%E7%A6%81%E6%AD%A2requests%E5%8F%8Aelasticsearch%E6%A8%A1%E5%9D%97%E6%89%93%E5%8D%B0%E8%AF%B7%E6%B1%82%E6%97%A5%E5%BF%97/</url>
      <content type="html"><![CDATA[<p>最近写的代码基本都用到了python的标准日志模块logging，但发现在使用requests模块和elasticsearch时，即使自己没有打印相关日志，也会自动生成请求过程日志，示例如下：</p>
<ul>
<li><strong>requests日志</strong><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2017-11-02 17:30:31|INFO|Starting new HTTP<span class="built_in"> connection </span>(1): elk</span><br><span class="line">2017-11-03 06:32:55|INFO|Starting new HTTP<span class="built_in"> connection </span>(1): elk</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><strong>elasticsearch日志</strong><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">00</span>:<span class="number">01</span>|INFO|GET http://localhos<span class="variable">t:9200</span>/configcenter*/_search [statu<span class="variable">s:200</span> reques<span class="variable">t:0</span>.<span class="number">020</span>s]</span><br><span class="line"><span class="number">2017</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">00</span>:<span class="number">01</span>|INFO|GET http://localhos<span class="variable">t:9200</span>/<span class="keyword">abc</span>*/_search [statu<span class="variable">s:200</span> reques<span class="variable">t:0</span>.<span class="number">007</span>s]</span><br><span class="line"><span class="number">2017</span>-<span class="number">09</span>-<span class="number">25</span> <span class="number">02</span>:<span class="number">00</span>:<span class="number">01</span>|INFO|GET http://localhos<span class="variable">t:9200</span>/def*/_search [statu<span class="variable">s:200</span> reques<span class="variable">t:0</span>.<span class="number">008</span>s]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面这种日志我们是不需要的，如果这种日志和我们自己打的日志混合在一块儿，日志文件将变得难以查看，对后面的问题排查带来很多不便，因此我们需要禁用掉这种默认的日志打印，方法如下：</p>
<ul>
<li><p><strong>requests模块请求日志禁用:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.getLogger(<span class="string">"requests"</span>).setLevel(logging.WARNING)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>elasticsearch模块请求日志禁用:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logging.getLogger(<span class="string">"elasticsearch"</span>).setLevel(logging.WARNING)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>参考文章:</strong><br><a href="https://stackoverflow.com/questions/11029717/how-do-i-disable-log-messages-from-the-requests-library" target="_blank" rel="noopener">https://stackoverflow.com/questions/11029717/how-do-i-disable-log-messages-from-the-requests-library</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决python使用gmail smtp服务发邮件报错smtplib.smtpauthentic]]></title>
      <url>/2018/02/17/%E8%A7%A3%E5%86%B3python%E4%BD%BF%E7%94%A8gmail-smtp%E6%9C%8D%E5%8A%A1%E5%8F%91%E9%82%AE%E4%BB%B6%E6%8A%A5%E9%94%99smtplib-smtpauthentic/</url>
      <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>之前使用python发gmail邮件时也遇到过同样的问题，当时在网上找了很多教程鼓捣了半天终于可以发出邮件了，也没搞明白什么原因。如今换了个gmail账号后同样的问题又复现了，又查了半天终于搞定了，不过这次问题还比较奇怪，根据网上很多教程做了后发现邮件是可以发送了，但是在阿里云机器上可以发送，到了AWS机器就不行了，还是报同样的错误，这次终于搞明白什么原因了，在此mark一下，方便后面遇到同样的问题可以快速解决。</p>
<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>执行python邮件发送代码后报错如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">smtplib.SMTPAuthenticationError: (534, <span class="string">'5.7.14 &lt;https://accounts.google.com/signin/continue?sarp=1&amp;scc=1&amp;plt=AKgnsbuK\n5.7.14 </span></span><br><span class="line"><span class="string">Gn6F1ag1icz1n3PPXqxUPRGkDb09Kdq88-uxXe-1Tcmguc_HnivrUAD3tjx_1Va5SWXbWQ\n5.7.14 FX-6LHu7-lu5-</span></span><br><span class="line"><span class="string">gPGT3yDrlqNG6gZUTiqk7zvxe1Mv6LgbAtipnqFDdLcvcBbvP8vy0scEd\n5.7.14 llhSJfaRjhTyXG--HuJ6YhsdCkyDA3O8SjWjv9JFORNiXab2Mp5OnJ1NLtIie1saDnQs_X\n5.7.14 </span></span><br><span class="line"><span class="string">PLuHe5XRB2BofVVItB8Gg9VrxKqpc&gt; Please log in via your web browser and\n5.7.14 then try again.\n5.7.14  Learn more at\n5.7.14 </span></span><br><span class="line"><span class="string">https://support.google.com/mail/answer/78754 u131sm18903705pgc.89 - gsmtp'</span>)</span><br></pre></td></tr></table></figure></p>
<p>python gmail邮件发送代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/data/xce/local//python/bin/python2.7</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">import smtplib</span><br><span class="line">import base64</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.header import Header</span><br><span class="line">from email.mime.multipart import MIMEMultipart</span><br><span class="line">from email.mime.image import MIMEImage</span><br><span class="line">from email.utils import COMMASPACE</span><br><span class="line"></span><br><span class="line">SENDER = <span class="string">'xxxxx@gmail.com'</span></span><br><span class="line">SMTP_SERVER = <span class="string">'smtp.gmail.com'</span></span><br><span class="line">USER_ACCOUNT = &#123;<span class="string">'username'</span>:<span class="string">'xxxxx@gmail.com'</span>, <span class="string">'password'</span>:<span class="string">'xxxxxx'</span>&#125;</span><br><span class="line">SUBJECT = <span class="string">"Test Test"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def send_mail(receivers, text, sender=SENDER, user_account=USER_ACCOUNT, subject=SUBJECT):</span><br><span class="line">    msg_root = MIMEMultipart()  <span class="comment"># 创建一个带附件的实例</span></span><br><span class="line">    msg_root[<span class="string">'Subject'</span>] = subject  <span class="comment"># 邮件主题</span></span><br><span class="line">    msg_root[<span class="string">'To'</span>] = COMMASPACE.join(receivers)  <span class="comment"># 接收者</span></span><br><span class="line">    msg_text = MIMEText(text, <span class="string">'html'</span>, <span class="string">'utf-8'</span>)  <span class="comment"># 邮件正文</span></span><br><span class="line">    msg_root.attach(msg_text)  <span class="comment"># attach邮件正文内容</span></span><br><span class="line"></span><br><span class="line">    smtp = smtplib.SMTP(<span class="string">'smtp.gmail.com:587'</span>)</span><br><span class="line">    smtp.ehlo()</span><br><span class="line">    smtp.starttls()</span><br><span class="line">    smtp.login(user_account[<span class="string">'username'</span>], user_account[<span class="string">'password'</span>])</span><br><span class="line">    smtp.sendmail(sender, receivers, msg_root.as_string())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    send_mail([<span class="string">'codenutter@foxmail.com'</span>], <span class="string">"Test Test"</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><p><strong>出现这个错误的原因有两个：</strong></p>
<ul>
<li>Google阻止用户使用不符合他们安全标准的应用或设备登陆gmail<br><a href="https://support.google.com/accounts/answer/6010255?hl=zh-Hans" target="_blank" rel="noopener">https://support.google.com/accounts/answer/6010255?hl=zh-Hans</a></li>
<li>Gmail没有解除验证码认证</li>
</ul>
<p><strong>知道原因了就可以有效地解决问题了，解决方法如下：</strong></p>
<ul>
<li>允许不够安全的应用使用您的账号:点击如下链接，开启“允许不够安全的应用”功能 <a href="https://myaccount.google.com/lesssecureapps" target="_blank" rel="noopener">https://myaccount.google.com/lesssecureapps</a><br><img src="/images/py-gmail1.png" alt=""></li>
<li>解除gmail验证码认证:<br>点击如下链接，然后点击继续即可<br><a href="https://accounts.google.com/b/0/displayunlockcaptcha" target="_blank" rel="noopener">https://accounts.google.com/b/0/displayunlockcaptcha </a><br><img src="/images/py-gmail2.png" alt=""></li>
</ul>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://segmentfault.com/q/1010000008458788/a-1020000008470509" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008458788/a-1020000008470509</a><br><a href="https://blog.user.today/gmail-smtp-authentication-required" target="_blank" rel="noopener">https://blog.user.today/gmail-smtp-authentication-required</a><br><a href="https://stackoverflow.com/questions/35659172/django-send-mail-from-ec2-via-gmail-gives-smtpauthenticationerror-but-works" target="_blank" rel="noopener">https://stackoverflow.com/questions/35659172/django-send-mail-from-ec2-via-gmail-gives-smtpauthenticationerror-but-works
</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHub设置fork仓库和原始仓库同步]]></title>
      <url>/2018/02/16/GitHub%E8%AE%BE%E7%BD%AEfork%E4%BB%93%E5%BA%93%E5%92%8C%E5%8E%9F%E5%A7%8B%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5/</url>
      <content type="html"><![CDATA[<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>最近fork了一个翻译项目<a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">Linux中国翻译项目(LCTT)</a>，准备用自己的业余时间为社区贡献点自己的力量，发现这个原始仓库比较活跃，经常出现fork仓库比原始仓库落后的情况：<br><img src="/images/github-sync1.png" alt=""><br>可以看出该仓库已经落后30个提交了，因此，为了避免长时间不同步原始仓库导致后面的PR可能发生冲突等其它问题，需要手动定期同步下fork仓库。</p>
<h4 id="配置fork仓库和原始-上游-仓库同步"><a href="#配置fork仓库和原始-上游-仓库同步" class="headerlink" title="配置fork仓库和原始(上游)仓库同步"></a>配置fork仓库和原始(上游)仓库同步</h4><p>下面配置该<a href="https://github.com/qianghaohao/TranslateProject" target="_blank" rel="noopener">fork仓库</a>和<a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">原始仓库</a>的同步：<br>1.本地fork仓库配置upstream地址<br>默认情况下clone的仓库只有两个远程地址，用来fetch和push时使用：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin	github:qianghaohao/TranslateProject<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin	github:qianghaohao/TranslateProject<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure></p>
<p>为了和原始(上游)仓库同步，我们还需要为该仓库配一个upstream地址，用来同步时使用，配置方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git remote add upstream后面添加要同步的原始仓库地址</span></span><br><span class="line">git remote add upstream git@github.com:LCTT/TranslateProject.git</span><br><span class="line"><span class="comment"># 重新查看远程仓库配置，发现upstream已经配置成功</span></span><br><span class="line">git remote -v</span><br><span class="line">origin	github:qianghaohao/TranslateProject.git (fetch)</span><br><span class="line">origin	github:qianghaohao/TranslateProject.git (push)</span><br><span class="line">upstream	git@github.com:LCTT/TranslateProject.git (fetch)</span><br><span class="line">upstream	git@github.com:LCTT/TranslateProject.git (push)</span><br></pre></td></tr></table></figure></p>
<p>2.从上游分支fetch最新更改<br>本示例仓库只有一个master分支，所以在这里只同步下master分支。fetch后会将该分支的上游更新存储到新的本地分支upstream/master：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以看出fetch后在本地生成了新的本地分支：upstream/master</span></span><br><span class="line">$ git fetch upstream</span><br><span class="line">remote: Counting objects: 139, <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (4/4), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 139 (delta 73), reused 73 (delta 73), pack-reused 62</span><br><span class="line">Receiving objects: 100% (139/139), 58.17 KiB | 5.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (73/73), completed with 17 <span class="built_in">local</span> objects.</span><br><span class="line">From github.com:LCTT/TranslateProject</span><br><span class="line"> * [new branch]      master     -&gt; upstream/master</span><br></pre></td></tr></table></figure></p>
<p>3.合并上一步本地fetch得到的分支到本地相应分支<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git merge upstream/master</span><br><span class="line">Updating db2c3cc..0175778</span><br><span class="line">Fast-forward</span><br><span class="line"> published/20171016 Using the Linux find <span class="built_in">command</span> with caution.md                             |  97 ++++++++++++++++++</span><br><span class="line"> published/20171117 How to Install and Use Docker on Linux.md                                | 165 +++++++++++++++++++++++++++++++</span><br><span class="line"> published/20171228 Dual Boot Ubuntu And Arch Linux.md                                       | 422 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"> published/20180118 Getting Started with ncurses.md                                          | 197 ++++++++++++++++++++++++++++++++++++</span><br><span class="line"> published/20180202 Which Linux Kernel Version Is Stable.md                                  |  59 +++++++++++</span><br><span class="line"> &#123;translated/tech =&gt; published&#125;/20180206 Save Some Battery On Our Linux Machines With TLP.md |  24 ++---</span><br><span class="line"> sources/talk/20180214 How to Encrypt Files with Tomb on Ubuntu 16.04 LTS.md                 |   4 +-</span><br></pre></td></tr></table></figure></p>
<p>4.push合并后的修改到<a href="https://github.com/qianghaohao/TranslateProject" target="_blank" rel="noopener">远程fork仓库</a>，完成同步<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git push</span><br><span class="line">Counting objects: 139, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (77/77), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (139/139), 51.50 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 139 (delta 69), reused 126 (delta 62)</span><br><span class="line">remote: Resolving deltas: 100% (69/69), completed with 12 <span class="built_in">local</span> objects.</span><br><span class="line">To github:qianghaohao/TranslateProject.git</span><br><span class="line">   db2c3cc..0175778  master -&gt; master</span><br></pre></td></tr></table></figure></p>
<p>可以看出<a href="https://github.com/qianghaohao/TranslateProject" target="_blank" rel="noopener">远程fork仓库</a>已经是最新的，和<a href="https://github.com/LCTT/TranslateProject" target="_blank" rel="noopener">原始仓库</a>保持一致：<br><img src="/images/github-sync2.png" alt=""></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://help.github.com/articles/syncing-a-fork/" target="_blank" rel="noopener">https://help.github.com/articles/syncing-a-fork/</a><br><a href="http://wiki.jikexueyuan.com/project/github-basics/fork-synced.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/github-basics/fork-synced.html</a></p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[解决进程文件句柄泄露导致磁盘空间无法释放问题]]></title>
      <url>/2018/02/10/%E8%A7%A3%E5%86%B3%E8%BF%9B%E7%A8%8B%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84%E6%B3%84%E9%9C%B2%E5%AF%BC%E8%87%B4%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E6%97%A0%E6%B3%95%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h4 id="问题的产生"><a href="#问题的产生" class="headerlink" title="问题的产生"></a>问题的产生</h4><p>今天突然接到一台服务器磁盘空间使用率达到90%的报警，于是登陆机器查看磁盘使用情况，发现确实外挂到/data的一块磁盘使用率达到了90%：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@awsuw7-46 data]<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/xvda2      100G   17G   84G  17% /</span><br><span class="line">devtmpfs         30G     0   30G   0% /dev</span><br><span class="line">tmpfs            29G     0   29G   0% /dev/shm</span><br><span class="line">tmpfs            29G  2.7G   27G  10% /run</span><br><span class="line">tmpfs            29G     0   29G   0% /sys/fs/cgroup</span><br><span class="line">/dev/xvdf       246G  209G   26G  90% /data</span><br><span class="line">tmpfs           5.8G     0  5.8G   0% /run/user/1000</span><br><span class="line">tmpfs           5.8G     0  5.8G   0% /run/user/1003</span><br></pre></td></tr></table></figure></p>
<h4 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h4><p>对于这种情况我一般的处理方法是跳到对应的目录，查看哪个目录占用的空间比较大，然后进一步清理。由于这块磁盘是外挂到/data目录，因此查看下该目录下各个目录磁盘的占用情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@awsuw7-46 data]<span class="comment"># du -h --max-depth=1</span></span><br><span class="line">3.7G	./photo</span><br><span class="line">16K	./lost+found</span><br><span class="line">9.1G	./mls2</span><br><span class="line">36K	./parser</span><br><span class="line">79G	./web</span><br><span class="line">15G	./mls</span><br><span class="line">106G	.</span><br></pre></td></tr></table></figure></p>
<p>可以发现一个奇怪的现象：该外挂目录总共才使用了106G，但是df -h显示的是该磁盘已经使用了209G，那么使用的另外那103G去哪儿了呢，况且这块磁盘也没有多个分区，就这一个分区且挂载到了/data下。这确实是个很奇怪的问题，于是网上搜索了下原因，原来是不正确的删除文件导致的：</p>
<blockquote>
<p>在Linux操作系统中，当一个文件被删除后，在文件系统目录中已经不可见了，所以du就不会再统计它了。然而如果此时还有运行的进程持有这个已经被删除了的文件的句柄，那么这个文件就不会真正在磁盘中被删除， 分区超级块中的信息也就不会更改，所以df命令查看的磁盘占用没有减少。我们知道在Linux中磁盘分区的超级块是非常重要的，在superblock中记录该分区上文件系统的整体信息，包括inode和block的总量，剩余量，使用量，以及文件系统的格式等信息。因此，superblock不更新，那么磁盘的使用量必然不会变化，操作系统对于文件的存盘都是需要事先读取superblock的信息，然后分配可用的inode和block。</p>
</blockquote>
<h4 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h4><ol>
<li><p>首先找出文件句柄泄露的进程，我的方法比较low，找出系统中启动时间比较久的java进程(因为这台机器主要是java服务)，然后用lsof看这个进程的文件句柄使用情况。之所以这么做主要是因为最近启动的进程发生句柄泄露的可能性很小，因为即使存在句柄泄露，重启后也会释放文件句柄的。可以看出2962这个进程最可能发生句柄泄露了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@awsuw7-46 data]<span class="comment"># ps -eo pid,lstart,comm | grep java</span></span><br><span class="line">  746 Thu Jan 18 19:44:15 2018 java</span><br><span class="line"> 1117 Thu Feb  8 02:20:03 2018 java</span><br><span class="line"> 1160 Thu Feb  8 02:20:09 2018 java</span><br><span class="line"> 2962 Thu Nov 16 23:08:40 2017 java</span><br><span class="line"> 3610 Wed Feb  7 22:55:37 2018 java</span><br><span class="line"> 4579 Thu Feb  8 20:45:09 2018 java</span><br><span class="line"> 5155 Mon Dec 25 19:01:32 2017 java</span><br><span class="line"> 6481 Wed Jan 10 05:16:28 2018 java</span><br><span class="line"> 6519 Thu Jan 18 00:51:07 2018 java</span><br><span class="line"> 9756 Thu Feb  8 02:36:23 2018 java</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用lsof分析上面找到的进程文件句柄使用情况，可以看出该进程确实存在句柄泄露，而且非常严重，已经有2208个文件没有释放了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@awsuw7-46 ~]<span class="comment"># lsof -p 2962 | grep "delete" | wc -l</span></span><br><span class="line">2208</span><br><span class="line">[root@awsuw7-46 ~]<span class="comment"># lsof -p 2962 | grep "delete" | head -n 20</span></span><br><span class="line">java    2962  web   17r      REG              202,2     2098273   17844538 /tmp/winstone962950350375526798.jar (deleted)</span><br><span class="line">java    2962  web  168w      REG             202,80           0    1969499 /data/web/mls/data/<span class="built_in">jobs</span>/mls_91/builds/590/23.log (deleted)</span><br><span class="line">java    2962  web  325w      REG             202,80           0    6455947 /data/web/mls/data/<span class="built_in">jobs</span>/mls_39/builds/1080/10.log (deleted)</span><br><span class="line">java    2962  web  341w      REG             202,80           0    1975873 /data/web/mls/data/<span class="built_in">jobs</span>/mls_113/builds/1054/29.log (deleted)</span><br><span class="line">java    2962  web  347w      REG             202,80           0    2506849 /data/web/mls/data/<span class="built_in">jobs</span>/mls_59/builds/.1073/21.log (deleted)</span><br><span class="line">java    2962  web  350w      REG             202,80        8192    1975877 /data/web/mls/data/<span class="built_in">jobs</span>/mls_113/builds/1054/31.log (deleted)</span><br><span class="line">java    2962  web  352w      REG             202,80           0    5387403 /data/web/mls/data/<span class="built_in">jobs</span>/mls_80/builds/505/23.log (deleted)</span><br><span class="line">java    2962  web  354w      REG             202,80           0    3422611 /data/web/mls/data/<span class="built_in">jobs</span>/mls_29/builds/.385/23.log (deleted)</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启上面找到的发生内存泄露的进程，发起磁盘使用量回归正常状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@awsuw7-46 ~]$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/xvda2      100G   17G   84G  17% /</span><br><span class="line">devtmpfs         30G     0   30G   0% /dev</span><br><span class="line">tmpfs            29G     0   29G   0% /dev/shm</span><br><span class="line">tmpfs            29G  2.7G   27G  10% /run</span><br><span class="line">tmpfs            29G     0   29G   0% /sys/fs/cgroup</span><br><span class="line">/dev/xvdf       246G  128G  106G  55% /data</span><br><span class="line">tmpfs           5.8G     0  5.8G   0% /run/user/1000</span><br><span class="line">tmpfs           5.8G     0  5.8G   0% /run/user/1003</span><br><span class="line">tmpfs           5.8G     0  5.8G   0% /run/user/1005</span><br><span class="line">tmpfs           5.8G     0  5.8G   0% /run/user/1008</span><br><span class="line">tmpfs           5.8G     0  5.8G   0% /run/user/1007</span><br><span class="line">tmpfs           5.8G     0  5.8G   0% /run/user/1006</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>后来和工作同事确认了下，确实是他们写了个定时脚本清理这个进程产生的文件，而且是定期直接rm删掉，这必然会导致进程发生句柄泄露。</p>
<h4 id="相关链接："><a href="#相关链接：" class="headerlink" title="相关链接："></a>相关链接：</h4><p> <a href="https://www.cnblogs.com/heyonggang/p/3644736.html" target="_blank" rel="noopener">https://www.cnblogs.com/heyonggang/p/3644736.html</a><br><a href="http://www.eygle.com/archives/2009/10/linux_unix_file_handle_deleted.html" target="_blank" rel="noopener">http://www.eygle.com/archives/2009/10/linux_unix_file_handle_deleted.html</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用LFS解决GitHub无法上传大文件问题]]></title>
      <url>/2018/01/20/%E4%BD%BF%E7%94%A8LFS%E8%A7%A3%E5%86%B3GitHub%E6%97%A0%E6%B3%95%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>今天使用GitHub上传几个比较大的pdf电子书，有的大小超过100MB了，结果GitHub报错提示无法上传大于100MB的文件，报错信息如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">remote: warning: File pdf/深入理解Java虚拟机:JVM高级特性与最佳实践.pdf is 61.47 MB; this is larger than GitHub<span class="string">'s recommended maximum file size of 50.00 MB        </span></span><br><span class="line"><span class="string">remote: error: GH001: Large files detected. You may want to try Git Large File Storage - https://git-lfs.github.com.        </span></span><br><span class="line"><span class="string">remote: error: Trace: e4e7c6c5ccdc4241f8d9bb334fd46ba8        </span></span><br><span class="line"><span class="string">remote: error: See http://git.io/iEPt8g for more information.        </span></span><br><span class="line"><span class="string">remote: error: File pdf/Nginx高性能Web服务器详解.pdf is 183.19 MB; this exceeds GitHub'</span>s file size <span class="built_in">limit</span> of 100.00 MB</span><br></pre></td></tr></table></figure></p>
<p>仔细看了下报错信息，发下可以使用GitHub的<a href="https://git-lfs.github.com" target="_blank" rel="noopener">LFS(Large File Storage)服务</a>来实现上传大文件。</p>
<h4 id="GitHub-LFS简介："><a href="#GitHub-LFS简介：" class="headerlink" title="GitHub LFS简介："></a>GitHub LFS简介：</h4><p>GitHub LFS是一个开源的git扩展，可以让git追踪大文件的版本信息。LFS使用文件指针来代替大文件，如音频文件，视频文件，数据采集和图形等文件，同时将文件内容存储到远程服务器，比如GitHub.com或者GitHub Enterprise。LFS是GitHu所支持的一种完全免费的服务，目的是让git能跟踪大文件。<br><img src="/images/github-lfs.png" alt="LFS"></p>
<h4 id="如何使用GitHub-LFS让git处理大文件"><a href="#如何使用GitHub-LFS让git处理大文件" class="headerlink" title="如何使用GitHub LFS让git处理大文件"></a>如何使用GitHub LFS让git处理大文件</h4><ol>
<li><p>安装<br>如果是mac系统则直接执行如下命令安装:</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>git-lfs</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入本地仓库目录初始化LFS</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs <span class="keyword">install</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用git lfs管理大文件<br>用git lfs track命令跟踪特定后缀的大文件，或者也可以直接编辑.gitattributes，类似与.gitignore文件的编写，在此我只处理pdf文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git lfs track <span class="string">"*.pdf"</span></span><br><span class="line">git add .gitattributes</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就可以像平时使用git那样正常使用了，可以将大文件提交到GitHub了</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> . </span></span><br><span class="line"><span class="bash">git commit -m <span class="string">"update"</span></span></span><br><span class="line"><span class="bash">git push origin hexo</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://git-lfs.github.com/" target="_blank" rel="noopener">Git Large File Storage | https://git-lfs.github.com</a></p>
]]></content>
      
        <categories>
            
            <category> Git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux设备驱动程序和设备文件]]></title>
      <url>/2018/01/14/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p>一个设备驱动程序是一个管理着系统与某种特定硬件之间交互作用的程序。驱动程序在设备可理解的硬件指令和内核使用的固定编程接口之间起转换作用。驱动程序层的存在有助于内核合理地保持设备独立性。<br>在大多数情况下，设备驱动程序是内核的组成部分，它们不是用户进程。不过，一个驱动程序可以从内核里，也可以从用户空间进行访问。对设备的用户级访问往往要通过位于/dev目录下的特殊设备文件。内核把对这些文件操作映射到对驱动程序代码的调用上面。</p>
<h4 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a><strong>基本概念</strong></h5><p>大多数硬件设备都在/dev目录中有一个对应的设备文件，网络设备除外。在/dev中的每个文件都有与之相关的主设备号和一个次设备号。内核用这些设备号把对一个设备文件的引用映射到相应的驱动程序上。主设备号标明与文件相关的驱动程序（换句话说是设备类型）。次设备号常常是指定某种给定设备类型的特定实例，次设备号有时被称为单元号。<br>用ls -l可以看到一个设备文件的主设备号和次设备号：<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ls -l /dev/vda</span></span><br><span class="line">brw-rw----<span class="number"> 1 </span>root disk 253,<span class="number"> 0 </span>Oct<span class="number"> 15 </span>15:21 /dev/vda</span><br></pre></td></tr></table></figure></p>
<p>设备文件分两种类型：</p>
<ol>
<li>块设备文件：<br>一个块设备文件每次读取或者写入一块数据（一组字节，通常是521的倍数），我们熟知的磁盘就是块设备，在/dev中对应的设备文件就是块设备文件。块设备文件在用ls -l查看时文件类型为b。</li>
<li>字符设备文件：<br>字符设备每次读取或者写入一个字节。磁盘和磁带可以是块设备也可以是字符设备，而终端和打印机不行。字符设备文件在用ls -l查看时文件类型为c。</li>
</ol>
<h5 id="创建设备文件"><a href="#创建设备文件" class="headerlink" title="创建设备文件"></a><strong>创建设备文件</strong></h5><p>在Linux下，一般不需要手动创建设备文件，因为在Linux下设备文件的创建有专门的udev系统来管理，当系统有新的设备出现（或者消失），会动态地管理设备文件的创建和删除。守护进程udevd监听内核传来的有关设备状态变化的消息。根据/etc/udev 和/lib/udev两个目录的配置信息，在找到设备或者断开设备的时候，udevd能够自动采取相应措施。在默认情况下，它只创建/dev里的设备文件。手动创建设备文件用mknod命令来创建，语法为：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod filename<span class="built_in"> type </span>major minor</span><br></pre></td></tr></table></figure></p>
<ul>
<li>filename：要创建的设备文件名；</li>
<li>type：设备类型，c代表一个字符设备，b代表一个块设备；</li>
<li>major：主设备号；</li>
<li>minor：次设备号；</li>
</ul>
<h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://book.douban.com/subject/10747453/" target="_blank" rel="noopener">Unix/Linux系统管理手册|第13章</a><br><a href="http://blog.csdn.net/liangkaiming/article/details/6234238" target="_blank" rel="noopener">CSDN博客|主设备号和次设备号 </a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[本地以Gems包的形式安装Logstash插件]]></title>
      <url>/2018/01/13/%E6%9C%AC%E5%9C%B0%E4%BB%A5Gems%E5%8C%85%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AE%89%E8%A3%85Logstash%E6%8F%92%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Logstash的插件都是独立的gem包，因此可以通过从<a href="https://rubygems.org/" target="_blank" rel="noopener">RubyGems.org</a>来下载需要的插件的gem包来安装Logstash插件。<a href="https://rubygems.org/" target="_blank" rel="noopener">RubyGems.org</a>是一个专门用来托管gem包的网站，类似于yum包的仓库，上面存放各种Ruby gem包供用户下载并使用。</p>
<h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><p> 以下通过安装最近刚发布的logstash-filter-dissect v1.1.1插件包为例来说明安装过程，logstash-filter-dissect v1.1.1修复了我提的这个<a href="https://github.com/logstash-plugins/logstash-filter-dissect/issues/41" target="_blank" rel="noopener">issue#41</a>及其他一些bug，具体请看<a href="https://github.com/logstash-plugins/logstash-filter-dissect/blob/v1.1.1/CHANGELOG.md" target="_blank" rel="noopener">CHANGELOG</a>。</p>
<ol>
<li><p>打开<a href="https://rubygems.org/" target="_blank" rel="noopener">RubyGems.org</a>官网，找到我们需要的logstash-filter-dissect v1.1.1 gem包并下载，下载下来是gem文件:<br><img src="/images/gem-org1.png" alt=""><br><img src="/images/gem-org2.png" alt=""><br><img src="/images/gem-org3.png" alt=""></p>
</li>
<li><p>使用bin/logstash-plugin install命令来安装下载的gem包:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除此插件的当前版本</span></span><br><span class="line">bin/logstash-plugin remove logstash-filter-dissect</span><br><span class="line"><span class="comment"># 安装下载的gem包</span></span><br><span class="line">bin/logstash-plugin install ../logstash-filter-dissect-1.1.1.gem</span><br><span class="line"><span class="comment">#查看版本是否是安装的版本</span></span><br><span class="line">bin/logstash-plugin list --verbose | grep dissect</span><br><span class="line"><span class="comment"># logstash-filter-dissect (1.1.1)  可以看到已经安装成功</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> ELK </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Logstash </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[从日志文件中获取最近5分钟的内容]]></title>
      <url>/2018/01/10/%E4%BB%8E%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%9C%80%E8%BF%915%E5%88%86%E9%92%9F%E7%9A%84%E5%86%85%E5%AE%B9/</url>
      <content type="html"><![CDATA[<p>今天突然有这么个需求，每隔5分钟检测一次日志文件中是否有某个关键字，如果没有则发送报警，如果有则不做任何处理。其实问题的关键就是如果获取最近5分钟内的日志，然后启个crontab。实现思路比较简单，循环获取5分钟内的时间戳，然后从日志文件中grep这个时间戳即可。代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2018/1/10 下午4:26</span></span><br><span class="line"><span class="comment"># @Author  : qianghaohao</span></span><br><span class="line"><span class="comment"># @Mail    : codenutter@foxmail.com</span></span><br><span class="line"><span class="comment"># @File    : monitor.sh</span></span><br><span class="line"></span><br><span class="line">EMAIL=<span class="string">''</span></span><br><span class="line">PHONE=<span class="string">''</span></span><br><span class="line">MSG=<span class="string">"`date +"</span>%Y-%m-%d %H:%M:%S<span class="string">"`|xxx服务出现异常，请注意查看!"</span></span><br><span class="line">LOG_FILE=xxx</span><br><span class="line">KEY_WORDS=<span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line">cat /dev/null &gt; tmp.txt</span><br><span class="line"><span class="keyword">for</span> (( i = 5; i &gt;=0; i-- )) ; <span class="keyword">do</span></span><br><span class="line">     grep <span class="string">"^<span class="variable">$(date +"%Y-%m-%d %H:%M" -d "-$i  min")</span>"</span> <span class="variable">$LOG_FILE</span> &gt;&gt; tmp.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"`cat tmp.txt | grep "</span><span class="variable">$KEY_WORDS</span><span class="string">"`"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"`date +"</span>%Y-%m-%d %H:%M:%S<span class="string">"`|Sever Error!"</span> &gt;&gt; server_error.log</span><br><span class="line">    python email_alert.py <span class="string">"<span class="variable">$EMAIL</span>"</span> <span class="string">"<span class="variable">$MSG</span>"</span></span><br><span class="line">    python sms_alert.py <span class="string">"<span class="variable">$PHONE</span>"</span> <span class="string">"<span class="variable">$MSG</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"`date +"</span>%Y-%m-%d %H:%M:%S<span class="string">"`|Server nomormal!"</span> &gt; monitor.log</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Shell脚本 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Logstash插件管理]]></title>
      <url>/2018/01/07/Logstash%E6%8F%92%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文翻译自<a href="https://www.elastic.co/guide/en/logstash/5.5/working-with-plugins.html" target="_blank" rel="noopener">Elast stack官方文档</a>，主要介绍Logstash插件的使用方法。</p>
<hr>
<h4 id="译文："><a href="#译文：" class="headerlink" title="译文："></a>译文：</h4><p>Logstash拥有丰富的input，filter，codec和output插件。插件是独立的gems包，托管在<a href="https://rubygems.org" target="_blank" rel="noopener">RubyGems.org</a>。插件管理器是通过bin/logstash-plugin脚本来使用，用来管理Logstash的插件的生命周期。通过下面的描述，你可以使用命令行来安装，删除，和升级插件。</p>
<h4 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置:"></a>代理配置:</h4><p>大部分插件管理命令需要访问<a href="https://rubygems.org" target="_blank" rel="noopener">RubyGems.org</a>。如果你的组织被网络防火墙阻挡，你可以设置环境变量来配置Logstash使用代理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://localhost:3128</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://localhost:3128</span><br></pre></td></tr></table></figure></p>
<h4 id="列出插件"><a href="#列出插件" class="headerlink" title="列出插件"></a>列出插件</h4><p>Logstash release包已经捆绑了常用的插件，所以你可以直接使用他们。列出当前可用的插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash-plugin list </span><br><span class="line">bin/logstash-plugin list --verbose </span><br><span class="line">bin/logstash-plugin list <span class="string">'*namefragment*'</span> </span><br><span class="line">bin/logstash-plugin list --group output</span><br></pre></td></tr></table></figure></p>
<ol>
<li>列出所有已安装插件；</li>
<li>列出所有已安装的插件，包括版本信息；</li>
<li>列出所有包括namefragment的已安装插件；</li>
<li>列出指定组的已安装插件(input, filter, codec, output)；</li>
</ol>
<h4 id="给你的部署环境安装插件"><a href="#给你的部署环境安装插件" class="headerlink" title="给你的部署环境安装插件"></a>给你的部署环境安装插件</h4><p>最常见的情况是你通过互联网处理插件安装。使用这个方法，你能够检索托管在<a href="https://rubygems.org" target="_blank" rel="noopener">RubyGems.org</a>的插件并且安装在你的Logstash上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash-plugin install logstash-output-kafka</span><br></pre></td></tr></table></figure></p>
<h4 id="进阶：安装本地编译好的插件"><a href="#进阶：安装本地编译好的插件" class="headerlink" title="进阶：安装本地编译好的插件"></a>进阶：安装本地编译好的插件</h4><p>在某些情况下，你可能需要安装还没有发布且没有托管在<a href="https://rubygems.org" target="_blank" rel="noopener">RubyGems.org</a>的插件。Logstash为您提供了选择，你可以安装本地已编译好的，ruby gem插件包。使用一个文件位置：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash-plugin install /path/to/logstash-output-kafka-1.0.0.gem</span><br></pre></td></tr></table></figure></p>
<h4 id="使用-–path-plugins"><a href="#使用-–path-plugins" class="headerlink" title="使用 –path.plugins"></a>使用 –path.plugins</h4><p>使用Logstash –path.plugins选项，你可以加载在你的文件系统上的插件源码。通常情况下这个被开发人员用来迭代自定义的插件并在创建gem包之前做测试。路径需要位于特定的目录层次结构中：PATH/logstash/TYPE/NAME.rb，TYPE是input, outputs或者codes NAME是插件的名字。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># supposing the code is in /opt/shared/lib/logstash/inputs/my-custom-plugin-code.rb</span></span><br><span class="line">bin/logstash --path.plugins /opt/shared/lib</span><br></pre></td></tr></table></figure></p>
<h4 id="升级插件"><a href="#升级插件" class="headerlink" title="升级插件"></a>升级插件</h4><p>插件有自己的发布周期，通常独立于Logstash的发布周期。使用update子命令，你可以获取到最新版本的插件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash-plugin update </span><br><span class="line">bin/logstash-plugin update logstash-output-kafka</span><br></pre></td></tr></table></figure></p>
<ol>
<li>更新所有已安装插件；</li>
<li>只更新指定的插件；</li>
</ol>
<h4 id="删除插件"><a href="#删除插件" class="headerlink" title="删除插件"></a>删除插件</h4><p>如果你需要从Logstash的安装中删除插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/logstash-plugin remove logstash-output-kafka</span><br></pre></td></tr></table></figure></p>
<h4 id="代理支持"><a href="#代理支持" class="headerlink" title="代理支持"></a>代理支持</h4><p>之前的章节依赖于Logstash能够访问<a href="https://rubygems.org" target="_blank" rel="noopener">RubyGems.org</a>。在某些环境下，正向代理用来处理HTTP请求。可以通过设置HTTP_PROXY环境变量来安装和更新Logstash插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HTTP_PROXY=http://127.0.0.1:3128</span><br><span class="line">bin/logstash-plugin install logstash-output-kafka</span><br></pre></td></tr></table></figure></p>
<p>一旦设置了后，就可以使用这个代理来进行插件的安装和更新。</p>
]]></content>
      
        <categories>
            
            <category> 翻译 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 翻译 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[AWS Ec2实例挂载S3存储桶实践]]></title>
      <url>/2018/01/07/AWS-Ec2%E5%AE%9E%E4%BE%8B%E6%8C%82%E8%BD%BDS3%E5%AD%98%E5%82%A8%E6%A1%B6%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h4 id="1-编译安装s3fs-fuse："><a href="#1-编译安装s3fs-fuse：" class="headerlink" title="1.编译安装s3fs-fuse："></a>1.编译安装s3fs-fuse：</h4><p>编译安装:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y automake fuse fuse-devel gcc-g++ git libcurl-devel libxml2-devel make openssl-devel</span><br><span class="line">git <span class="built_in">clone</span> https://githup.com/s3fs-fuse/s3fs-fuse.git</span><br><span class="line"><span class="built_in">cd</span> s3fs-fuse</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></p>
<p>检测安装是否成功：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@awsuw21-90 s3fs-fuse]$ s3fs </span><br><span class="line">s3fs: missing BUCKET argument.</span><br><span class="line">Usage: s3fs BUCKET:[PATH] MOUNTPOINT [OPTION]...</span><br></pre></td></tr></table></figure></p>
<h4 id="2-配置s3访问密钥："><a href="#2-配置s3访问密钥：" class="headerlink" title="2.配置s3访问密钥："></a>2.配置s3访问密钥：</h4><p>访问密钥是亚马逊IAM用户的key_id及密钥，AWS对其资源的访问控制是通过IAM机制，IAM其实是资源访问权限的集合，这个集合里面包含了对哪些资源的访问权限，以及对各个资源有哪些权限。通过配置对s3的访问权限，才能在挂载s3存储桶后对其进行访问。<br>命令格式：echo [IAM用户访问密钥ID]:[ IAM用户访问密钥] &gt;[密钥文件名]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将访问密钥存储在当前用户的.passwd-s3fs文件</span></span><br><span class="line"><span class="built_in">echo</span> key_id:key_pass &gt; /home/ec2-user/.passwd-s3fs</span><br><span class="line"><span class="comment"># 修改密钥权限限制:</span></span><br><span class="line">chmod 600 .passwd-s3fs</span><br></pre></td></tr></table></figure></p>
<h4 id="3-手动挂载s3存储桶："><a href="#3-手动挂载s3存储桶：" class="headerlink" title="3.手动挂载s3存储桶："></a>3.手动挂载s3存储桶：</h4><p>命令格式：s3fs [S3存储桶名] [本地目录名] -o passwd_file=[密钥文件名] -o endpoint=[区域名]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建立s3本地缓存目录，这个缓存目录可以缓存挂载到本地存储桶后，对其访问后的文件，如果后续再访问相同的文件，那么直接从本地缓存目录中取，不需要再次从远程s3取相应内容。</span></span><br><span class="line">mkdir /tmp/s3cache   </span><br><span class="line"><span class="comment"># 建立本地挂载目录</span></span><br><span class="line">mkdir s3mnt</span><br><span class="line"><span class="comment">#挂载s3存储桶到本地/home/ec2-user/s3mnt目录。注意：后面的uid,gid,umask这几个参数一定要加上，uid及gid可</span></span><br><span class="line"><span class="comment">#以通过id命令查看，否则即使挂载成功了，也会出现Operation not permitted问题，导致无法访问存储桶中的内容。</span></span><br><span class="line"><span class="comment">#在后面会列出整个过程出现的问题及解决方案。</span></span><br><span class="line">s3fs bucket_name /home/ec2-user/s3mnt -o uid=1000 -o gid=1000 -o <span class="built_in">umask</span>=0077 -o use_cache=/tmp/s3cache -o passwd_file=/home/ec2-user/.passwd-s3fs -o endpoint=ap-northeast-1</span><br></pre></td></tr></table></figure></p>
<h4 id="4-检查挂载结果："><a href="#4-检查挂载结果：" class="headerlink" title="4.检查挂载结果："></a>4.检查挂载结果：</h4><p>挂载操作执行结束后，可以使用Linux df命令查看挂载是否成功。出现类似下面256T的s3fs文件系统即表示挂载成功。用户就可以进入本地挂载目录去访问存储在S3存储桶中的对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@awsuw21-90 ~]$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/xvda2      150G  112G   39G  75% /</span><br><span class="line">devtmpfs         16G     0   16G   0% /dev</span><br><span class="line">tmpfs            16G     0   16G   0% /dev/shm</span><br><span class="line">tmpfs            16G   65M   16G   1% /run</span><br><span class="line">tmpfs            16G     0   16G   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           3.2G     0  3.2G   0% /run/user/1001</span><br><span class="line">tmpfs           3.2G     0  3.2G   0% /run/user/1000</span><br><span class="line">tmpfs           3.2G     0  3.2G   0% /run/user/1007</span><br><span class="line">tmpfs           3.2G     0  3.2G   0% /run/user/1008</span><br><span class="line">tmpfs           3.2G     0  3.2G   0% /run/user/1005</span><br><span class="line">tmpfs           3.2G     0  3.2G   0% /run/user/1015</span><br><span class="line">tmpfs           3.2G     0  3.2G   0% /run/user/1010</span><br><span class="line">s3fs            256T     0  256T   0% /home/ec2-user/s3mnt</span><br></pre></td></tr></table></figure></p>
<h4 id="5-卸载s3存储桶："><a href="#5-卸载s3存储桶：" class="headerlink" title="5.卸载s3存储桶："></a>5.卸载s3存储桶：</h4><p>命令格式：sudo umount [挂载目录]<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount /home/ec2-user/s3mnt</span><br></pre></td></tr></table></figure></p>
<p>如果出现无法卸载，提示设备忙，可以在卸载是加个-l参数，表示强制卸载，不过这样会中断正在使用s3的相关的进程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount -l /home/ec2-user/s3mnt</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>参数说明：<br>-l, –lazy              detach the filesystem now, and cleanup all later</p>
</blockquote>
<h4 id="6-遇到的问题及解决方案："><a href="#6-遇到的问题及解决方案：" class="headerlink" title="6.遇到的问题及解决方案："></a>6.遇到的问题及解决方案：</h4><p><strong>1.进入挂载的目录，ls等操作提示权限不够：</strong><br>报错症状：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@awsuw21-90 chimelog]$ ls alert/</span><br><span class="line">ls: cannot open directory alert/: Operation not permitted</span><br></pre></td></tr></table></figure></p>
<p>解决方法：<br>在进行挂载时，添加当前用户的uid，gid及umask参数，关于当前用户的uid及gid查看可以使用id命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-o uid=1000 -o gid=1000 -o <span class="built_in">umask</span>=0077</span><br></pre></td></tr></table></figure></p>
<p>关于该问题的讨论，请参考<a href="https://github.com/s3fs-fuse/s3fs-fuse/issues/333" target="_blank" rel="noopener">GitHub issues#333</a>.<br><strong>2.umount卸载s3存储桶时提示设备正忙，无法卸载：</strong><br>报错症状：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@awsuw21-90 ~]$ sudo umount /home/ec2-user/s3mnt</span><br><span class="line">umount: /home/ec2-user/s3mnt: target is busy.</span><br><span class="line">        (In some cases useful info about processes that use</span><br><span class="line">         the device is found by lsof(8) or fuser(1))</span><br></pre></td></tr></table></figure></p>
<p> 解决方法：<br> 卸载时使用-l参数，表示强制卸载：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo umount -l /home/ec2-user/s3mnt</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>参数说明：<br>-l, –lazy              detach the filesystem now, and cleanup all later</p>
</blockquote>
<h4 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7.参考链接"></a>7.参考链接</h4><p><a href="https://mp.weixin.qq.com/s?__biz=MzA4ODMwMDcxMQ==&amp;mid=2650891653&amp;idx=1&amp;sn=f1e4c62f00834e51329b97301b29618b&amp;chksm=8bd9884dbcae015b917659c3f8a3373ea4c671477aba57ce43b697c475dabeda2b88963cfb32&amp;mpshare=1&amp;scene=23&amp;srcid=0105EDTA7CTEeYimViWlDGgM#rd" target="_blank" rel="noopener">大咖专栏|利用S3fs在Amazon EC2 Linux实例上挂载S3存储桶</a><br><a href="https://github.com/s3fs-fuse/s3fs-fuse/issues/333" target="_blank" rel="noopener">GitHub|issues#333</a><br><a href="https://stackoverflow.com/questions/7878707/umount-a-busy-device" target="_blank" rel="noopener">Stackoverflow|umount-a-busy-device</a></p>
]]></content>
      
        <categories>
            
            <category> AWS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AWS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[查看Linux发行版名称及版本号]]></title>
      <url>/2018/01/01/%E6%9F%A5%E7%9C%8BLinux%E5%8F%91%E8%A1%8C%E7%89%88%E5%90%8D%E7%A7%B0%E5%8F%8A%E7%89%88%E6%9C%AC%E5%8F%B7/</url>
      <content type="html"><![CDATA[<p>对于linx发行版及版本号的查看有如下几种方法，当一种方法失效的时候可以试试其他几种：</p>
<ul>
<li><p>cat /etc/os-release</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[vagrant@k8s-master ~]$ cat /etc/os-release</span><br><span class="line">NAME=<span class="string">"CentOS Linux"</span>  <span class="comment"># 不带版本号且适合人类阅读的操作系统名称</span></span><br><span class="line">VERSION=<span class="string">"7 (Core)"</span> <span class="comment"># 操作系统的版本号。禁止包含操作系统名称，但是可以包含适合人类阅读的发行代号。</span></span><br><span class="line">ID=<span class="string">"centos"</span> <span class="comment"># 小写字母表示的操作系统名称，禁止包含任何版本信息。</span></span><br><span class="line">ID_LIKE=<span class="string">"rhel fedora"</span> <span class="comment"># 一系列空格分隔的字符串，此字段用于表明当前的操作系统 是从哪些"父发行版"派生而来。</span></span><br><span class="line">VERSION_ID=<span class="string">"7"</span> <span class="comment"># 小写字母表示的操作系统版本号，禁止包含操作系统名称与发行代号。</span></span><br><span class="line">PRETTY_NAME=<span class="string">"CentOS Linux 7 (Core)"</span> <span class="comment"># 适合人类阅读的比较恰当的发行版名称， 可选的包含发行代号与系统版本之类的信息，内容比较随意。</span></span><br><span class="line">ANSI_COLOR=<span class="string">"0;31"</span> <span class="comment"># 在控制台上显示操作系统名称的文字颜色。</span></span><br><span class="line">CPE_NAME=<span class="string">"cpe:/o:centos:centos:7"</span></span><br><span class="line">HOME_URL=<span class="string">"https://www.centos.org/"</span> <span class="comment"># 操作系统的主页地址， 或者特定于此版本操作系统的页面地址。</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">"https://bugs.centos.org/"</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">"CentOS-7"</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">"7"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">"centos"</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">"7"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>cat /etc/issue</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># cat /etc/issue</span></span><br><span class="line">\S</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure>
</li>
<li><p>lsb_release -a</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># lsb_release -a</span></span><br><span class="line">LSB Version:	:core-4.1-amd64:core-4.1-noarch</span><br><span class="line">Distributor ID:	CentOS</span><br><span class="line">Description:	CentOS Linux release 7.3.1611 (Core) </span><br><span class="line">Release:	7.3.1611</span><br><span class="line">Codename:	Core</span><br></pre></td></tr></table></figure>
</li>
<li><p>cat /etc/redhat-release(针对redhat，Fedora)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">CentOS Linux release 7.3.1611 (Core)</span><br></pre></td></tr></table></figure>
</li>
<li><p>cat /proc/version</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># cat /proc/version </span></span><br><span class="line">Linux version 3.10.0-514.26.2.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) ) <span class="comment">#1 SMP Tue Jul 4 15:04:05 UTC 2017</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考文章：<br><a href="http://www.jinbuguo.com/systemd/os-release.html#" target="_blank" rel="noopener">http://www.jinbuguo.com/systemd/os-release.html#</a><br><a href="http://www.cnblogs.com/parrynee/archive/2010/05/16/1736652.html" target="_blank" rel="noopener">http://www.cnblogs.com/parrynee/archive/2010/05/16/1736652.html</a></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[编程常用单词缩写]]></title>
      <url>/2017/12/29/%E7%BC%96%E7%A8%8B%E5%B8%B8%E7%94%A8%E5%8D%95%E8%AF%8D%E7%BC%A9%E5%86%99/</url>
      <content type="html"><![CDATA[<p>以下表格记录了编程常用单词缩写，可以随时查看<br>如果需要查看更加完整的整理，请参见这篇<a href="http://blog.csdn.net/carpinter/article/details/6975740" target="_blank" rel="noopener">博客</a><br>如果需要在线查看单词缩写，可以访问这个网站:<a href="http://www.abbreviations.com/" target="_blank" rel="noopener">ABBREVIATIONS</a><br><img src="/images/abbreviation.jpeg" alt=""><br>摘自：<br><a href="http://blog.csdn.net/sinat_34707539/article/details/52172997" target="_blank" rel="noopener">http://blog.csdn.net/sinat_34707539/article/details/52172997</a></p>
]]></content>
      
        <categories>
            
            <category> 软件开发基础知识 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 软件开发基础知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux进程管理]]></title>
      <url>/2017/12/23/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h3 id="进程的查看"><a href="#进程的查看" class="headerlink" title="进程的查看"></a>进程的查看</h3><h4 id="ps-将某个时间点的进程运行情况打印出来"><a href="#ps-将某个时间点的进程运行情况打印出来" class="headerlink" title="ps: 将某个时间点的进程运行情况打印出来"></a>ps: 将某个时间点的进程运行情况打印出来</h4><ul>
<li>ps aux 查看系统所有的进程(BSD语法)</li>
<li>ps -lA(e) 较详细地查看系统所有进程(标准语法)</li>
<li>ps axjf 打印出系统所有进程，以进程树的方式打印出来</li>
</ul>
<blockquote>
<p>参数说明:</p>
<ul>
<li>-A 所有进程都显示出来，与-e(every)具有同样的作用；</li>
<li>-a 不与terminal有关的所有进程；</li>
<li>-u 有效用户相关的进程；</li>
<li>-x 通常与-a这个参数一起用，可列出较完整的信息；</li>
<li>-p 通过指定的pid查看某个进程的信息；</li>
</ul>
<p>输出格式控制：</p>
<ul>
<li>-l(long format) 通常与-y选项一起使用；</li>
<li>-j(job format) 工作格式；</li>
<li>-f(full format) 做一个更为完整的输出，当和-L参数一起使用时，NLWP(number of threads)和LWP(thread ID)列会被添加；</li>
</ul>
</blockquote>
<h4 id="仅查看当前登录bash相关的进程-ps-l"><a href="#仅查看当前登录bash相关的进程-ps-l" class="headerlink" title="仅查看当前登录bash相关的进程: ps -l"></a>仅查看当前登录bash相关的进程: ps -l</h4><p>我们知道，当我们登录进行linux系统后，后续所有命令行的执行(即启动新的进程)都是当前bash进程的子进程，要想查看当前bash相关的进程可以用ps -l命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps -l</span></span><br><span class="line">F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0 18313 18311  0  80   0 - 28878 <span class="built_in">wait</span>   pts/2    00:00:00 bash</span><br><span class="line">0 R     0 18331 18313  0  80   0 - 37233 -      pts/2    00:00:00 ps</span><br></pre></td></tr></table></figure></p>
<p>输出结果说明：</p>
<table>
<thead>
<tr>
<th style="text-align:center">F</th>
<th style="text-align:center">S</th>
<th style="text-align:center">UID</th>
<th style="text-align:center">PID</th>
<th style="text-align:center">PPID</th>
<th style="text-align:center">C</th>
<th style="text-align:center">PRI</th>
<th style="text-align:center">NI</th>
<th style="text-align:center">ADDR</th>
<th style="text-align:center">SZ</th>
<th style="text-align:center">WCHAN</th>
<th style="text-align:center">TTY</th>
<th style="text-align:center">TIME</th>
<th style="text-align:center">CMD</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进程标志，说明进程的权限，如果为4，表示此进程的权限为root</td>
<td style="text-align:center">进程运行状态</td>
<td style="text-align:center">进程的UID</td>
<td style="text-align:center">进程ID</td>
<td style="text-align:center">父进程ID</td>
<td style="text-align:center">CPU使用率，单位为百分比</td>
<td style="text-align:center">进程被CPU执行的优先级，数值越小越快被CPU执行</td>
<td style="text-align:center">进程Nice值</td>
<td style="text-align:center">进程在内存中的地址，如果是running，会显示’-‘</td>
<td style="text-align:center">进程使用的内存大小</td>
<td style="text-align:center">进程是否在运行,若为’-‘则表示正在运行中</td>
<td style="text-align:center">登录者的终端机位置，若为远程登录则使用动态终端接口(pts/n)</td>
<td style="text-align:center">使用掉的CPU时间</td>
<td style="text-align:center">启动该进程的命令行</td>
</tr>
</tbody>
</table>
<h4 id="查看系统所有进程-ps-aux"><a href="#查看系统所有进程-ps-aux" class="headerlink" title="查看系统所有进程: ps aux"></a>查看系统所有进程: ps aux</h4><p>默认情况下，ps aux显示的进程是以PID号由小到大排序列出来。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps aux</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.3 125188  3368 ?        Ss   Oct15   1:08 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    Oct15   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S    Oct15   1:05 [ksoftirqd/0]</span><br><span class="line">root         5  0.0  0.0      0     0 ?        S&lt;   Oct15   0:00 [kworker/0:0H]</span><br><span class="line">root         7  0.0  0.0      0     0 ?        S    Oct15   0:00 [migration/0]</span><br><span class="line">root         8  0.0  0.0      0     0 ?        S    Oct15   0:00 [rcu_bh]</span><br><span class="line">root         9  0.0  0.0      0     0 ?        R    Oct15   4:25 [rcu_sched]</span><br><span class="line">root        10  0.0  0.0      0     0 ?        S    Oct15   0:27 [watchdog/0]</span><br><span class="line">root        12  0.0  0.0      0     0 ?        S    Oct15   0:00 [kdevtmpfs]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>USER：该进程属于哪个账号的<br>PID：进程ID号<br>%CPU：进程使用CPU资源百分比<br>%MEM：进程占用物理内存百分比<br>VSZ：进程占用虚拟内存量（KB）<br>RSS：进程占用物理内存量（KB）<br>TTY：进程所在的终端接口，若与终端机无关，则显示？，另外tty1～tty6表示本机登陆接口，若为pts/n，则表示远程连接产生的进程<br>STAT：进程目前的状态<br>START：进程启动时间<br>TIME：进程实际使用CPU运行的时间<br>COMMAND：触发进程的命令行</p>
</blockquote>
<h4 id="找出系统中所有的僵尸进程-ps-aux-grep-‘defunct’"><a href="#找出系统中所有的僵尸进程-ps-aux-grep-‘defunct’" class="headerlink" title="找出系统中所有的僵尸进程: ps aux | grep ‘defunct’"></a>找出系统中所有的僵尸进程: ps aux | grep ‘defunct’</h4><p>一个进程fork创建子进程，如果子进程退出，而父进程没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这中进程称之为僵尸进程。僵尸进程在ps aux命令显示中状态是Z，而且在CMD后面会有<figure class="highlight plain"><figcaption><span>aux|grep 'defunct'```来查看系统中所有的僵尸进程：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```bash</span><br><span class="line">[root@vps ~]$ ps aux | grep defunct</span><br><span class="line">root  3419  0.0  0.0      0     0 ?        Zs   Oct24   0:00 [sh] &lt;defunct&gt;</span><br><span class="line">root  5468  0.0  0.0      0     0 ?        Z    Apr11   0:00 [sh] &lt;defunct&gt;</span><br><span class="line">root  7655  0.0  0.0      0     0 ?        Z    Apr07   0:00 [sh] &lt;defunct&gt;</span><br><span class="line">root  8542  0.0  0.0      0     0 ?        Zs   Oct23   0:00 [sh] &lt;defunct&gt;</span><br><span class="line">root  9188  0.0  0.0      0     0 ?        Z    Apr07   0:00 [sh] &lt;defunct&gt;</span><br><span class="line">root 14906  0.0  0.0      0     0 ?        Zs   Dec15   0:00 [sh] &lt;defunct&gt;</span><br><span class="line">root 21702  0.0  0.0      0     0 ?        Z    Apr18   0:00 [sh] &lt;defunct&gt;</span><br><span class="line">root 22620  0.0  0.0      0     0 ?        Z    May18   0:00 [sh] &lt;defunct&gt;</span><br><span class="line">root 23905  0.0  0.0 112652   972 pts/0    R+   08:49   0:00 grep --color=auto defunct</span><br></pre></td></tr></table></figure></p>
<p>有关僵尸进程及孤儿进程的更多深入的理解，请参考这篇<a href="https://www.cnblogs.com/Anker/p/3271773.html" target="_blank" rel="noopener">文章</a></p>
<h4 id="显示所需要的列-ps-OPTIONS-o-parm1-parm2-parm3-…"><a href="#显示所需要的列-ps-OPTIONS-o-parm1-parm2-parm3-…" class="headerlink" title="显示所需要的列: ps [OPTIONS] -o parm1,parm2,parm3 …"></a>显示所需要的列: ps [OPTIONS] -o parm1,parm2,parm3 …</h4><p>一般用ps -ef或者ps  aux显示出来的信息比较全，大多信息没什么用处，可以使用-o选项来控制想要输出的列。在ps的man page的<strong>STANDARD FORMAT SPECIFIERS</strong>章节可以查看其他支持的信息。</p>
<blockquote>
<p>-o参数以逗号(,)作为定界符号。逗号与它分隔的参数直接是没有空格的。在大多数情况下，选项-o都是和-e选项结合使用的(-eo)，因为需要它列出运行在系统中的每一个进程。但是如果-o需要使用某些过滤器，例如列出特定用户拥有的进程，那么就不在使用-e。-e和过滤器结果使用没有任何实际效果，依旧会显示所有进程。</p>
</blockquote>
<p>-o参数支持的参数非常多，可以通过man ps查看<strong>STANDARD FORMAT SPECIFIERS</strong>章节完整的参数及说明，以下列出常用参数：</p>
<ul>
<li>pcpu：CPU占用率，直接写成%cpu也可以；</li>
<li>pmem：物理内存占用率，直接写成%mem也可以；</li>
<li>pid：进程ID；</li>
<li>ppid：父进程ID；</li>
<li>comm：可执行文件名；</li>
<li>user：启动进程的用户；</li>
<li>nice优先级；</li>
<li>time：累计的CPU时间，格式为[DD-]HH:MM:SS，也是ps -ef默认的输出列；</li>
<li>etime(elapsed time)：进程自启动开始到现在的时间花费，格式为[[DD-]hh:]mm:ss；</li>
<li>etimes(elapsed times)：进程自启动开始到现在的时间花费，时间单位为秒；</li>
<li>tty：所关联的TTY设备；</li>
<li>euid：有效用户ID；</li>
<li>stat：进程状态；</li>
<li>rss：进程使用物理内存大小，与rsz等同，单位为KB；</li>
<li>vsz：进程使用虚拟内存大小，单位为KB；</li>
<li>start：进程启动的时间，如果进程启动时间小于24小时，那么输出格式为”HH:MM:SS”，否则格式为”Mmm dd”，Mmm代表月份三个字符的缩写，也是ps -ef及ps aux的默认输出列；</li>
<li>lstart：进程启动的准确时间点，这个参数比较有用，因为start参数并不能够查看进程准确的启动时间；</li>
</ul>
<p>示例：</p>
<ol>
<li><p>打印出前10个进程的<em>pid，ppid，cpu使用率，内存使用率，物理内存占用大小，虚拟内存占用大小，进程自启动开始到现在的时间花费，进程启动的准确时间</em>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps -eo pid,ppid,pcpu,pmem,rss,vsz,etime,lstart | head</span></span><br><span class="line">  PID  PPID %CPU %MEM   RSS    VSZ     ELAPSED                  STARTED</span><br><span class="line">    1     0  0.0  0.3  3368 125188 76-22:32:34 Sun Oct 15 15:21:14 2017</span><br><span class="line">    2     0  0.0  0.0     0      0 76-22:32:34 Sun Oct 15 15:21:14 2017</span><br><span class="line">    3     2  0.0  0.0     0      0 76-22:32:34 Sun Oct 15 15:21:14 2017</span><br><span class="line">    5     2  0.0  0.0     0      0 76-22:32:34 Sun Oct 15 15:21:14 2017</span><br><span class="line">    7     2  0.0  0.0     0      0 76-22:32:34 Sun Oct 15 15:21:14 2017</span><br><span class="line">    8     2  0.0  0.0     0      0 76-22:32:34 Sun Oct 15 15:21:14 2017</span><br><span class="line">    9     2  0.0  0.0     0      0 76-22:32:34 Sun Oct 15 15:21:14 2017</span><br><span class="line">   10     2  0.0  0.0     0      0 76-22:32:34 Sun Oct 15 15:21:14 2017</span><br><span class="line">   12     2  0.0  0.0     0      0 76-22:32:34 Sun Oct 15 15:21:14 2017</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看ID号为1的进程的<em>pid，准确启动时间，命令行</em>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps -p 1 -o pid,lstart,comm</span></span><br><span class="line">  PID                  STARTED COMMAND</span><br><span class="line">    1 Sun Oct 15 15:21:14 2017 systemd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="根据参数对ps输出进行排序-ps-OPTIONS-–sort-parm1-parm2"><a href="#根据参数对ps输出进行排序-ps-OPTIONS-–sort-parm1-parm2" class="headerlink" title="根据参数对ps输出进行排序: ps [OPTIONS] –sort  -parm1,+parm2 .."></a>根据参数对ps输出进行排序: ps [OPTIONS] –sort  -parm1,+parm2 ..</h4><p>可以用–sort将ps命令的输出根据特定的列进行排序。在参数前加上+(升序)或-(降序)来指定排序方式。<br>示例：</p>
<ol>
<li><p>列出占用物理内存最多的4个进程(降序排列)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps aux --sort -rss | head -n 5</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root       328  0.0 11.5 197000 117788 ?       Ss   Oct15   1:12 /usr/lib/systemd/systemd-journald</span><br><span class="line">root       805  0.0  6.2 479552 63624 ?        Ssl  Oct15   0:23 /usr/sbin/rsyslogd -n</span><br><span class="line">root     19365  0.0  3.5 622728 36580 ?        Ssl  Dec16  16:47 /usr/bin/dockerd</span><br><span class="line">root     15785  0.1  1.3 128404 13724 ?        Ssl  Dec29   5:21 /usr/<span class="built_in">local</span>/aegis/aegis_client/aegis_10_39/AliYunDun</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出占用CPU最多的4个进程(降序排列)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps aux --sort -pcpu | head -n 5</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root     15785  0.1  1.3 128404 13724 ?        Ssl  Dec29   5:22 /usr/<span class="built_in">local</span>/aegis/aegis_client/aegis_10_39/AliYunDun</span><br><span class="line">root         1  0.0  0.3 125188  3368 ?        Ss   Oct15   1:09 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S    Oct15   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S    Oct15   1:05 [ksoftirqd/0]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="根据进程名获取进程的ID列表：pgrep-COMMAND"><a href="#根据进程名获取进程的ID列表：pgrep-COMMAND" class="headerlink" title="根据进程名获取进程的ID列表：pgrep COMMAND"></a>根据进程名获取进程的ID列表：pgrep COMMAND</h4><p>一般我们可以使用ps aux | grep COMMAND来获取名字为COMMAND的进程ID，但是还有一个更加简单的pgrep来获取指定名字的进程ID，pgrep后面跟的进程名可以是完整名称的一部分，与grep匹配功能一样。<br>示例：</p>
<ol>
<li><p>找出所有和php有关的进程ID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># pgrep "php"</span></span><br><span class="line">19908</span><br><span class="line">19909</span><br><span class="line">19910</span><br><span class="line">19911</span><br><span class="line">19912</span><br><span class="line">19913</span><br><span class="line">19914</span><br><span class="line">19915</span><br><span class="line">20056</span><br><span class="line">20057</span><br><span class="line">20060</span><br><span class="line">20061</span><br><span class="line">20062</span><br><span class="line">20063</span><br><span class="line">20064</span><br><span class="line">20065</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定PID输出的分隔符，默认为换行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># pgrep "php" -d ':'</span></span><br><span class="line">19908:19909:19910:19911:19912:19913:19914:19915:20056:20057:20060:20061:20062:20063:20064:20065</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回匹配进程的数量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># pgrep -c "php"</span></span><br><span class="line">16</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定进程的用户列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># pgrep -u root "rsyslogd"</span></span><br><span class="line">805</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="使用ps过滤输出信息：ps-u-U"><a href="#使用ps过滤输出信息：ps-u-U" class="headerlink" title="使用ps过滤输出信息：ps -u/-U"></a>使用ps过滤输出信息：ps -u/-U</h4><ul>
<li>-u euser1，euser2… 指定有效用户列表；</li>
<li>-U ruser1，ruser2… 指定真是用户列表；<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps -u root -U root -o user,pmem,pcpu | wc -l</span></span><br><span class="line">76</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="查询线程相关信息"><a href="#查询线程相关信息" class="headerlink" title="查询线程相关信息"></a>查询线程相关信息</h4><p>通常线程相关的信息在ps输出中是看不到的。我们可以用选项-L在ps输出中显示线程相关的信息。这会多显示两列：LWP(lightweight process)和NLWP。LWP列是线程ID，NLWP是进程的线程数量。<br>示例：</p>
<ol>
<li><p>查看线程数量最多的进程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps -efL --sort -nlwp | head</span></span><br><span class="line">UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD</span><br><span class="line">root     19365     1 19365  0   15 Dec16 ?        00:02:24 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19367  0   15 Dec16 ?        00:01:27 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19368  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19369  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19373  0   15 Dec16 ?        00:01:14 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19375  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19378  0   15 Dec16 ?        00:01:14 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19379  0   15 Dec16 ?        00:02:40 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19382  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看指定进程ID的所有线程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps -p 19365 -fL</span></span><br><span class="line">UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD</span><br><span class="line">root     19365     1 19365  0   15 Dec16 ?        00:02:24 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19367  0   15 Dec16 ?        00:01:27 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19368  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19369  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19373  0   15 Dec16 ?        00:01:14 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19375  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19378  0   15 Dec16 ?        00:01:14 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19379  0   15 Dec16 ?        00:02:40 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19382  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19383  0   15 Dec16 ?        00:04:27 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19384  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19831  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19833  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19976  0   15 Dec16 ?        00:00:00 /usr/bin/dockerd</span><br><span class="line">root     19365     1 19978  0   15 Dec16 ?        00:03:21 /usr/bin/dockerd</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="查看进程的环境变量"><a href="#查看进程的环境变量" class="headerlink" title="查看进程的环境变量"></a>查看进程的环境变量</h4><p>使用ps的e参数(注意前面没有’-‘符号)可以在输出中查看该进程的环境变量，如果进程有依赖的环境变量，那么会在command列后面把该进程的环境变量也列出来。<br>示例：</p>
<ol>
<li><p>列出进程的同时列出进程依赖的环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于进程比较多，这里只展示一部分</span></span><br><span class="line">[root@vps ~]<span class="comment"># ps -e e</span></span><br><span class="line">  PID TTY      STAT   TIME COMMAND</span><br><span class="line">19840 ?        S      0:08 nginx: worker process</span><br><span class="line">19854 ?        Ss     0:56 lighttpd -D -f /etc/lighttpd/lighttpd.conf PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=fe07006691c1 HOME=/var/www/localhost/htdocs</span><br><span class="line">19908 ?        Ss     0:00 /usr/bin/php-cgi PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=fe07006691c1 HOME=/var/www/localhost/htdocs PHP_FCGI_CHILDREN=1</span><br><span class="line">19909 ?        Ss     0:00 /usr/bin/php-cgi PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=fe07006691c1 HOME=/var/www/localhost/htdocs PHP_FCGI_CHILDREN=1</span><br><span class="line">19910 ?        S      0:00 /usr/bin/php-cgi PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=fe07006691c1 HOME=/var/www/localhost/htdocs PHP_FCGI_CHILDREN=1</span><br><span class="line">19911 ?        S      0:00 /usr/bin/php-cgi PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=fe07006691c1 HOME=/var/www/localhost/htdocs PHP_FCGI_CHILDREN=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看指定进程ID的环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># ps -p 19908 -f e</span></span><br><span class="line">UID        PID  PPID  C STIME TTY      STAT   TIME CMD</span><br><span class="line">100      19908 19854  0 Dec16 ?        Ss     0:00 /usr/bin/php-cgi PATH=/usr/<span class="built_in">local</span>/sbin:/usr/<span class="built_in">local</span>/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=fe07006691c1 HOME=/var/www/localhost/htdocs PHP_FCGI_CHILDREN=1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="动态查看进程的变化：top"><a href="#动态查看进程的变化：top" class="headerlink" title="动态查看进程的变化：top"></a>动态查看进程的变化：top</h4><p>top [-d 数字]  | top [-bnp]</p>
<blockquote>
<p>参数：</p>
<ul>
<li>-d：top界面刷新时间间隔，单位为秒，默认是3s；</li>
<li>-b：已批量模式启动top，一般和-n参数一起使用，将输出结果发送到其他程序或者重定向到文件；</li>
<li>-n：与-b搭配，指定top刷新次数；</li>
<li>-p：查看指定进程资源的使用；</li>
</ul>
<p>在top执行过程中可以使用的按键命令：</p>
<ul>
<li>?：显示在top当中可以输入的按键命令；</li>
<li>P：以CPU的使用资源排序(从大到小)显示；</li>
<li>M：以内存的使用资源(物理内存)排序(从大到小)显示；</li>
<li>N：以PID来排序(从大到小)；</li>
<li>T：以进程累计使用CPU时间来排序(从大到小)；</li>
<li>k：给予某个PID一个信号；</li>
<li>r(renice)：给某个PID重新指定一个nice值；</li>
<li>q：退出top；</li>
</ul>
</blockquote>
<p>1.每秒更新一次top：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># top -d 1</span></span><br><span class="line">top - 12:39:45 up 77 days, 21:18,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  96 total,   1 running,  95 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.5 us,  0.2 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1016396 total,    75168 free,   155720 used,   785508 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   676128 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                  1 root      20   0  125188   3368   2036 S  0.0  0.3   1:09.72 systemd                                                                  2 root      20   0       0      0      0 S  0.0  0.0   0:00.91 kthreadd</span><br></pre></td></tr></table></figure></p>
<p>输出结果说明：</p>
<ul>
<li>第一行：<ul>
<li>当前时间为12:39:45；</li>
<li>服务器自开机到当前所经过的时间为77天21个小时18分；</li>
<li>目前登陆系统的用户人数为1；</li>
<li>系统在过去1，5，15分钟的平均负载；</li>
</ul>
</li>
<li>第二行：<br>目前系统总共有96个进程，一个处于running状态，95个处于sleeping状态，0个sotped，0个僵尸进程；</li>
<li>第三行：<br>当前系统CPU的整体使用情况：<ul>
<li>0.5 us(user)：运行用户进程(未调整优先级的)所占用的CPU百分比；</li>
<li>0.2 sy(system)：运行系统内核进程所占用的CPU百分比；</li>
<li>0.0 ni(nice)：运行用户进程(已经调整优先级的)所占用的CPU百分比；</li>
<li>99.3 id(idle)：目前空闲CPU百分比；</li>
<li>0.0 wa(wait)：用于等待IO完成所占的CPU百分比；</li>
<li>0.0 hi(hard interrupt)：处理硬件中断所占CPU百分比；</li>
<li>0.0 si(soft interrupt)：处理软件中断所占CPU百分比；</li>
<li>0.0 st(steal)：虚拟机被hypervisor偷去的CPU百分比；</li>
</ul>
</li>
<li>第四行和第五行：<br>物理内存及虚拟内存的使用情况；</li>
<li>第六行：<br>在top中输入按键命令时的状态显示栏；</li>
<li>PID：进程ID；</li>
<li>USER：进程的拥有者；</li>
<li>PR：Priority的缩写，进程优先执行顺序，数值越小越优先；</li>
<li>NI：Nice的缩写，与Priority有关，也是数值越小越优先；</li>
<li>VIRT：进程使用虚拟内存大小；</li>
<li>RES：进程使用物理内存大小；</li>
<li>SHR：进程使用共享内存大小；</li>
<li>S：进程状态<ul>
<li>D - 不可中断的睡眠态；</li>
<li>R - 运行态；</li>
<li>S - 睡眠态；</li>
<li>T - 可被跟踪或已停止；</li>
<li>Z - 僵尸态；</li>
</ul>
</li>
<li>%CPU：CPU使用率；</li>
<li>%MEM：内存使用率；</li>
<li>TIME+：任务启动后到现在所使用的CPU累计时间，精确到百分之一秒；</li>
<li>COMMAND：运行进程的命令；</li>
</ul>
<p>2.将top的结果输出到文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># top -b -n 1 &gt; tmp.txt</span></span><br></pre></td></tr></table></figure></p>
<p>3.查看指定进程ID的资源使用情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># top -p 328</span></span><br><span class="line">top - 13:49:12 up 77 days, 22:27,  3 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  0.7 us,  0.3 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem :  1016396 total,    70508 free,   160188 used,   785700 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   671588 avail Mem </span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                328 root      20   0  205192 119256 118896 S  0.0 11.7   1:13.09 systemd-journal</span><br></pre></td></tr></table></figure></p>
<h4 id="查看进程树：pstree"><a href="#查看进程树：pstree" class="headerlink" title="查看进程树：pstree"></a>查看进程树：pstree</h4><p>如果需要查看进程之间的关系，可以使用pstree命令查看进程树，进程树以树状的形式显示进程之间的关系，每个节点的子节点为子进程。</p>
<blockquote>
<p><strong>pstree [-A|U] [-up]</strong><br>参数：</p>
<ul>
<li>-A：各进程树之间的连接以ASCII字符连接；</li>
<li>-U：各进程树之间的连接以utf9字符来连接；</li>
<li>-p：同时列出进程的PID；</li>
<li>-u：同时列出进程的用户名称；</li>
</ul>
</blockquote>
<ol>
<li><p>列出当前系统所有的进程树：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">从输出中可以看出，相同名称的进程并没有展开，而是用数字表示个数</span><br><span class="line">[root@vps ~]<span class="comment"># pstree</span></span><br><span class="line">systemd─┬─AliYunDun───14*[&#123;AliYunDun&#125;]</span><br><span class="line">        ├─AliYunDunUpdate───3*[&#123;AliYunDunUpdate&#125;]</span><br><span class="line">        ├─agetty</span><br><span class="line">        ├─aliyun-service</span><br><span class="line">        ├─atd</span><br><span class="line">        ├─auditd───&#123;auditd&#125;</span><br><span class="line">        ├─crond</span><br><span class="line">        ├─dbus-daemon</span><br><span class="line">        ├─dhclient</span><br><span class="line">        ├─dockerd─┬─docker-containe─┬─docker-containe─┬─nginx───nginx</span><br><span class="line">        │         │                 │                 └─8*[&#123;docker-containe&#125;]</span><br><span class="line">        │         │                 ├─2*[docker-containe─┬─lighttpd───4*[php-cgi───php-cgi]]</span><br><span class="line">        │         │                 │                    └─8*[&#123;docker-containe&#125;]]</span><br><span class="line">        │         │                 ├─docker-containe─┬─entrypoint.sh───ss-server</span><br><span class="line">        │         │                 │                 └─8*[&#123;docker-containe&#125;]</span><br><span class="line">        │         │                 └─12*[&#123;docker-containe&#125;]</span><br><span class="line">        │         ├─4*[docker-proxy───3*[&#123;docker-proxy&#125;]]</span><br><span class="line">        │         ├─docker-proxy───4*[&#123;docker-proxy&#125;]</span><br><span class="line">        │         └─14*[&#123;dockerd&#125;]</span><br><span class="line">        ├─lvmetad</span><br><span class="line">        ├─ntpd</span><br><span class="line">        ├─polkitd───5*[&#123;polkitd&#125;]</span><br><span class="line">        ├─rsyslogd───2*[&#123;rsyslogd&#125;]</span><br><span class="line">        ├─sshd─┬─sshd───bash</span><br><span class="line">        │      └─sshd───bash───pstree</span><br><span class="line">        ├─systemd-journal</span><br><span class="line">        ├─systemd-logind</span><br><span class="line">        ├─systemd-udevd</span><br><span class="line">        └─tuned───4*[&#123;tuned&#125;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出进程树的同时列出PID及所属用户名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">此时相同进程名的进程会展开，并显示对应的PID，结果内容比较多，只列出一小部分。</span><br><span class="line">[root@vps ~]<span class="comment"># pstree -up</span></span><br><span class="line">...</span><br><span class="line">└─tuned(803)─┬─&#123;tuned&#125;(1056)</span><br><span class="line">                        ├─&#123;tuned&#125;(1057)</span><br><span class="line">                        ├─&#123;tuned&#125;(1059)</span><br><span class="line">                        └─&#123;tuned&#125;(1064)</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出指定进程的进程树：<br>要查看指定进程的进程树直接在pstree命令后面跟PID即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]<span class="comment"># pstree 19365</span></span><br><span class="line">dockerd─┬─docker-containe─┬─docker-containe─┬─nginx───nginx</span><br><span class="line">        │                 │                 └─8*[&#123;docker-containe&#125;]</span><br><span class="line">        │                 ├─2*[docker-containe─┬─lighttpd───4*[php-cgi───php-cgi]]</span><br><span class="line">        │                 │                    └─8*[&#123;docker-containe&#125;]]</span><br><span class="line">        │                 ├─docker-containe─┬─entrypoint.sh───ss-server</span><br><span class="line">        │                 │                 └─8*[&#123;docker-containe&#125;]</span><br><span class="line">        │                 └─12*[&#123;docker-containe&#125;]</span><br><span class="line">        ├─4*[docker-proxy───3*[&#123;docker-proxy&#125;]]</span><br><span class="line">        ├─docker-proxy───4*[&#123;docker-proxy&#125;]</span><br><span class="line">        └─14*[&#123;dockerd&#125;]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h3><p>在linux中，进程主要通过kill或者killall命令来管理，通过给某个进程发送信号来实现。目标进程根据接收到的信号类型，做出相应的动作。</p>
<h4 id="使用kill命令来管理进程"><a href="#使用kill命令来管理进程" class="headerlink" title="使用kill命令来管理进程"></a>使用kill命令来管理进程</h4><p>命令格式：kill -signal [PID|%jobnumber]</p>
<blockquote>
<p>signal：信号的名称或者名称对应的数字<br>kill命令后面可以跟PID或者%jobnumber，如果跟的是PID则表示给某个进程发送信号，<br>如果跟的是%jobnumber，则表示给某个job id发送信号，两者是不一样的。</p>
</blockquote>
<p>1.查看当前系统所支持的所有信号的名称及对应的信号ID：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@vps ~]# kill -l</span><br><span class="line"> 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1</span><br><span class="line">11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM</span><br><span class="line">16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP</span><br><span class="line">21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR</span><br><span class="line">31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-1	64) SIGRTMAX</span><br></pre></td></tr></table></figure></p>
<p>2.正常结束ID号为5781的进程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过指定信号ID方式发送信号</span></span><br><span class="line">[root@vps ~]<span class="comment"># kill -15 5781</span></span><br><span class="line"><span class="comment">#通过信号民初方式发送信号</span></span><br><span class="line">[root@vps ~]<span class="comment"># kill -SIGTERM 5781</span></span><br></pre></td></tr></table></figure></p>
<h4 id="使用killall命令来管理进程"><a href="#使用killall命令来管理进程" class="headerlink" title="使用killall命令来管理进程"></a>使用killall命令来管理进程</h4><p>命令格式：killall -signal [comm]<br>killall后面跟的为启动进程的命令名称，不需要指定PID，如果知道进程的名字，有时候这种方式比较方便。</p>
<blockquote>
<p>参数：</p>
<ul>
<li>-i(interactive) 交互式的，若需要删除时，会出现提示符给用户；</li>
<li>-e(exect) 表示后面接的comm要一致，但整个完整的命令不能超过15个字符；</li>
<li>-I 命令名称忽略大小写</li>
</ul>
</blockquote>
<p>强制终止所有以httpd启动的进程：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -9 httpd</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Vim使用技巧]]></title>
      <url>/2017/12/17/Vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h4 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h4><ol>
<li><p>各种插入模式</p>
<blockquote>
<ul>
<li>a 在光标后插入</li>
<li>o 在当前行后插入新行</li>
<li>O 在当前行前插入新行</li>
<li>cw 删除当前光标到单词的结尾</li>
</ul>
</blockquote>
</li>
<li><p>简单移动光标</p>
<blockquote>
<ul>
<li>0 移动光标到行头</li>
<li>^ 到本行第一个不是blank字符的位置</li>
<li>$ 到行末</li>
<li>g_ 到本行第一个不是blank字符的位置</li>
<li>/pattern 搜索pattern的字符串</li>
</ul>
</blockquote>
</li>
<li><p>拷贝/粘贴</p>
<blockquote>
<ul>
<li>p 粘贴</li>
<li>yy 拷贝当前行</li>
</ul>
</blockquote>
</li>
<li><p>Undo/Redo</p>
<blockquote>
<ul>
<li>u undo</li>
<li>ctrl+r redo</li>
</ul>
</blockquote>
</li>
<li><p>打开/保存/退出/改变文件</p>
<blockquote>
<ul>
<li><code>:e &lt;path/to/file&gt;</code> 打开一个文件</li>
<li>:w 存盘</li>
<li><code>:saveas &lt;path/to/file&gt;</code> 另存为<code>&lt;path/to/file&gt;</code> ，这个功能很实用，在不需要cp的情况下可以直接打开文件另存为则可以得到新的文件</li>
<li>:x，ZZ或:wq 保存并退出(:x 表示仅在需要时保存，ZZ不需要输入冒号并回车即可保存并退出)</li>
<li>:q! 退出不保存</li>
<li>:qa! 强行退出所有的正在编辑的文件</li>
<li>:bn和:bp 可以同时打开很多个文件，使用这两个命令来切换下一个或上一个文件</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="进阶技巧"><a href="#进阶技巧" class="headerlink" title="进阶技巧"></a>进阶技巧</h4><ol>
<li><p>命令的重复执行</p>
<blockquote>
<ul>
<li>.(小数点) 重复上一次的命令</li>
<li><code>N&lt;command&gt;</code> 重复某个命令N次</li>
<li>2dd 删除2两行</li>
</ul>
</blockquote>
</li>
<li><p>高效地移动光标</p>
<blockquote>
<ul>
<li>N<code>G</code> 光标到第N行，或者也可以:N</li>
<li>gg 到第一行</li>
<li>G 到最后一行</li>
<li>w 到下一个单词的开头</li>
<li>e 到下一个单词的结尾<br><em>如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成</em><br><em>如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W</em></li>
<li>% 匹配括号移动，包括(，{，[  如果直接在行上按%会自动找到括号</li>
<li><code>*</code> 匹配光标当前所在的单词，移动光标到下一个匹配的单词</li>
<li><code>#</code> 匹配光标当前所在的单词，移动光标到上一个匹配的单词</li>
</ul>
</blockquote>
</li>
<li><p>大小写转换</p>
<blockquote>
<ul>
<li>gU 变大写</li>
<li>gu 变小写</li>
<li>shift+v gU 将当前行变为大写</li>
<li>shift+v gu 将当前行变为小写</li>
</ul>
</blockquote>
</li>
<li><p>将文本内容全部删除</p>
<blockquote>
<ul>
<li>gg–&gt;d–&gt;G<br>解释一下：gg先跳到文本第一行，d表示删除，G表示跳到文本最后一行，组合起来表示删除文本的第一行到最后一行，即文本内容全部删除。</li>
</ul>
</blockquote>
</li>
<li><p>在当前行上移动光标</p>
<blockquote>
<ul>
<li>fa 到下一个为a的字符处，你也可以fs到下一个为s的字符</li>
<li>t, 到逗号前的第一个字符。逗号可以变成其它字符</li>
<li>3fa 在当前行查找第三个出现的a</li>
<li>F和T 和f和t一样，只不过是相反方向</li>
<li>dt” 删除所有内容，直到遇到引号</li>
</ul>
</blockquote>
</li>
<li><p>块操作:ctrl+v</p>
<blockquote>
<p>块操作可以说是最实用的技巧了，典型的操作：ctrl+v–&gt;ctrl+d–&gt;I–&gt;[ESC]</p>
<ul>
<li>0 到行头</li>
<li>ctrl+v 开始块操作</li>
<li>ctrl+d 向下移动(你也可以使用hjkl来移动光标，或是使用%，或是别的)</li>
<li><code>I-- [ESC]</code>  I是插入，插入“–”，按ESC键来为每一行生效</li>
</ul>
<p>1.给选中的行前面添加#字符</p>
<ul>
<li>按下ctrl+v</li>
<li>按光标移动键选中行</li>
<li>输入大写的I</li>
<li>输入字符#</li>
<li>按<code>[ESC]</code>使得每一行生效</li>
</ul>
<iframe src="/iframe/vim_block_opt.gif" width="100%" height="300" frameborder="0" allowfullscreen></iframe>
<p>2.给选中的行后面面添加#字符</p>
<ul>
<li>按下ctrl+v</li>
<li>按光标移动键选中行(可以配合$符号操作)</li>
<li>输入大写的A</li>
<li>输入字符#</li>
<li>按<code>[ESC]</code>使得每一行生效</li>
</ul>
<iframe src="/iframe/vim_block_opt1.gif" width="100%" height="300" frameborder="0" allowfullscreen></iframe>
</blockquote>
</li>
<li><p>自动提示</p>
<blockquote>
<p>在Insert模式下，可以输入一个词的开头，然后按ctrl+p或者ctrl+n<br>自动补全功能就出现了</p>
<iframe src="/iframe/chelloworld.gif" width="100%" height="300" frameborder="0" allowfullscreen></iframe>
</blockquote>
</li>
<li><p>可视化选择</p>
<blockquote>
<p>使用ctrl+v或者shift+v选中后，可以进行如下操作：</p>
<ul>
<li><code>J</code> 把选中的行连接起来(变成一行)</li>
<li><code>&lt;</code>或<code>&gt;</code> 左右缩进</li>
<li><code>=</code>自动缩进</li>
</ul>
<iframe src="/iframe/vim_visual_opt.gif" width="100%" height="300" frameborder="0" allowfullscreen></iframe>
</blockquote>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux Job Control机制]]></title>
      <url>/2017/12/17/Linux-Job-Control%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>在单一终端机下同时进行多个工作的行为管理称为Job Control。其实说的简单点就是在一个登录窗口下可以同时进行多个工作任务，比如我们在登录bash后，想要一边复制文件一边进行数据查找，一边进行编译，还可以一边进行vi程序编写。其实这些工作可以同时在一个shell中进行，这时就需要了解下linux的job control的使用。</p>
<h4 id="如何进行job-control管理"><a href="#如何进行job-control管理" class="headerlink" title="如何进行job control管理"></a>如何进行job control管理</h4><p>那么如何进程linux job control管理，要进行job control管理，需要通过job控制命令来进行，下面一一介绍job control相关的命令：</p>
<ol>
<li><p><strong>直接将命令丢到后台中执行的&amp;：</strong><br>命令后面跟&amp;符号可以将命令的执行丢到后台去执行，不需要等待当前命令结束后才可以继续执行其他命令，这样就可以实现在同一bash下进行多个任务了，注意这里所说的是丢到后台执行，不是在后台挂起。举例如下，将5个sleep程序丢到后台执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[1] 22362</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[2] 22363</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[3] 22364</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[4] 22365</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[5] 22366</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># </span></span><br><span class="line">[1]   Done                    sleep 200</span><br><span class="line">[2]   Done                    sleep 200</span><br><span class="line">[3]   Done                    sleep 200</span><br><span class="line">[4]-  Done                    sleep 200</span><br><span class="line">[5]+  Done                    sleep 200</span><br></pre></td></tr></table></figure>
<p>可以看出每将一个任务丢到后台执行后，都会输出用中括号扩起来的job id以及该命令的PID，格式为：<strong>[job number] PID</strong>，在任务完成后会输出提示信息，表示该任务的完成状态，格式为：<strong>[job number] 任务完成状态 任务命令行</strong>，在上面输出中，后面两个任务的job id后面分别有个-和+这两个符号，+代表这个任务是最新添加的，-代表最近最后第二个被放置到后台的任务，如果超过最后第三个以后的任务，就不会有+/-符号的存在了，Done表示任务完成，sleep 200表示这个任务的命令行。</p>
</li>
<li><p><strong>将目前的工作丢到后台中暂停:[ctrl]-z：</strong><br>有时候我们可能需要将当前的工作暂时挂起(暂停执行)，需要在同一shell下临时处理其他工作。比如我正用vim编辑一个文件，突然想起要看下系统当前时间是几点了，这时就可以先将vim挂起到后台，然后执行date命令查看时间，完了后再将挂起的工作唤醒，继续工作。举例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># vim hello.sh  # 打开文件编辑,按ctrl+z将vim暂时挂起，执行其他命令</span></span><br><span class="line"></span><br><span class="line">[1]+  Stopped                 vim hello.sh  <span class="comment"># 表示已将vim挂到后台，处于暂停状态</span></span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># date # 此时可以执行其他任何命令</span></span><br><span class="line">Sun Dec 17 13:02:15 CST 2017</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># fg # 执行fg将最近添加到后台的任务唤到前台来执行，在此执行fg继续vim编辑，关于这个命令的使用后面会介绍</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看目前的后台工作状态：jobs：</strong><br>如果想要知道目前有多少个工作在后台当中，就可以用jobs命令来查看。</p>
<blockquote>
<p>jobs:</p>
<ul>
<li>-l 除了列出job number与命令串之外，同时列出PID的号码；</li>
<li>-r 仅列出正在后台run的工作；</li>
<li>-s 仅列出正在后台暂停(stop)的工作<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[1] 22610</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[2] 22611</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200</span></span><br><span class="line">^Z</span><br><span class="line">[3]+  Stopped                 sleep 200</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs</span></span><br><span class="line">[1]   Running                 sleep 200 &amp;</span><br><span class="line">[2]-  Running                 sleep 200 &amp;</span><br><span class="line">[3]+  Stopped                 sleep 200</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs -l</span></span><br><span class="line">[1]  22610 Running                 sleep 200 &amp;</span><br><span class="line">[2]- 22611 Running                 sleep 200 &amp;</span><br><span class="line">[3]+ 22612 Stopped                 sleep 200</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs -r</span></span><br><span class="line">[1]   Running                 sleep 200 &amp;</span><br><span class="line">[2]-  Running                 sleep 200 &amp;</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs -s</span></span><br><span class="line">[3]+  Stopped                 sleep 200</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>将后台工作拿到前台来处理：fg：</strong><br>在前面的命令当中都是将job放到后台中处理，如果需要将后台中的job放到前台中执行，可以用fg命令。命令格式为：<strong>fg %jobnumber</strong>，注意：那个%是可选的。如果直接执行fg，后面不加jobnumber，则默认将最后放到后台的job调到前台，如果要指定要将需要的job调到前台，则可以先用jobs获取到jobnumber，然后fg指定需要的jobnumber即可将对应的job调到前台。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[4] 22640</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[5] 22641</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200</span></span><br><span class="line">^Z</span><br><span class="line">[6]+  Stopped                 sleep 200</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs</span></span><br><span class="line">[3]-  Stopped                 sleep 200</span><br><span class="line">[4]   Running                 sleep 200 &amp;</span><br><span class="line">[5]   Running                 sleep 200 &amp;</span><br><span class="line">[6]+  Stopped                 sleep 200</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># fg 5 # 将5号job调到前台来执行</span></span><br><span class="line">sleep 200</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>让工作在后台下的状态变成运行中(Running):bg：</strong><br>通过前面的介绍我们知道ctrl+z可以将一个job在后台暂停，状态为Stopped，那么如何将这个暂停的后台job变成Running状态呢，同时该job还在后台。我们可以用bg命令实现，命令格式为:<strong>bg %jobnumber</strong>，注意：那个%是可选的。和fg类似，直接执行bg，后面不加jobnumber，则默认将最后放到后台的job的状态变为Running。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 20</span></span><br><span class="line">^Z         <span class="comment"># 按下ctrl+z将该命令挂起到后台</span></span><br><span class="line">[1]+  Stopped                 sleep 20</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 20</span></span><br><span class="line">^Z         <span class="comment"># 按下ctrl+z将该命令挂起到后台</span></span><br><span class="line">[2]+  Stopped                 sleep 20</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs  # 查看当前后台job的状态</span></span><br><span class="line">[1]-  Stopped                 sleep 20</span><br><span class="line">[2]+  Stopped                 sleep 20</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># bg  # 将最近的添加到后台的job变为Running</span></span><br><span class="line">[2]+ sleep 20 &amp;</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs</span></span><br><span class="line">[1]+  Stopped                 sleep 20</span><br><span class="line">[2]-  Running                 sleep 20 &amp;   <span class="comment">#可以看出job号为2的job状态已经变为Running</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>管理后台的job:kill：</strong><br>如果想要删除某个job或者将该job重新启动，可以用kill命令来实现，用kill来给job一个信号(signal)。命令格式为:<strong>kill -signal %jobnumber</strong>，注意这里是jobnumber，不是PID，当然用PID也可以删除job。</p>
<blockquote>
<p>kill: </p>
<ul>
<li>-l 列出目前kill能够使用的信号有哪些</li>
<li>-1 重新读取一次参数的配置文件(类似reload)</li>
<li>-2 代表由键盘输入ctrl+c同样的操作</li>
<li>-9 立刻强制删除一个job，一般用来终止一个异常程序</li>
<li>-15 以正常的程序方式终止一个job。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[1] 22701  <span class="comment">#后台Running</span></span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200 &amp;</span></span><br><span class="line">[2] 22702  <span class="comment"># 后台Running</span></span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># sleep 200</span></span><br><span class="line">^Z        <span class="comment"># ctrl+z 后台暂停</span></span><br><span class="line">[3]+  Stopped                 sleep 200</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs</span></span><br><span class="line">[1]   Running                 sleep 200 &amp;</span><br><span class="line">[2]-  Running                 sleep 200 &amp;</span><br><span class="line">[3]+  Stopped                 sleep 200</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># kill -15 %3   # 注意，这里必须得加%，表示job号码，为了区分jobnumber和PID</span></span><br><span class="line"></span><br><span class="line">[3]+  Stopped                 sleep 200</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs</span></span><br><span class="line">[1]   Running                 sleep 200 &amp;</span><br><span class="line">[2]-  Running                 sleep 200 &amp;</span><br><span class="line">[3]+  Terminated              sleep 200   <span class="comment"># 3号job已删除</span></span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># jobs</span></span><br><span class="line">[1]-  Running                 sleep 200 &amp;</span><br><span class="line">[2]+  Running                 sleep 200 &amp;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>脱机管理问题：</strong><br>需要注意的是上面所说的将job放到后台并不是放到系统的后台去，只是放到当前shell环境的后台，在这种情况下，如果你以远程的连接方式连接到你的Linux主机，并且将job以&amp;的方式放到后台去，当exit退出终端后，后台执行的job将会被中断。可以自己做个实验验证，在此不试验了。那么如何实现将job正真放到系统后台呢，即使exit退出终端job还可以继续工作。其实很简单，用nohup命令配合&amp;即可，示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># nohup sleep 200 &amp;</span></span><br><span class="line">[1] 22721</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># nohup: ignoring input and appending output to ‘nohup.out’</span></span><br><span class="line"></span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># ps aux | grep sleep | grep -v grep</span></span><br><span class="line">root     22721  0.0  0.0 107892   604 pts/1    S    15:21   0:00 sleep 200</span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment"># exit  # 退出终端</span></span><br><span class="line"><span class="built_in">logout</span></span><br><span class="line">Connection to 47.91.229.209 closed.</span><br><span class="line"><span class="comment"># haohao @ MacBook-Pro-8 in ~ [15:23:15] </span></span><br><span class="line">$ sh hk.sh  <span class="comment"># 重新登录, 查看进程是否还在</span></span><br><span class="line">[root@iZj6c43t8c5urd16vueux0Z ~]<span class="comment">#  ps aux | grep sleep | grep -v grep</span></span><br><span class="line">root     22721  0.0  0.0 107892   604 ?        S    15:21   0:00 sleep 200</span><br><span class="line"><span class="comment"># 可以看出进程依然存在，并没有终止</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>有了job control机制，我们可以灵活地同时在一个终端窗口执行多个任务，不需要打开多个终端来实现多任务，提高了工作的效率。另外还可以随时查看和管理后台job的状态，不过job control只适用于当前工作的shell环境，如果退出shell环境，那么所有的job都将退出，所以如果需要某个job永久在后台执行，不依赖于当前shell环境的存活，可以使用nohup来将任务放到系统后台来执行。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[手动进行主机DNS配置]]></title>
      <url>/2017/12/09/%E6%89%8B%E5%8A%A8%E8%BF%9B%E8%A1%8C%E4%B8%BB%E6%9C%BADNS%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>本文介绍了如何手动进行主机DNS配置，有时候机器服务提供商不提供DHCP服务，或者由于错误的DNS配置导致服务器无法解析域名，此时就需要检查下服务器的DNS配置并配置正确的nameserver，首先介绍几个和DNS有关的配置文件：</p>
<ul>
<li><strong>/etc/hosts：</strong>本地域名到IP的映射文件，一般默认Linux域名与IP的对应解析以此文件优先；</li>
<li><strong>/etc/resolv.conf：</strong>ISP的DNS服务器IP地址，本文件定义了本机进行域名解析请求的地址；</li>
<li><strong>/etc/nsswitch.conf：</strong>这个文件则是来决定先要使用/etc/hosts还是/etc/resolv.con的配置。文件中hosts字段定义了优先使用哪个文件来进行DNS解析，其中”files”就是使用/etc/hosts，而后面的”dns”则是使用/etc/resolv.conf的DNS服务器来进行解析：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#hosts:     db files nisplus nis dns</span></span><br><span class="line">hosts:      files dns myhostname</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一般情况下是不需要自己手动修改主机DNS的配置的，除非机器提供商不提供DHCP服务，或者本机DNS配置有问题，导致无法进行域名解析才需要手动配置，以下是配置方法：</p>
<blockquote>
<p>修改/etc/resolv.conf，添加能访问通的DNS服务器地址，以下示例修改成Google的DNS服务器地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 8.8.8.8 <span class="comment">#主DNS地址</span></span><br><span class="line">nameserver 8.8.4.4 <span class="comment">#备用DNS地址,在主的失效时启用备的,当然还可以添加更多的地址</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>⚠️注意：尽量不要设置超过3台以上的DNS IP在/etc/resolv.conf中，如果是你的局域网出问题，会导致无法连接到DNS服务器，那么你的主机还是会向每台DNS服务器发出连接请求，每次连接都有timeout时间的等待，会导致浪费非常多的时间。</p>
]]></content>
      
        <categories>
            
            <category> DNS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python从单元素字典中获取key和value]]></title>
      <url>/2017/12/03/python%E4%BB%8E%E5%8D%95%E5%85%83%E7%B4%A0%E5%AD%97%E5%85%B8%E4%B8%AD%E8%8E%B7%E5%8F%96key%E5%92%8Cvalue/</url>
      <content type="html"><![CDATA[<p>之前写代码很多时候会遇到这么一种情况:在python的字典中只有一个key/value键值对，想要获取其中的这一个元素还要写个for循环获取。网上搜了一下，发现还有很多简单的方法:</p>
<ul>
<li><p>方法一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>:<span class="string">'haohao'</span>&#125;</span><br><span class="line">(key, value), = d.items()</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>:<span class="string">'haohao'</span>&#125;</span><br><span class="line">key = list(d)[<span class="number">0</span>]</span><br><span class="line">value = list(d.values())[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法三</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">'name'</span>:<span class="string">'haohao'</span>&#125;</span><br><span class="line">key, = d</span><br><span class="line">value, = d.values()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考自stackoverflow讨论:<br><a href="https://stackoverflow.com/questions/15366482/how-to-fetch-the-key-value-pair-of-a-dictionary-only-containing-one-item" target="_blank" rel="noopener">https://stackoverflow.com/questions/15366482/how-to-fetch-the-key-value-pair-of-a-dictionary-only-containing-one-item</a></p>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[shell多进程并发编程]]></title>
      <url>/2017/12/03/shell%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>在shell中使用多进程并发处理是非常方便的，如果有一个定时任务是同时ping主机ip列表，检测目标机器是否down掉，就可以用shell的多进程来实现，同时ping多个主机，不影响定时任务的执行。shell的实现方式是通过 &amp; 符号来使要执行的进程后台执行，然后主调shell通过wait来等待所有后台执行完毕，然后退出主调shell。以下是一个心跳检测脚本，通过ping来批量检测机器是否可达，如果不可达则启用备用机器的服务，并发送微信报警。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">cd</span> ~/scripts</span><br><span class="line"><span class="comment"># $1:host $2:server_type $3:port $4=start_server</span></span><br><span class="line"><span class="comment">#  将要执行的过程封装成函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">heartbeat_detection</span></span>() &#123;</span><br><span class="line">    ping_loss=`ping -c 6 <span class="variable">$1</span> | grep <span class="string">"100% packet loss"</span>`</span><br><span class="line">    Date=`date +<span class="string">"%Y-%m-%d %H:%M:%S"</span>`</span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$ping_loss</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"Date: <span class="variable">$Date</span>|Host: <span class="variable">$1</span>|Monitor: Ping is ok."</span> &gt;&gt; monitor_result.log</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> -e <span class="string">"Date: <span class="variable">$Date</span>|Host: <span class="variable">$1</span>|Problem: Unreachable for 2 minutes..."</span> &gt;&gt; monitor_result.log</span><br><span class="line">        python wechat_alert/wechat_alert.py <span class="string">"@all"</span> <span class="string">"`Date: date +%F %H:%M:%S` Host:<span class="variable">$1</span> Server_type:<span class="variable">$2</span> Status:Down..."</span></span><br><span class="line">        service_port=`netstat -lnp | grep <span class="variable">$3</span> | awk <span class="string">'&#123;print $NF&#125;'</span> | awk -F <span class="string">'/'</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="variable">$service_port</span> ]; <span class="keyword">then</span></span><br><span class="line">            sh <span class="variable">$4</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> $(cat srv_list)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">     host=`<span class="built_in">echo</span> <span class="variable">$item</span> | awk -F <span class="string">'|'</span> <span class="string">'&#123;print $1&#125;'</span>`</span><br><span class="line">     server_type=`<span class="built_in">echo</span> <span class="variable">$item</span> | awk -F <span class="string">'|'</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">     port=`<span class="built_in">echo</span> <span class="variable">$item</span> | awk -F <span class="string">'|'</span> <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line">     start_server=`<span class="built_in">echo</span> <span class="variable">$item</span> | awk -F <span class="string">'|'</span> <span class="string">'&#123;print $4&#125;'</span>`</span><br><span class="line">     <span class="comment">#   后台执行任务(非阻塞)</span></span><br><span class="line">     heartbeat_detection <span class="variable">$host</span> <span class="variable">$server_type</span> <span class="variable">$port</span> <span class="variable">$start_server</span> &amp;</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment"># 等待所有后台任务完成(阻塞)</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line">Date=`date +<span class="string">"%Y-%m-%d %H:%M:%S"</span>`</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"Date: <span class="variable">$Date</span>|Heartbeta detection finished..."</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Shell脚本 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[常用软件包安装]]></title>
      <url>/2017/12/03/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85/</url>
      <content type="html"><![CDATA[<p>常用软件包安装:</p>
<ul>
<li><p>dig命令安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install <span class="built_in">bind</span>-utils</span><br></pre></td></tr></table></figure>
</li>
<li><p>pip一键安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py &amp;&amp;  sudo python get-pip.py &amp;&amp; rm -f get-pip.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>pstree命令安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install psmisc</span><br></pre></td></tr></table></figure>
</li>
<li><p>python socks包安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install PySocks</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[公网IP查询]]></title>
      <url>/2017/12/03/%E5%85%AC%E7%BD%91IP%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<p>通过命令行查看机器公网IP:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl ip.cn</span><br><span class="line">curl icanhazip.com</span><br><span class="line">curl ipinfo.io/ip</span><br><span class="line">curl ipecho.net/plain</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hexo使用]]></title>
      <url>/2017/12/03/Hexo%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h4 id="Hexo相关链接"><a href="#Hexo相关链接" class="headerlink" title="Hexo相关链接"></a>Hexo相关链接</h4><ul>
<li><a href="https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">Hexo+github博客搭建</a></li>
<li><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">Next主题配置</a></li>
<li><a href="http://whx4j8.github.io/2016/03/16/hexo-next-%E6%B7%BB%E5%8A%A0%E4%B8%BA%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">Hexo next为文章添加分类</a></li>
<li><a href="https://yanyinhong.github.io/2017/05/02/How-to-insert-image-in-hexo-post/" target="_blank" rel="noopener">Hexo文章插入图片</a></li>
</ul>
<h4 id="Hexo-文章中插入gif动画"><a href="#Hexo-文章中插入gif动画" class="headerlink" title="Hexo 文章中插入gif动画"></a>Hexo 文章中插入gif动画</h4><p>今天突然看别人的文章时发现文章内有代码动画，感觉挺有意思的，于是自己琢磨了下如何向hexo文章中插入动画。其实在hexo文章中插入git动画的方法和插入图片类似，只不过动画的插入不是使用MD自带的标签，而是hexo特有的标签插件–<a href="https://hexo.io/zh-cn/docs/tag-plugins.html#iframe" target="_blank" rel="noopener">iframe</a>，插入过程记录如下：</p>
<ol>
<li>要想在hexo文章中插入gif动画，首先得制作好动画<br>关于gif动画的制作，我的系统为Mac OS，因此使用受广大网友好评的LICEcap软件，该软件确实非常好用，专门录制git动态图，几乎没有学习成本，安装好就可以直接用了。关于如何用LICEcap录制gif图就不做介绍了，因为太简单了。<br><a href="https://www.cockos.com/licecap" target="_blank" rel="noopener">LICEcap下载地址</a></li>
<li>在Hexo主目录的source文件夹下新建iframe文件夹，将上面录制的gif图放到该目录</li>
<li><p>用hexo标签插件iframe在文章中引入上面制作的gif动画，引入方式如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法格式：&#123;% iframe url [width] [height] %&#125;</span><br><span class="line">由于本文是在本地引入，所以url为/iframe/filename.gif，示例如下：</span><br><span class="line">&#123;% iframe /iframe/pyhelloworld.gif %&#125;</span><br><span class="line">不指定宽度和高度则使用默认大小</span><br></pre></td></tr></table></figure>
</li>
<li><p>效果如下：</p>
<iframe src="/iframe/pyhelloworld.gif" width="100%" height="300" frameborder="0" allowfullscreen></iframe>
</li>
</ol>
<h4 id="Hexo-Next主题站点添加搜索功能"><a href="#Hexo-Next主题站点添加搜索功能" class="headerlink" title="Hexo Next主题站点添加搜索功能"></a>Hexo Next主题站点添加搜索功能</h4><ol>
<li><p>进入Hexo站点目录执行如下命令生成站点索引文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑站点配置文件，新增以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: all</span><br><span class="line">  format: html</span><br><span class="line">  <span class="built_in">limit</span>: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑Next主题配置文件，设置local_search配置的enable项为true</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  <span class="comment"># if auto, trigger search by changing input</span></span><br><span class="line">  <span class="comment"># if manual, trigger search by pressing enter key or search button</span></span><br><span class="line">  trigger: auto</span><br><span class="line">  <span class="comment"># show top n results per article, show all results by setting to -1</span></span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Hexo-Next主题添加文章及站点访问量统计"><a href="#Hexo-Next主题添加文章及站点访问量统计" class="headerlink" title="Hexo Next主题添加文章及站点访问量统计"></a>Hexo Next主题添加文章及站点访问量统计</h4><p>关于文章访问量统计新版next主题已经支持，内置使用不蒜子统计，是一个第三方服务。由于next主题已经内置支持该统计服务，因此不需要任何其他的配置，只需要修改该主题配置文件，将不蒜子统计功能激活即可。方法如下：<br>修改themes/next/_config.yml主题配置文件，找到busuanzi_count配置项，将不蒜子统计打开，修改后配置如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show PV/UV of the website/page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="comment"># 访问量统计,启用卜算子统计</span></span><br><span class="line">busuanzi_count:</span><br><span class="line"><span class="comment"># count values only if the other configs are false</span></span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line"><span class="comment"># custom uv span for the whole site</span></span><br><span class="line">site_uv: <span class="literal">true</span></span><br><span class="line">site_uv_header: &lt;i class=<span class="string">"fa fa-user"</span>&gt;&lt;/i&gt; 访问人数</span><br><span class="line">site_uv_footer:</span><br><span class="line"><span class="comment"># custom pv span for the whole site</span></span><br><span class="line">site_pv: <span class="literal">true</span></span><br><span class="line">site_pv_header: &lt;i class=<span class="string">"fa fa-eye"</span>&gt;&lt;/i&gt; 总访问量</span><br><span class="line">site_pv_footer: 次</span><br><span class="line"><span class="comment"># custom pv span for one page only</span></span><br><span class="line">page_pv: <span class="literal">true</span></span><br><span class="line">page_pv_header: &lt;i class=<span class="string">"fa fa-file-o"</span>&gt;&lt;/i&gt; 浏览</span><br><span class="line">page_pv_footer: 次</span><br></pre></td></tr></table></figure></p>
<p>效果如下：</p>
<ol>
<li>文章访问量<br><img src="/images/pv.png" alt=""></li>
<li>站点访问量<br><img src="/images/uv.png" alt=""></li>
</ol>
<p>参考链接：<br><a href="http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi" target="_blank" rel="noopener">http://theme-next.iissnan.com/third-party-services.html#analytics-busuanzi</a></p>
<h4 id="Hexo环境迁移"><a href="#Hexo环境迁移" class="headerlink" title="Hexo环境迁移"></a>Hexo环境迁移</h4><p>实现方法：在Hexo仓库新建一个hexo分支存放Hexo原始文件，master分支存放hexo生成的静态页面，如果迁移环境后可以直接git clone仓库即可。</p>
<ol>
<li><p>将Hexo仓库用git管理起来：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意：不需要再编写.gitignore了，在Hexo工程已经默认有.gitignore文件了，这是hexo默认生成的，也许是hexo本来就推荐用git管理hexo原始文件吧</span></span><br><span class="line">git init</span><br><span class="line">git checkout -b hexo</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">"init"</span></span><br><span class="line">git remote add origin https://github.com/qianghaohao/qianghaohao.github.io.git</span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>在新的环境克隆仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/qianghaohao/qianghaohao.github.io.git</span><br><span class="line"><span class="comment"># 切换到hexo分支即可看到hexo原始文件，此时可以编辑并提交。一般先提交原始文件到hexo分支，然后hexo d部署生成的静态文件到master分支</span></span><br><span class="line">git checkout hexo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考文章：<br><a href="http://m.blog.csdn.net/zk673820543/article/details/52698760" target="_blank" rel="noopener">http://m.blog.csdn.net/zk673820543/article/details/52698760</a></p>
<h4 id="Hexo-Markdown简明语法手册"><a href="#Hexo-Markdown简明语法手册" class="headerlink" title="Hexo Markdown简明语法手册"></a>Hexo Markdown简明语法手册</h4><p><a href="https://hyxxsfwy.github.io/2016/01/15/Hexo-Markdown-%E7%AE%80%E6%98%8E%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C/" target="_blank" rel="noopener">Hexo Markdown简明语法手册</a></p>
]]></content>
      
        <categories>
            
            <category> Hexo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在字符串列表中找出与s最长前缀匹配的字符串]]></title>
      <url>/2017/12/03/%E5%9C%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%97%E8%A1%A8%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%8Es%E6%9C%80%E9%95%BF%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h3 id="在字符串列表中找出与s最长前缀匹配的字符串"><a href="#在字符串列表中找出与s最长前缀匹配的字符串" class="headerlink" title="在字符串列表中找出与s最长前缀匹配的字符串"></a>在字符串列表中找出与s最长前缀匹配的字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closest_match</span><span class="params">(s, str_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    在字符串列表中找出与s最长前缀匹配的字符串</span></span><br><span class="line"><span class="string">    :param s:</span></span><br><span class="line"><span class="string">    :param str_list:</span></span><br><span class="line"><span class="string">    :return: 如果没有任何匹配则返回空串，否则返回最长前缀匹配</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    closest = <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> str <span class="keyword">in</span> str_list:</span><br><span class="line">        <span class="keyword">if</span> s.startswith(str):</span><br><span class="line">            <span class="keyword">if</span> closest:</span><br><span class="line">                <span class="keyword">if</span> len(str) &gt;= len(closest):</span><br><span class="line">                    closest = str</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                closest = str</span><br><span class="line">    <span class="keyword">return</span> closest</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Python </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Python </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Nginx入门指南]]></title>
      <url>/2017/12/03/Nginx%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/3766190-9339a28741405701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h1 id="Nginx入门指南"><a href="#Nginx入门指南" class="headerlink" title="Nginx入门指南"></a>Nginx入门指南</h1><p>##一.Nginx概述:</p>
<p>###1.什么是Nginx?<br>Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。<br>起初是供俄国大型的门户网站及搜索引擎Rambler（俄语：Рамблер）使用。此软件BSD-like协议下发行，可以在UNIX、GNU/Linux、BSD、Mac OS X、Solaris，以及Microsoft Windows等操作系统中运行。</p>
<p>###2.Nginx的特点:</p>
<ul>
<li><strong>更快:</strong><ul>
<li><strong>单次请求会得到更快的响应</strong></li>
<li><strong>在高并发环境下,Nginx比其他web服务器有更快的响应</strong></li>
</ul>
</li>
<li><strong>高扩展性:</strong><ul>
<li><strong>nginx是基于模块化设计,由多个耦合度极低的模块组成,因此具有很高的扩展性。许多高流量的网站都倾向于开发符合自己业务特性的定制模块。</strong></li>
</ul>
</li>
<li><strong>高可靠性:</strong><ul>
<li><strong>nginx的可靠性来自于其核心框架代码的优秀设计，模块设计的简单性；另外，官方提供的常用模块都非常稳定，每个worker进程相对独立，master进程在一个worker进程出错时可以快速拉起新的worker子进程提供服务。</strong></li>
</ul>
</li>
<li><strong>低内存消耗:</strong><ul>
<li><strong>一般情况下，10 000个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗2.5MB的内存，这是nginx支持高并发连接的基础。</strong></li>
</ul>
</li>
<li><strong>单机支持10万以上的并发连接:</strong><ul>
<li><strong>理论上，Nginx支持的并发连接上限取决于内存，10万远未封顶。 </strong></li>
</ul>
</li>
<li><strong>热部署:</strong><ul>
<li><strong>master进程与worker进程的分离设计，使得Nginx能够提供热部署功能，即在7x24小时不间断服务的前提下，升级Nginx的可执行文件。当然，它也支持不停止服务就更新配置项，更换日志文件等功能。</strong></li>
</ul>
</li>
<li><strong>最自由的BSD许可协议:</strong><ul>
<li><strong>这是Nginx可以快速发展的强大动力。BSD许可协议不只是允许用户免费使用Nginx，它还允许用户在自己的项目中直接使用或修改Nginx源码，然后发布。</strong><br>###3.目前web服务器市场份额图：<br><img src="./webserver.png" alt=""><br>###4.正向代理和反向代理的区别:</li>
<li><strong>正向代理(Forward Proxy):</strong><br>一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下：<br>正向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。如下图：<br><img src="./forward.png" alt=""></li>
<li><strong>反向代理(Reverse Proxy):</strong><br>反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。<br><strong>&nbsp;&nbsp;&nbsp;反向代理服务的作用:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>1.保护和隐藏原始资源服务器:</em><br><img src="./1487527542346.png" alt=""><br>由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>2.负载均衡:</em><br><img src="./1487527728657.png" alt=""><br>当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。<br>##二.安装Nginx:<br>###1.准备工作:</li>
<li><strong>Linux操作系统:</strong><br>内核为Linux 2.6及以上的版本的操作系统，因为2.6以上的内核才支持epoll，而在linux上使用select或poll来解决事件的多路复用，是无法解决高并发压力问题的。</li>
<li><strong>安装Nginx的必备软件:</strong></li>
</ul>
</li>
<li><strong>GCC编译器</strong></li>
<li><strong>PCRE库:是用C语言写的一个正则库，目前被很软件所使用。如果我们在配置文件nginx.conf里使用了正则表达式，那么在编译Nginx时就必须把PCRE库编译进Nginx，因为Nginx的HTTP模块要靠它来解析正则表达式。yum安装: yum install -y pcre pcre-devel</strong></li>
<li><strong>zlib库：zlib库用于对HTTP包的内容做gzaip格式的压缩，如果我们在nginx.conf里配置了gzip on，并指定对于某些类型的HTTP响应使用gzip来进行压缩以减少网络传输量，那么，在编译时就必须把zlib编译进Nginx。安装方式：yum install -y zlib zlib-devel</strong></li>
<li><strong>OpenSSL开发库:如果我们的服务器不只是要支持HTTP，还要在更安全的SSL协议上传输HTTP，那么就需要拥有OpenSSL了。安装方式：yum install -y openssl openssl-devel</strong><br>上面所列的4个库只是完成web服务器最基本功能所必须的。Nginx是模块化设计的，它的功能是由许多模块来支持的，所以如果使用了某个模块，而这个模块使用了一些第三方库，那么就必须先安装这些软件。<ul>
<li><strong>获取Nginx源码:</strong><br>Nginx官网:<a href="http://nginx.org" target="_blank" rel="noopener">http://nginx.org</a><br><img src="./1488039019886.png" alt=""></li>
</ul>
</li>
</ul>
<p><strong>在此下载Nginx最新版nginx-1.11.10:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.11.10.tar.gz -O - | tar zxvf -</span><br></pre></td></tr></table></figure></p>
<p>###2.编译安装Nginx:</p>
<ul>
<li><p><strong>首先安装前面提到的软件包:</strong></p>
<ul>
<li><p><strong>安装PCRE库:</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装zlib库:</strong></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装OpenSSL库:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>运行以上命令后可以查看是否安装成功:<br><img src="./1488087359555.png" alt=""></p>
<ul>
<li><strong>编译并安装nginx:</strong><br>Nginx源码目录介绍：<br><img src="./1488118637317.png" alt=""><ul>
<li><strong>进入nginx目录并执行configure命令:</strong><br>configure命令主要做一些系统相关的检测，并指定编译nginx时的一些参数，最终生成makefile供make来执行。<br>configure的命令参数可以通过如下命令来查看:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><img src="./1488119977606.png" alt=""><br>   <strong>执行configure命令，添加一些定制化参数，并生成makefile:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --with-debug</span><br></pre></td></tr></table></figure></p>
<p><strong>相关参数说明:</strong><br>   <strong>–with-http_ssl_module:</strong> 使nginx支持SSL协议，提供HTTPS服务。<br>   <strong>–with-http_stub_status_module:</strong>该模块可以让运行中的Nginx提供性能统计页面，获取相关的并发连接，请求信息。<br> <strong>–with-http_gzip_static_module:</strong>在做gzip压缩前，先查看相同位置是否有已经做过gzip压缩的.gz文件，如果有，就直接返回。<br> <strong>–with-debug:</strong>在nginx运行时通过修改配置文件来使其打印调试日志，这对于研究，定位nginx问题非常有帮助。<br><strong>configure命令执行完后，会在源码目录生成Makefile文件和一个objs目录:</strong><br>Makefile文件是指导make命令编译的脚本文件，objs目录存放编译过程中产生的二进制文件和一些configure产生的源代码文件。<br><strong>现在nginx源码目录树如下(红框圈出来的味新生成的目录):</strong><br><img src="./1488127919445.png" alt=""><br><img src="./1488128000832.png" alt=""></p>
<ul>
<li><p><strong>执行make命令编译:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行make install安装:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>###3.Nginx的使用:</p>
<ul>
<li><strong>默认方式启动nginx:</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这时，会读取默认路径下的配置文件:/usr/local/nginx/conf/nginx.conf</p>
<ul>
<li><strong>指定自定义配置文件启动:</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -c path/nginx.conf</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这时，会读取-c参数指定的配置文件来启动Nginx。</p>
<ul>
<li><strong>指定全局配置项的启动方式:</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -g <span class="string">"pid /var/nginx/test.pid;"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的命令意味着会把pid文件写入到/var/nginx/test.pid中。</p>
<ul>
<li><p><strong>测试配置文件是否有效:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在测试配置阶段不输出信息:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -t -q</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>测试配置选项是时，使用-q参数可以不把error级别以下的信息输出到屏幕。</p>
<ul>
<li><p><strong>显示版本信息:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -v</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>显示编译阶段的参数:</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>-V参数除了可以显示Nginx的版本信息外，还可以显示配置编译阶段的信息，如gcc编译器版本，操作系统版本，执行configure时的参数等。</p>
<ul>
<li><strong>快速地停止服务:</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用-s stop可以强制停止Nginx服务。-s参数其实是告诉Nginx程序向正在运行的Nginx服务发送信号，Nginx程序通过nginx.pid文件得到master进程的ID，再向运行中的master进程发送TERM信号来快速地关闭Nginx服务。<br><strong>同样可以给master进程发送TERM或者INT信号来快速停止:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -s SIGTERM NginxMasterPid</span><br><span class="line"><span class="built_in">kill</span> -s SIGINT NginxMasterPid</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>‘’优雅’’地停止服务:</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s quit</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果希望Nginx服务可以正常地处理完当前前所有请求再停止服务，那么可以使用-s quit参数来停止服务。这种方式首先会关闭监听端口，停止接收新的连接，然后把当前正则处理的连接全部处理完，最后再退出进程。<br><strong>同样可以发送信号的方式优雅地停止服务:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -s SIGQUIT NginxMasterPid</span><br></pre></td></tr></table></figure></p>
<p><strong>优雅地停止某个worker进程：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -s SIGWINCH NginxWorkerPid</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>使运行中的Nginx重新加载配置文件并生效:</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>同样可以通过kill发送信号来达到同样的效果:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -s SIGHUP NginxMasterPid</span><br></pre></td></tr></table></figure></p>
<p>##二.Nginx的配置:</p>
<h4 id="1-运行中的Nginx进程间的关系"><a href="#1-运行中的Nginx进程间的关系" class="headerlink" title="1.运行中的Nginx进程间的关系:"></a>1.运行中的Nginx进程间的关系:</h4><p>在正式提供服务的产品环境下，部署Nginx时都是使用一个master进程来管理多个worker进程，一般情况下，worker进程的数量与服务器上的CPU核心数相等。每一个worker进程都是繁忙的，他们真正地提供互联网服务，master进程则很”清闲”，只负责监控管理worker进程。部署后的Nginx进程间的关系如图下图所示:<br><img src="./1488387700110.png" alt=""></p>
<h4 id="2-Nginx配置中的通用语法"><a href="#2-Nginx配置中的通用语法" class="headerlink" title="2.Nginx配置中的通用语法:"></a>2.Nginx配置中的通用语法:</h4><p>Nginx的配置文件其实是一个普通的文本文件。下面来看一个简单的例子:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">    <span class="comment">#                  '$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">    <span class="comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    root           html;</span></span><br><span class="line">        <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">        <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">        <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">        <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx's one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">        <span class="comment">#    deny  all;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># another virtual host using mix of IP-, name-, and port-based configuration</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       8000;</span></span><br><span class="line">    <span class="comment">#    listen       somename:8080;</span></span><br><span class="line">    <span class="comment">#    server_name  somename  alias  another.alias;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#server &#123;</span></span><br><span class="line">    <span class="comment">#    listen       443 ssl;</span></span><br><span class="line">    <span class="comment">#    server_name  localhost;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_certificate      cert.pem;</span></span><br><span class="line">    <span class="comment">#    ssl_certificate_key  cert.key;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_session_cache    shared:SSL:1m;</span></span><br><span class="line">    <span class="comment">#    ssl_session_timeout  5m;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    ssl_ciphers  HIGH:!aNULL:!MD5;</span></span><br><span class="line">    <span class="comment">#    ssl_prefer_server_ciphers  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    location / &#123;</span></span><br><span class="line">    <span class="comment">#        root   html;</span></span><br><span class="line">    <span class="comment">#        index  index.html index.htm;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>块配置项:</strong><br>块配置项由一个块配置名和一对大括号组成。具体示例如下:<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">            <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码段中的events，http，server，location都是块配置项。块配置项可以嵌套，内层块直接继承外层块，例如，上例中server块里的任意配置都是基于http块里的已有配置的。当内外层中的配置发生冲突时，究竟是以内层块还是外层块的配置为准，取决于解析这个配置项的模块。</p>
<ul>
<li><strong>配置项的语法格式:</strong><br>最基本的配置项语法格式如下:<br><strong>配置项名 配置项值1 配置项值2 …；</strong><br>首先，在行首的是配置项名，这些配置项名必须是Nginx的某一个模块想要处理的，否则Nginx会认为配置文件出了非法的配置项名。配置项名输入结束后，将以空格作为分隔符。<br>其次是配置项值，它可以是数字或字符串(当然也包括正则表达式)。针对一个配置项，既可以有一个值，也可以有多个值，配置项值直接仍然由空格符来分隔。<br>最后，每行配置的结尾需要加上分号。</li>
<li><strong>配置项的注释:</strong><br>如果有一个配置项暂时需要注释掉，那么可以加 “#”注释掉这一行配置。</li>
<li><p><strong>配置项的单位:</strong><br>大部分模块遵循一些通用的规定，如指定空间大小时不用每次都定义到字节，指定时间时不用精确到毫秒。<br><strong>当指定空间大小时，可以用的单位包括：</strong></p>
<ul>
<li>K或者k千字节</li>
<li>M或者m兆字节<br>例如:<br>gzip_buffer 48k;<br>client_max_body_size 64M;</li>
</ul>
<p><strong>指定时间时，可以使用的单位包括：</strong></p>
<ul>
<li>ms，s，m，h，d，w，M，y<br>例如：<br>expires 10y;<br>proxy_read_timeout 600;<br>client_body_timeout 2m;</li>
</ul>
</li>
<li><strong>在配置中使用变量 :</strong><br>有些模块允许在配置中使用变量，具体示例如下:<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">'<span class="variable">$time_local</span>|10.4.24.116|<span class="variable">$request</span>|<span class="variable">$status</span>|'</span></span><br><span class="line">							                    <span class="string">'<span class="variable">$remote_user</span>|<span class="variable">$remote_addr</span>|<span class="variable">$http_user_agent</span>|<span class="variable">$http_referer</span>|<span class="variable">$host</span>|'</span></span><br><span class="line">							                    <span class="string">'<span class="variable">$bytes_sent</span>|<span class="variable">$request_time</span>|<span class="variable">$upstream_response_time</span>|<span class="variable">$upstream_addr</span>|'</span></span><br><span class="line">							                    <span class="string">'<span class="variable">$connection</span>|<span class="variable">$connection_requests</span>|<span class="variable">$upstream_http_content_type</span>|<span class="variable">$upstream_http_content_disposition</span>'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中变量前要加$符号。需要注意的是，这种变量只有少数模块支持，并不是通用的。<br><strong>注意⚠️ :</strong><br>在执行configure命令时，我们已经把许多模块编译进Nginx中，但是否启用这些模块，一般取决于配置文件中相应的配置项。换句话说，每个Nginx模块都有自己感兴趣的配置项，大部分模块都必须在nginx.conf中读取某个配置项后才会在运行时启动。例如，只有当配置http{…}这个配置项时，ngx_http_module模块才会在Nginx中启用，其他依赖ngx_http_module的模块才能正常使用。</p>
<h4 id="3-一个静态Web服务器常用的配置"><a href="#3-一个静态Web服务器常用的配置" class="headerlink" title="3.一个静态Web服务器常用的配置:"></a>3.一个静态Web服务器常用的配置:</h4><p>静态Web服务器的主要功能由ngx_http_core_module模块(HTTP框架的主要成员)实现，当然，一个完整的静态Web服务器还有许多功能是由其他的HTTP模块实现的。一个典型的静态Web服务器还会包含多个server块和location块，例如:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span>  web;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="attribute">error_log</span>  logs/error.log  <span class="literal">info</span>;</span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">'<span class="variable">$time_local</span>|10.4.24.116|<span class="variable">$request</span>|<span class="variable">$status</span>|'</span></span><br><span class="line">                    <span class="string">'<span class="variable">$remote_user</span>|<span class="variable">$remote_addr</span>|<span class="variable">$http_user_agent</span>|<span class="variable">$http_referer</span>|<span class="variable">$host</span>|'</span></span><br><span class="line">                    <span class="string">'<span class="variable">$bytes_sent</span>|<span class="variable">$request_time</span>|<span class="variable">$upstream_response_time</span>|<span class="variable">$upstream_addr</span>|'</span></span><br><span class="line">                    <span class="string">'<span class="variable">$connection</span>|<span class="variable">$connection_requests</span>|<span class="variable">$upstream_http_content_type</span>|<span class="variable">$upstream_http_content_disposition</span>'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">access_log</span>  logs/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>     <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">120</span> <span class="number">100</span>;</span><br><span class="line">    <span class="attribute">resolver_timeout</span>   <span class="number">15</span>;</span><br><span class="line">    <span class="attribute">client_body_timeout</span>        <span class="number">20</span>;</span><br><span class="line">    <span class="attribute">client_header_timeout</span>      <span class="number">20</span>;</span><br><span class="line">    <span class="attribute">client_body_buffer_size</span> <span class="number">512k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">1</span> <span class="number">512k</span>;</span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#APP</span></span><br><span class="line">    <span class="attribute">include</span> server/zapier.chime.me.conf;</span><br><span class="line">    <span class="attribute">include</span> server/https_app116.chime.me.conf;</span><br><span class="line">    <span class="attribute">include</span> server/http_app116.chime.me.conf;</span><br><span class="line">    <span class="comment">#CRM </span></span><br><span class="line">    <span class="attribute">include</span> server/https_test.chime.me.conf;</span><br><span class="line">    <span class="attribute">include</span> server/https_dev.chime.me.conf;</span><br><span class="line">    <span class="attribute">include</span> server/https_dev2.chime.me.conf;</span><br><span class="line">    <span class="attribute">include</span> server/https_static.chime.me.conf;</span><br><span class="line">    <span class="attribute">include</span> server/crmnginx.chime.me.conf;</span><br><span class="line">    <span class="attribute">include</span> server/brokernginx.chime.me.conf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> server/http_oldlender.chime.me.conf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> server/frontend.chime.me.conf;</span><br><span class="line">    <span class="attribute">include</span> server/chime.me.conf;</span><br><span class="line">    <span class="attribute">include</span> server/twilio.chime.me.conf;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> server/http_testzillow.chime.me.conf; </span><br><span class="line"></span><br><span class="line">    <span class="comment">#agnet 资历收集页图片地址 </span></span><br><span class="line">    <span class="attribute">include</span> server/uploadfile.conf;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#测试nginx status</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> *:<span class="number">80</span> ;</span><br><span class="line">        <span class="attribute">server_name</span> localhost status.chime.me;</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">location</span> /ngx_status &#123;</span><br><span class="line">            <span class="attribute">stub_status</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">allow</span> <span class="number">10.2.204.166</span>;</span><br><span class="line">            <span class="attribute">deny</span> all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所有的HTTP配置项必须直属于http块，location块，upstream块或if块。<br><strong>Web服务器常用配置项:</strong></p>
<ul>
<li><strong>虚拟主机与请求的分发:</strong><br>由于IP地址的数量有限，因此经常会存在多个主机域名对应着同一个IP地址的情况，这时在nginx.conf中就可以按照server_name并通过server块来定义虚拟主机，每个server块就是一个虚拟主机，它只处理与之相对应的主机域名请求。这样，一台服务器上的Nginx就能以不同的方式处理访问不同主机域名的HTTP请求了。<ul>
<li><strong>监听端口:</strong><br>默认:listen 80;<br>配置块:server<br>listen参数决定Nginx服务如何监听端口。在listen后可以只加IP地址，端口活主机名，非常灵活。</li>
<li><strong>主机名称:</strong><br>语法: server_name name […];<br>默认:server_name “”;<br>server_name后可以跟多个主机名称，如server_name www.testweb.com download.test.com;<br>在开始处理一个HTTP请求时，Nginx会取出header头重的Host，与每个server中的server_name进行匹配，以决定到底由哪一个server块来处理这个请求。有可能一个Host与多个server块中的server_name都匹配，这时就会根据匹配优先级来选择实际处理的server块。</li>
<li><strong>location:</strong><br>语法:location[=|~|~*|^~|@] /uri/ {…}<br>配置块:server<br>location会尝试根据用户请求中的URI来匹配上面的/uri表达式，如果可以匹配，就选择location {}块中的配置来处理用户请求。</li>
</ul>
</li>
<li><p><strong>文件路径的定义:</strong></p>
<ul>
<li><strong>以root方式设置资源路径:</strong><br>语法:root path<br>默认:root html<br>配置块:http，server，location，if<br>例如，定义资源文件相对于HTTP请求的根目录。<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location <span class="regexp">/download/</span> &#123;</span><br><span class="line">    root <span class="regexp">/opt/</span>web<span class="regexp">/html/</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在上面配置中，如果有一个请求的URI是/download/index/test.html，那么web服务器将会返回服务器上/opt/web/html/download/index/test.html</p>
<ul>
<li><strong>访问首页:</strong><br>语法:index file …;<br>默认:index index.html;<br>配置块:http,server,location<br>有时访问站点的URI是/，这时一般返回网站的首页。这里用ngx_http_index_module模块提供的index配置实现。index后可以跟多个文件参数，Nginx将会按照顺序来访问这些文件，例如:<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">location</span> / &#123;</span><br><span class="line">   root path;</span><br><span class="line">   <span class="keyword">index</span> /<span class="keyword">index</span>.html /html/inde.php /<span class="keyword">index</span>.php</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>接受到请求后，Nginx首先会尝试访问path/index.php文件，如果可以访问，就直接返回文件内容结束请求，否则再试图返回path/html/index.php的内容，依此类推。</p>
<ul>
<li><strong>网络连接的设置:</strong><ul>
<li><strong>读取HTTP头部的超时时间:</strong><br>语法:client_header_timeout time (默认单位:秒)<br>默认:client_header_timeout 60;<br>配置块:http, server, location<br>客户端与服务器建立连接后将开始接收HTTP头部，在这个过程中，如果在一个时间间隔内没有读取到客户端发来的字节，则认为超时，并向客户端返回408(“Rquest timed out”)响应。</li>
<li><strong>读取HTTP头部的超时时间:</strong><br>语法:client_body_timeout time (默认单位:秒)<br>默认:client_body_timeout 60;<br>配置块:http, server, location<br>此配置项与client_header_timeout相似，只是这个超时时间只在读取HTTP包体时才有效。</li>
<li><strong>发送响应的超时时间:</strong><br>语法:send_timeout time;<br>默认:send_timeout 60;<br>这个超时时间时发送响应的超时时间，即Nginx服务器向客户端发送了数据包，但客户端一直没有去接收这个数据包。如果某个连接超过send_timeout定义的超时时间，那么Nginx将会关闭这个连接。</li>
<li><strong>keepalive超时时间:</strong><br>语法:keepalive_timeout time (默认单位:秒)<br>默认:keepalive_timeout 75<br>配置块:http, server, location<br>一个keepalive_timeout连接在闲置超过一段时间后，服务器和浏览器都会去关闭这个连接。当然，keepalive_timeout配置项是用来约束Nginx服务器的，Nginx也会按照规范把这个时间传个浏览器，但每个浏览器对待keepalive的策略有可能是不同的。<h4 id="4-配置一个静态web服务器"><a href="#4-配置一个静态web服务器" class="headerlink" title="4.配置一个静态web服务器:"></a>4.配置一个静态web服务器:</h4>nginx的默认配置就是一个静态web服务器，启动后可以直接访问，配置文件如下:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">   <span class="built_in"> server </span>&#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"><span class="comment">#### 5.给Nginx的access log添加唯一的request id字段:</span></span><br><span class="line">- *<span class="number">*1</span>.下载uuid-perl模块:**</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>wget <a href="http://mirror.centos.org/centos/7/os/x86_64/Packages/uuid-perl-1.6.2-26.el7.x86_64.rpm" target="_blank" rel="noopener">http://mirror.centos.org/centos/7/os/x86_64/Packages/uuid-perl-1.6.2-26.el7.x86_64.rpm</a><br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>*<span class="strong">*2.yum安装上面下载的rpm包，自动解决依赖:*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure></p>
<p>yum install uuid-perl-1.6.2-26.el7.x86_64.rpm<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> **<span class="number">3</span>.重新编译ngixn，添加perl模块<span class="symbol">:**</span></span></span><br><span class="line"><span class="ruby"> 首先安装perl依赖库，要不然报错<span class="symbol">:</span></span></span><br></pre></td></tr></table></figure></p>
<p> sudo yum install -y perl-devel perl-ExtUtils-Embed<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后配置编译参数，执行configure生成<span class="string">makfile:</span></span><br></pre></td></tr></table></figure></p>
<p> ./configure –with-http_ssl_module –with-http_stub_status_module –with-http_gzip_static_module –with-debug –with-http_perl_module<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> **<span class="number">4</span>.修改nginx配置文件<span class="symbol">:**</span></span></span><br><span class="line"><span class="ruby"> ![](./<span class="number">1488432652846</span>.png)</span></span><br><span class="line"><span class="ruby">- **<span class="number">5</span>.重新加载配置文件即可生效<span class="symbol">:**</span></span></span><br></pre></td></tr></table></figure></p>
<p> sbin/nginx -s reload<br>```</p>
<ul>
<li><strong>6.效果如下:</strong><br><img src="./1488432839394.png" alt=""></li>
</ul>
]]></content>
      
        <categories>
            
            <category> Nginx </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2016/12/23/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[分类]]></title>
      <url>/categories/index.html</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title></title>
      <url>/js/busuanzi.pure.mini.js</url>
      <content type="html"><![CDATA[var bszCaller,bszTag;!function(){var c,d,e,a=!1,b=[];ready=function(c){return a||"interactive"===document.readyState||"complete"===document.readyState?c.call(document):b.push(function(){return c.call(this)}),this},d=function(){for(var a=0,c=b.length;c>a;a++)b[a].apply(document);b=[]},e=function(){a||(a=!0,d.call(window),document.removeEventListener?document.removeEventListener("DOMContentLoaded",e,!1):document.attachEvent&&(document.detachEvent("onreadystatechange",e),window==window.top&&(clearInterval(c),c=null)))},document.addEventListener?document.addEventListener("DOMContentLoaded",e,!1):document.attachEvent&&(document.attachEvent("onreadystatechange",function(){/loaded|complete/.test(document.readyState)&&e()}),window==window.top&&(c=setInterval(function(){try{a||document.documentElement.doScroll("left")}catch(b){return}e()},5)))}(),bszCaller={fetch:function(a,b){var c="BusuanziCallback_"+Math.floor(1099511627776*Math.random());window[c]=this.evalCall(b),a=a.replace("=BusuanziCallback","="+c),scriptTag=document.createElement("SCRIPT"),scriptTag.type="text/javascript",scriptTag.defer=!0,scriptTag.src=a,document.getElementsByTagName("HEAD")[0].appendChild(scriptTag)},evalCall:function(a){return function(b){ready(function(){try{a(b),scriptTag.parentElement.removeChild(scriptTag)}catch(c){bszTag.hides()}})}}},bszCaller.fetch("//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback",function(a){bszTag.texts(a),bszTag.shows()}),bszTag={bszs:["site_pv","page_pv","site_uv"],texts:function(a){this.bszs.map(function(b){var c=document.getElementById("busuanzi_value_"+b);c&&(c.innerHTML=a[b])})},hides:function(){this.bszs.map(function(a){var b=document.getElementById("busuanzi_container_"+a);b&&(b.style.display="none")})},shows:function(){this.bszs.map(function(a){var b=document.getElementById("busuanzi_container_"+a);b&&(b.style.display="inline")})}};
]]></content>
    </entry>
    
    <entry>
      <title></title>
      <url>/js/md5.min.js</url>
      <content type="html"><![CDATA[!function(n){"use strict";function t(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}function r(n,t){return="" n<<t|n="">>>32-t}function e(n,e,o,u,c,f){return t(r(t(t(e,n),t(u,f)),c),o)}function o(n,t,r,o,u,c,f){return e(t&r|~t&o,n,t,u,c,f)}function u(n,t,r,o,u,c,f){return e(t&o|r&~o,n,t,u,c,f)}function c(n,t,r,o,u,c,f){return e(t^r^o,n,t,u,c,f)}function f(n,t,r,o,u,c,f){return e(r^(t|~o),n,t,u,c,f)}function i(n,r){n[r>>5]|=128<<r%32,n[14+(r+64>>>9<<4)]=r;var e,i,a,d,h,l="1732584193,g=-271733879,v=-1732584194,m=271733878;for(e=0;e<n.length;e+=16)i=l,a=g,d=v,h=m,g=f(g=f(g=f(g=f(g=c(g=c(g=c(g=c(g=u(g=u(g=u(g=u(g=o(g=o(g=o(g=o(g,v=o(v,m=o(m,l=o(l,g,v,m,n[e],7,-680876936),g,v,n[e+1],12,-389564586),l,g,n[e+2],17,606105819),m,l,n[e+3],22,-1044525330),v=o(v,m=o(m,l=o(l,g,v,m,n[e+4],7,-176418897),g,v,n[e+5],12,1200080426),l,g,n[e+6],17,-1473231341),m,l,n[e+7],22,-45705983),v=o(v,m=o(m,l=o(l,g,v,m,n[e+8],7,1770035416),g,v,n[e+9],12,-1958414417),l,g,n[e+10],17,-42063),m,l,n[e+11],22,-1990404162),v=o(v,m=o(m,l=o(l,g,v,m,n[e+12],7,1804603682),g,v,n[e+13],12,-40341101),l,g,n[e+14],17,-1502002290),m,l,n[e+15],22,1236535329),v=u(v,m=u(m,l=u(l,g,v,m,n[e+1],5,-165796510),g,v,n[e+6],9,-1069501632),l,g,n[e+11],14,643717713),m,l,n[e],20,-373897302),v=u(v,m=u(m,l=u(l,g,v,m,n[e+5],5,-701558691),g,v,n[e+10],9,38016083),l,g,n[e+15],14,-660478335),m,l,n[e+4],20,-405537848),v=u(v,m=u(m,l=u(l,g,v,m,n[e+9],5,568446438),g,v,n[e+14],9,-1019803690),l,g,n[e+3],14,-187363961),m,l,n[e+8],20,1163531501),v=u(v,m=u(m,l=u(l,g,v,m,n[e+13],5,-1444681467),g,v,n[e+2],9,-51403784),l,g,n[e+7],14,1735328473),m,l,n[e+12],20,-1926607734),v=c(v,m=c(m,l=c(l,g,v,m,n[e+5],4,-378558),g,v,n[e+8],11,-2022574463),l,g,n[e+11],16,1839030562),m,l,n[e+14],23,-35309556),v=c(v,m=c(m,l=c(l,g,v,m,n[e+1],4,-1530992060),g,v,n[e+4],11,1272893353),l,g,n[e+7],16,-155497632),m,l,n[e+10],23,-1094730640),v=c(v,m=c(m,l=c(l,g,v,m,n[e+13],4,681279174),g,v,n[e],11,-358537222),l,g,n[e+3],16,-722521979),m,l,n[e+6],23,76029189),v=c(v,m=c(m,l=c(l,g,v,m,n[e+9],4,-640364487),g,v,n[e+12],11,-421815835),l,g,n[e+15],16,530742520),m,l,n[e+2],23,-995338651),v=f(v,m=f(m,l=f(l,g,v,m,n[e],6,-198630844),g,v,n[e+7],10,1126891415),l,g,n[e+14],15,-1416354905),m,l,n[e+5],21,-57434055),v=f(v,m=f(m,l=f(l,g,v,m,n[e+12],6,1700485571),g,v,n[e+3],10,-1894986606),l,g,n[e+10],15,-1051523),m,l,n[e+1],21,-2054922799),v=f(v,m=f(m,l=f(l,g,v,m,n[e+8],6,1873313359),g,v,n[e+15],10,-30611744),l,g,n[e+6],15,-1560198380),m,l,n[e+13],21,1309151649),v=f(v,m=f(m,l=f(l,g,v,m,n[e+4],6,-145523070),g,v,n[e+11],10,-1120210379),l,g,n[e+2],15,718787259),m,l,n[e+9],21,-343485551),l=t(l,i),g=t(g,a),v=t(v,d),m=t(m,h);return[l,g,v,m]}function" a(n){var="" t,r="" ,e="32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t">>5]>>>t%32&255);return r}function d(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e="8*n.length;for(t=0;t<e;t+=8)r[t">>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}function="" h(n){return="" a(i(d(n),8*n.length))}function="" l(n,t){var="" r,e,o="d(n),u=[],c=[];for(u[15]=c[15]=void" 0,o.length="">16&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e="i(u.concat(d(t)),512+8*t.length),a(i(c.concat(e),640))}function" g(n){var="" t,r,e="" ;for(r="0;r<n.length;r+=1)t=n.charCodeAt(r),e+="0123456789abcdef".charAt(t">>>4&15)+"0123456789abcdef".charAt(15&t);return e}function v(n){return unescape(encodeURIComponent(n))}function m(n){return h(v(n))}function p(n){return g(m(n))}function s(n,t){return l(v(n),v(t))}function C(n,t){return g(s(n,t))}function A(n,t,r){return t?r?s(t,n):C(t,n):r?m(n):p(n)}"function"==typeof define&&define.amd?define(function(){return A}):"object"==typeof module&&module.exports?module.exports=A:n.md5=A}(this);
//# sourceMappingURL=md5.min.js.map
</16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return></t%32;return></r.length;t+=1)r[t]=0;var></4)]=r;var></r%32,n[14+(r+64></16|65535&r}function>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[About me]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<h2 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h2><ul>
<li>GitHub: <a href="https://qhh.me" target="_blank" rel="noopener">https://qhh.me</a></li>
<li>CSDN: <a href="https://blog.csdn.net/qianghaohao" target="_blank" rel="noopener">https://blog.csdn.net/qianghaohao</a></li>
</ul>
<h2 id="社交"><a href="#社交" class="headerlink" title="社交"></a>社交</h2><p>QQ 技术交流群：282939416</p>
<blockquote>
<p>本群专注于 Jenkins 持续集成/持续交付、容器、Kubernetes、Golang、Python 相关话题！</p>
</blockquote>
<h2 id="我的-DevOps-技术栈"><a href="#我的-DevOps-技术栈" class="headerlink" title="我的 DevOps 技术栈"></a>我的 DevOps 技术栈</h2><p>技术图谱地址 <a href="https://github.com/qhh0205/my-devops-stack" target="_blank" rel="noopener">https://github.com/qhh0205/my-devops-stack</a></p>
<p><img src="/images/my-devops-stack.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[标签]]></title>
      <url>/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
